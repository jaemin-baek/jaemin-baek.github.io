[
    {
        "id": 1,
        "title": "Android Binder 메커니즘 심층 분석: IPC의 내부 동작 원리",
        "content": "## 1. Introduction: 왜 Binder인가?\n\n안드로이드 시스템을 깊이 있게 이해하려면 **Binder IPC(Inter-Process Communication)** 메커니즘을 피해갈 수 없습니다. 리눅스 커널 기반임에도 불구하고, 안드로이드는 왜 표준 System V IPC(Message Queues, Shared Memory, Semaphores) 대신 독자적인 Binder를 채택했을까요?\n\n가장 큰 이유는 **보안(Security)**과 **성능(Performance)**입니다. Binder는 프로세스 간 통신 시 송신자의 신원(UID/PID)을 커널 레벨에서 확실하게 검증하며, 단 한 번의 메모리 복사(One copy)만으로 데이터를 전달하는 효율적인 구조를 가지고 있습니다.\n\n이 글에서는 AIDL 뒤에 숨겨진 Binder 드라이버와 메모리 매핑(`mmap`)의 매커니즘을 코드로 직접 뜯어보며 분석합니다.\n\n---\n\n## 2. Architecture Overview\n\nBinder 아키텍처는 크게 4가지 컴포넌트로 나뉩니다.\n\n1.  **Client**: 서비스를 요청하는 프로세스\n2.  **Server**: 서비스를 제공하는 프로세스\n3.  **Service Manager**: 서비스의 위치(Handle)를 관리하는 DNS 역할\n4.  **Binder Driver**: 커널 공간에서 실제 데이터 전달을 담당 (`/dev/binder`)\n\n여기서 핵심은 **Binder Driver**입니다. 사용자 공간(User Space)의 프로세스들은 직접 메모리를 공유할 수 없기 때문에, 커널 공간을 통해 데이터를 주고받아야 합니다.\n\n### Memory Mapping (`mmap`)\n\nBinder의 고성능 비결은 `mmap`에 있습니다. 일반적인 IPC(예: 파이프)는 데이터 전송 시 'Sender -> Kernel' (1회), 'Kernel -> Receiver' (1회), 총 **2번의 메모리 복사**가 일어납니다.\n\n하지만 Binder는 프로세스 시작 시 `ProcessState` 생성자에서 `/dev/binder`를 열고 `mmap`을 호출하여 커널 공간의 버퍼와 사용자 공간의 버퍼를 매핑합니다.\n\n```cpp\n// frameworks/native/libs/binder/ProcessState.cpp\n\nProcessState::ProcessState(const char *driver)\n    : mDriverName(String8(driver))\n        , mDriverFD(open_driver(driver))\n        , mVMStart(MAP_FAILED)\n        // ...\n{\n    if (mDriverFD >= 0) {\n        // mmap the binder, providing a chunk of virtual address space to receive transactions.\n        mVMStart = mmap(0, BINDER_VM_SIZE, PROT_READ, MAP_PRIVATE | MAP_NORESERVE, mDriverFD, 0);\n        // ...\n    }\n}\n```\n\n이 매핑 덕분에 송신자가 데이터를 커널 버퍼에 복사하면(1회), 수신자는 별도의 복사 없이(0회) 그 데이터를 자신의 주소 공간에서 즉시 읽을 수 있습니다. 이것이 바로 **'One-copy'** 전략입니다.\n\n---\n\n## 3. Deep Dive: `ioctl` Traffic\n\n결국 모든 Binder 통신은 `ioctl` 시스템 콜로 귀결됩니다. `BINDER_WRITE_READ` 커맨드를 통해 데이터를 주고받죠. 실제로 어떤 데이터가 오가는지 구조체를 살펴봅시다.\n\n```c\nstruct binder_write_read {\n    binder_size_t write_size;  // 송신할 데이터 크기\n    binder_size_t write_consumed;\n    binder_uintptr_t write_buffer;\n\n    binder_size_t read_size;   // 수신할 데이터 크기\n    binder_size_t read_consumed;\n    binder_uintptr_t read_buffer;\n};\n```\n\n개발자가 AIDL(Android Interface Definition Language)을 작성하면, 빌드 툴이 자동으로 `Stub`과 `Proxy` 코드를 생성합니다. `Proxy`는 데이터를 직렬화(Parceling)하여 `transact()`를 호출하고, 이는 내부적으로 `IPCThreadState::transact()`를 거쳐 `ioctl`을 호출하게 됩니다.\n\n### Transaction Flow\n\n1.  **Client**: `data.writeString(\"hello\")` -> `remote->transact(...)`\n2.  **Kernel**: 클라이언트 스레드를 재우고(sleep), 데이터를 타겟 서버의 버퍼로 복사.\n3.  **Server**: Binder 스레드 풀에서 대기 중이던 스레드가 깨어나(wake up), 요청을 처리.\n4.  **Server**: `onTransact()` 실행 후 결과 반환.\n\n---\n\n## 4. Practical Implementation: Manual Binder\n\nAIDL 없이 직접 Binder를 구현해보면 이 흐름이 더 명확해집니다. 아래는 서비스 매니저 없이, Activity와 Service가 Binder를 통해 직접 통신하는 예제 코드입니다.\n\n```java\n// IRemoteService.java\npublic interface IRemoteService extends IInterface {\n    static final String DESCRIPTOR = \"com.jaemin.binder.IRemoteService\";\n    static final int TRANSACTION_getSystemStatus = IBinder.FIRST_CALL_TRANSACTION + 0;\n\n    String getSystemStatus() throws RemoteException;\n}\n\n// RemoteService.java (Server)\npublic class RemoteService extends Service {\n    private final Binder mBinder = new Binder() {\n        @Override\n        protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException {\n            if (code == IRemoteService.TRANSACTION_getSystemStatus) {\n                data.enforceInterface(IRemoteService.DESCRIPTOR);\n                // 실제 로직 수행\n                String status = \"CPU: 45%, Mem: 1.2GB\";\n                reply.writeNoException();\n                reply.writeString(status);\n                return true;\n            }\n            return super.onTransact(code, data, reply, flags);\n        }\n    };\n\n    // ... onBind returns mBinder\n}\n```\n\n위 코드에서 `onTransact` 메서드가 바로 커널에서 넘어온 데이터를 수신하는 진입점입니다. AIDL은 단지 이 과정을 추상화해줄 뿐, 본질은 `Parcel` 객체에 데이터를 쓰고(Marshaling) `TRANSACTION_CODE`로 기능을 구분하는 것에 있습니다.\n\n---\n\n## 5. Conclusion\n\nBinder는 안드로이드라는 거대한 OS를 지탱하는 척추와도 같습니다. Activity Manager가 앱을 시작할 때, PackageManager가 앱 정보를 조회할 때, 심지어 View가 화면에 그려질 때도 내부적으로는 Binder 통신이 일어납니다.\n\n상위 레벨 API에만 익숙해지기 쉽지만, 가끔은 이렇게 한 꺼풀 아래의 메커니즘을 들여다보는 것이 성능 최적화와 트러블슈팅에 큰 통찰력을 줍니다.\n\n> **Reference**\n> - Android Source Code (AOSP): frameworks/native/libs/binder\n> - Linux Kernel Source: drivers/android/binder.c\n",
        "tag": "Architecture",
        "date": "2025-12-11"
    }
]