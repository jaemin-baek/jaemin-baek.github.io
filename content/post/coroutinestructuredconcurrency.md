---
title: "[v.0.0] 구조적 동시성이란 무엇인가? 코루틴의 안정성과 예측 가능성을 위한 원칙"
date: 2025-03-08
draft: false
tags: ["kotlin", "coroutine", "structured concurrency", "job", "스코프", "비동기"]
categories: ["Kotlin"]
---

## 구조적 동시성이란 무엇인가?  
코루틴의 안정성과 예측 가능성을 위한 원칙

Kotlin의 코루틴 철학에서 가장 핵심적인 개념 중 하나가 바로 **구조적 동시성(Structured Concurrency)**이다.  
이 개념은 코루틴이 언제 시작되고 언제 종료되는지를 **코드의 구조(스코프)에 따라 명확하게 보장**하도록 만든다.

---

### 한줄 정의

> **구조적 동시성(Structured Concurrency)**이란  
> "**코루틴의 실행 범위와 생명주기를 코드 구조에 따라 명확하게 관리**하는 방식"이다.

---

### 왜 필요한가?

전통적인 비동기 코드에서는 다음과 같은 문제가 자주 발생한다:

- 콜백 지옥
- 예외가 무시됨
- 남은 코루틴이 언제 끝날지 알 수 없음
- 메모리 누수

구조적 동시성은 이를 해결한다.

| 항목 | 구조적 동시성에서 보장되는 동작 |
|------|----------------------------|
| 코루틴 생명주기 | 부모 스코프가 닫히면 자식 코루틴도 종료됨 |
| 예외 처리 | 자식 예외는 부모로 전파됨 (또는 Supervisor로 분리 처리) |
| 자원 누수 방지 | 스코프 바깥에 살아남는 코루틴 없음 |
| 테스트 가능성 | 어느 시점에 어떤 작업이 실행 중인지 추론 가능 |

---

### 예시: 구조적 동시성이 없는 코드

```kotlin
fun fetchData() {
    GlobalScope.launch {
        // 이 코루틴은 언제 끝날지 아무도 모름
    }
}
```

- `GlobalScope`는 앱 전체 생명주기에 묶여 있으므로 정리 불가
- 호출한 쪽에서는 **코루틴 취소, 예외 추적 불가능**

---

### 예시: 구조적 동시성이 적용된 코드

```kotlin
suspend fun fetchData() = coroutineScope {
    launch { getUser() }
    launch { getPosts() }
}
```

- `coroutineScope` 안에서 실행된 모든 코루틴은 이 블록이 끝날 때까지 완료되어야 한다.
- 이 블록이 끝난다는 것은 **모든 자식 코루틴이 정상 종료되었음을 보장**

---

### 구조적 동시성의 핵심 규칙

1. 모든 코루틴은 **명확한 부모 스코프** 내에서 실행된다
2. 부모가 종료되면 자식 코루틴도 자동으로 취소된다
3. 예외는 위로 전파되어 일관된 방식으로 처리된다

---

### Kotlin이 구조적 동시성을 지원하는 방식

| 구성 요소 | 역할 |
|-----------|------|
| `CoroutineScope` | 생명주기 단위 스코프 정의 |
| `coroutineScope {}` | suspend 함수 내부 일시적 스코프 |
| `SupervisorJob` | 자식 간 예외 전파 제어 |
| `withContext` | 부모-자식 관계를 유지한 채 컨텍스트 전환 |
| `viewModelScope`, `lifecycleScope` | Android 앱 생명주기에 연동된 구조적 스코프 제공 |

---

### 요약 정리


> 구조적 동시성은 **코루틴이 언제 시작되고 언제 종료되는지를 명확하게 통제**할 수 있도록 한다.  
> 이를 통해 개발자는 **예측 가능한 흐름, 자동 정리, 안정적인 에러 전파**를 기반으로  
> 복잡한 비동기 프로그램을 안전하게 설계할 수 있다.

