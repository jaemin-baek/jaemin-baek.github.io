[{"content":"Kotlin Coroutine의 멀티스레드 동작 방식 1. 개요 Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(CoroutineDispatcher)의 역할과 실행 흐름에 대해 서술한다.\n2. 코루틴과 스레드의 관계 Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.\n3. CoroutineDispatcher의 역할 CoroutineDispatcher는 코루틴이 실행될 스레드를 결정하는 핵심 컴포넌트이다. 주요 디스패처는 다음과 같다.\nDispatchers.Default: CPU 집약적인 작업을 위한 공유 스레드 풀을 사용한다. 일반적으로 코어 수에 비례한 스레드를 할당한다. Dispatchers.IO: 블로킹 I/O 작업에 최적화된 디스패처로, 더 많은 수의 스레드를 동적으로 생성하여 처리한다. Dispatchers.Main: UI 기반 애플리케이션에서 메인 스레드에서 실행되도록 보장한다. 안드로이드 또는 JavaFX 환경에서 사용된다. newSingleThreadContext(name: String): 명시적으로 단일 스레드를 생성하여 해당 코루틴만을 위해 사용할 수 있도록 한다. 각 디스패처는 코루틴이 실행되는 스레드의 종류를 정의함으로써, 개발자가 동시성 또는 병렬성을 세밀하게 제어할 수 있도록 한다.\n4. 실행 예시 및 스레드 분산 다음은 다양한 디스패처를 지정하여 코루틴이 각각 다른 스레드에서 실행되는 예시이다.\nimport kotlinx.coroutines.* fun main() = runBlocking { launch(Dispatchers.Default) { println(\u0026#34;Default dispatcher: ${Thread.currentThread().name}\u0026#34;) } launch(Dispatchers.IO) { println(\u0026#34;IO dispatcher: ${Thread.currentThread().name}\u0026#34;) } launch(newSingleThreadContext(\u0026#34;MyThread\u0026#34;)) { println(\u0026#34;Single thread context: ${Thread.currentThread().name}\u0026#34;) } } 위 예제는 세 개의 코루틴이 서로 다른 스레드에서 동시에 실행되는 구조를 갖는다. 이로써 코루틴이 단일 스레드에 국한되지 않으며, 디스패처 설정에 따라 명시적으로 병렬 실행이 가능함을 확인할 수 있다.\n실행 결과: Default dispatcher: DefaultDispatcher-worker-1 IO dispatcher: DefaultDispatcher-worker-2 Custom thread: CustomThread 5. 코루틴의 스레드 전환 코루틴은 withContext() 함수를 통해 실행 중인 스레드를 동적으로 전환할 수 있다. 이는 컨텍스트 전환(Context Switch)을 명시적으로 수행하는 것으로, 특정 블록의 실행을 다른 디스패처가 관리하도록 위임하는 방식이다.\nsuspend fun sample() { println(\u0026#34;Start: ${Thread.currentThread().name}\u0026#34;) withContext(Dispatchers.IO) { println(\u0026#34;IO context: ${Thread.currentThread().name}\u0026#34;) } println(\u0026#34;Resume: ${Thread.currentThread().name}\u0026#34;) } 이 구조는 코루틴의 유연성과 구조적 동시성(Structured Concurrency)을 강화하는 핵심 기제로 작용한다.\n실행 결과: Start: main IO context: DefaultDispatcher-worker-1 Resume: main 6. 동시성과 병렬성 코루틴은 기본적으로 협조적(concurrent) 실행을 지향하나, 다중 디스패처를 활용하면 병렬성(parallelism)도 구현 가능하다. async와 await를 활용하면 서로 독립적인 계산을 동시에 수행하면서 결과를 효율적으로 병합할 수 있다. 다음은 Kotlin의 async와 await를 활용하여 두 작업을 병렬로 실행하고, 그 결과를 합산하는 예제이다.\n// await: 결과가 준비될 때까지 suspend val resultA = async(Dispatchers.Default) { computeA() } val resultB = async(Dispatchers.IO) { computeB() } val combined = resultA.await() + resultB.await() 실행 흐름 설명 computeA()는 Dispatchers.Default 디스패처에서 실행되며, 이는 CPU 집약적인 작업을 위한 공용 스레드 풀을 사용한다. computeB()는 Dispatchers.IO 디스패처에서 실행되며, I/O 블로킹 작업에 최적화된 스레드 풀에서 처리된다. async를 통해 두 작업은 동시에 실행되며, 서로 다른 스레드에서 병렬로 수행된다. await()는 각각의 결과가 준비될 때까지 suspend 상태로 대기하며, 이 동안 다른 코루틴이 실행될 수 있다. 두 await() 호출이 완료되면 resultA와 resultB의 값을 더하여 combined에 결과를 저장한다. 이러한 병렬 실행은 코어 수에 따른 스레드 분산을 통해 실행 성능을 높이는 데 효과적이다.\n예시 구현 suspend fun computeA(): Int { println(\u0026#34;Running computeA on: ${Thread.currentThread().name}\u0026#34;) delay(500) return 10 } suspend fun computeB(): Int { println(\u0026#34;Running computeB on: ${Thread.currentThread().name}\u0026#34;) delay(1000) return 20 } 실행 결과: Running computeA on: DefaultDispatcher-worker-1 Running computeB on: DefaultDispatcher-worker-2 computeA()는 약 500ms 후 10을 반환하고, computeB()는 약 1000ms 후 20을 반환한다. 따라서 combined의 값은 30이다.\n7. 결론 Kotlin의 코루틴은 전통적인 스레드 기반 프로그래밍의 한계를 극복하고, 비동기 처리를 보다 안전하고 구조적으로 구현할 수 있도록 설계되었다. 멀티스레드 환경에서의 코루틴 실행은 디스패처 설정을 통해 세밀히 제어되며, 협조적 실행 모델을 기반으로 하되 병렬 처리를 통해 성능 최적화도 가능하다. 이는 현대 애플리케이션 개발에서 요구되는 고성능 동시 처리 요구를 효과적으로 충족시킨다.\nyaml 복사 편집\n","date":"2025-02-16T00:00:00Z","permalink":"https://jaemin-baek.github.io/post/coroutine/","title":"Kotlin 코루틴의 멀티스레드 동작 방식"}]