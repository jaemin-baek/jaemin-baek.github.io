[{"content":"Kotlin Coroutine에서 CoroutineScope와 coroutineScope 빌더의 개념적 차이 Kotlin 코루틴은 구조적 동시성(Structured Concurrency)을 구현하기 위해 다양한 스코프(scope) 기반의 실행 환경을 제공한다. 그중 CoroutineScope(...) 생성자와 coroutineScope {} 빌더는 이름이 유사하지만, 역할과 사용 위치, 생명주기 및 제어 방식에 있어 명확히 구분되는 개념이다. 본 문서에서는 이 둘의 본질적인 차이와 각각의 실용적 쓰임에 대해 기술한다.\n1. 개요 코루틴은 자체적인 실행 컨텍스트를 요구하며, 이를 정의하는 단위가 CoroutineScope이다. 코루틴 스코프는 일반적으로 명시적으로 생성하거나, 일시적으로 suspend 함수 내에서 빌더로 선언하여 사용된다. 이 두 방식은 각각 CoroutineScope(...) 생성자와 coroutineScope {} 빌더로 구분되며, 코드 구조와 실행 흐름에 결정적인 영향을 미친다.\n2. CoroutineScope(\u0026hellip;) 생성자 CoroutineScope(context: CoroutineContext)는 클래스나 객체 수준에서 코루틴 실행 환경을 명시적으로 구성할 때 사용된다. 생성된 스코프는 별도로 cancel()하거나 생명주기를 관리해야 하며, 장기 실행되는 컴포넌트(ViewModel, Service 등)에 적합하다.\nprivate val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default) scope.launch { // 장기 실행되는 비동기 작업 } 외부에서 scope.cancel()을 호출하면 해당 스코프 하위의 모든 코루틴이 취소된다. CoroutineScope는 클래스 필드나 전역 컨텍스트로 주입되며, 수동 관리가 필수이다. 3. coroutineScope { } 빌더 coroutineScope는 suspend fun 내부에서 사용 가능한 코루틴 빌더이며, 해당 블록 내에서 생성된 자식 코루틴들이 모두 완료되기 전까지 현재 코루틴을 일시 정지시킨다. 구조적 동시성을 구현하기 위한 핵심 기제로 작동하며, 블록 범위 외부로 생명주기가 확장되지 않는다.\nsuspend fun fetchAggregatedData(): AggregatedData = coroutineScope { val a = async { fetchA() } val b = async { fetchB() } AggregatedData(a.await(), b.await()) } 블록이 종료되면 자식 코루틴은 모두 정리되고 스코프도 자동으로 사라진다. coroutineScope 자체를 변수로 저장하거나 외부에서 cancel()하는 것은 불가능하다. 4. 비교 표 항목 CoroutineScope(...) coroutineScope { } 타입 클래스 생성자 suspend 함수 내 빌더 사용 위치 전역, 클래스 필드 등 suspend 함수 내부 생명주기 외부에서 수동으로 관리 (cancel()) 블록 내부에서 자동 관리됨 구조적 동시성 보장되지 않음 (설계에 따라 가능) 기본적으로 보장됨 외부에서 종료 가능 여부 가능 (cancel()) 불가능 자식 예외 전파 방식 Job 종류에 따라 다름 (ex. SupervisorJob) 자식 실패 시 전체 블록 취소 일반적 사용 용도 ViewModel, Repository, Service 등 장기 생존 객체 일시적 작업 조합, suspend 함수 내부 동시 실행 처리 5. 사용 예시 비교 5.1 CoroutineScope 예시 class DataFetcher { private val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO) fun startFetching() { scope.launch { fetchSomething() } } fun stop() { scope.cancel() // 명시적으로 종료 } } 장기 실행되는 비동기 작업을 관리하는 데 적합하며, cancel()을 통한 명확한 종료가 가능하다. 5.2 coroutineScope 예시 suspend fun fetchAll(): List\u0026lt;Result\u0026gt; = coroutineScope { val a = async { fetchA() } val b = async { fetchB() } listOf(a.await(), b.await()) } 일시적인 데이터 병렬 수집이나 처리 시에 적합하며, 외부 생명주기와 무관하다. 6. 결론 CoroutineScope(...)는 명시적 실행 환경을 구성하고, 생명주기를 외부에서 직접 제어해야 하는 경우에 사용된다. 반면 coroutineScope {}는 일시적이고 지역적인 suspend 블록으로서, 블록 내부의 자식 코루틴들의 실행을 제어하고, 자동 정리되는 구조적 동시성을 제공한다. 이 둘은 유사한 이름을 가졌으나, 설계 철학과 활용 맥락이 명확히 구분되어야 하며, 적절한 선택이 안정적이고 예측 가능한 코루틴 기반 시스템 설계의 핵심이 된다.\n","date":"2025-03-01T00:00:00Z","permalink":"https://jaemin-baek.github.io/post/coroutinescopevsbuilder/","title":"Kotlin Coroutine에서 CoroutineScope와 coroutineScope 빌더의 개념적 차이"},{"content":"Kotlin Coroutine에서 SupervisorJob의 역할과 scopeJob 구조 Kotlin 코루틴에서는 비동기 작업의 생명주기와 예외 처리를 체계적으로 관리하기 위해 Job 기반의 구조적 동시성을 제공한다. 본 문서에서는 그 중 SupervisorJob을 중심으로 하는 scopeJob의 역할과 필요성, 그리고 일반 Job과의 차이에 대해 고찰한다.\n1. 개요 코루틴은 CoroutineScope 내에서 생성된 자식 코루틴들과 부모 코루틴 간의 관계를 명확히 하여 예측 가능한 동시 실행을 가능하게 한다. 이때 Job은 각 코루틴의 생명주기를 추적하고, 취소 여부를 상위 또는 하위로 전파하는 핵심 구성요소로 작동한다. Kotlin에서는 Job 외에도 SupervisorJob이라는 특별한 형태의 Job을 제공하여, 자식 간의 실패 전파를 제어할 수 있다.\n2. 구조 예시 아래는 SupervisorJob을 기반으로 한 scopeJob을 생성하는 전형적인 코드 예시이다.\nprivate val scopeJob = SupervisorJob() private val scope = CoroutineScope(scopeJob + Dispatchers.Default) 이 구조는 scope 내에서 생성되는 모든 자식 코루틴이 SupervisorJob을 공유하도록 구성되며, 하나의 자식이 실패하더라도 다른 자식은 영향을 받지 않고 독립적으로 실행을 계속할 수 있도록 한다.\n3. SupervisorJob의 동작 원리 SupervisorJob은 일반 Job과 달리, 자식 코루틴이 실패(Exception 발생 등)하더라도 부모나 다른 자식 코루틴에게 실패를 전파하지 않는다. 이를 통해 고립된 실패 처리와 부분 성공 전략을 구현할 수 있다.\n항목 Job (기본) SupervisorJob 자식 실패 시 전체 스코프 취소 실패한 자식만 취소 형제 간 전파 예외 전파됨 전파되지 않음 사용 목적 전체 작업의 일관성 보장 부분 실패 허용, 독립 실행 구조 SupervisorJob은 supervisorScope {} 또는 직접 Scope를 구성할 때 명시적으로 사용되며, CoroutineScope(SupervisorJob()) 형태로 자주 활용된다.\n4. 실용적 사용 맥락 병렬로 다수의 외부 API를 호출할 때 자식 코루틴 중 하나가 실패하더라도 나머지 결과가 유효한 경우 백그라운드 데이터 동기화 작업에서 개별 요청 단위의 실패를 분리하고 싶은 경우 val scope = CoroutineScope(SupervisorJob() + Dispatchers.IO) scope.launch { // 개별 작업 1 } scope.launch { // 개별 작업 2 (실패해도 다른 작업에는 영향 없음) } 위 예제는 scope 내부에서 수행되는 코루틴들이 독립적인 실행 환경을 갖도록 보장한다.\n5. 예외 처리와 결합 실제 응용에서는 SupervisorJob과 함께 CoroutineExceptionHandler를 결합하여 보다 견고한 예외 처리를 구현할 수 있다.\nval exceptionHandler = CoroutineExceptionHandler { _, throwable -\u0026gt; logger.error(\u0026#34;Unhandled exception: $throwable\u0026#34;) } val scope = CoroutineScope(SupervisorJob() + Dispatchers.Default + exceptionHandler) 이 구조는 실패한 자식 코루틴의 예외를 처리하면서도 전체 스코프를 안정적으로 유지할 수 있게 한다.\n6. 결론 SupervisorJob은 Kotlin 코루틴 기반 구조에서 자식 간의 예외 전파를 분리하고, 작업 단위의 독립성과 견고성을 확보하기 위한 중요한 구성요소이다. 일반 Job이 전체 일괄 실패를 선호하는 전략이라면, SupervisorJob은 부분 실패를 수용하며 전체 서비스의 연속성을 유지하는 전략에 적합하다. 이를 통해 복잡한 비동기 시스템에서도 예측 가능한 실행 흐름과 회복 가능한 오류 처리가 가능해진다.\n","date":"2025-02-25T00:00:00Z","permalink":"https://jaemin-baek.github.io/post/supervisorjob/","title":"Kotlin Coroutine에서 SupervisorJob의 역할과 scopeJob 구조"},{"content":"Kotlin 코루틴의 실행 스코프 비교: runBlocking, coroutineScope, supervisorScope Kotlin의 코루틴 시스템은 다양한 실행 스코프 제공을 통해 구조적 동시성과 예외 분리를 가능하게 한다. 본 문서에서는 runBlocking, coroutineScope, supervisorScope의 기능과 목적을 비교하고, 각각의 사용 상황과 실행 흐름 차이에 대해 기술한다.\n1. 개요 코루틴은 전통적인 스레드 기반 프로그래밍에 비해 더 적은 리소스로 동시성을 지원하며, 이를 위해 다양한 스코프 빌더가 제공된다. 그중 runBlocking, coroutineScope, supervisorScope는 가장 자주 사용되는 고수준 코루틴 빌더로, 이들은 실행 방식과 예외 처리 구조에 있어 중요한 차이를 갖는다.\n2. 주요 차이점 요약 항목 runBlocking coroutineScope supervisorScope 차단 여부 호출한 스레드를 차단 차단하지 않음 (suspend) 차단하지 않음 (suspend) 사용 위치 main() 함수, 테스트 suspend 함수 내부 suspend 함수 내부 자식 실패 전파 자식 실패 시 전체 취소 자식 실패 시 전체 취소 실패해도 다른 자식은 계속 실행 생성 스코프 새 CoroutineScope 생성 상위 스코프 상속 SupervisorJob 기반 스코프 주요 목적 일반 코드와 코루틴 연결 구조적 동시성 예외 고립 및 분리 실행 3. runBlocking runBlocking은 코루틴 진입점을 제공하는 함수로, 일반적인 블로킹 코드(main 함수 등)에서 suspend 함수를 사용할 수 있도록 한다. 내부적으로 현재 스레드를 차단하며, 코루틴이 완료될 때까지 대기한다.\nfun main() = runBlocking { println(\u0026#34;Start\u0026#34;) delay(1000) println(\u0026#34;Done\u0026#34;) } 호출한 스레드를 직접 차단하며, UI 스레드에서는 사용을 지양해야 한다. CoroutineScope를 생성하여 내부에서 launch, async 등을 사용할 수 있다. 4. coroutineScope coroutineScope는 현재 컨텍스트를 상속하는 CoroutineScope를 생성하며, 내부의 모든 자식 코루틴이 종료될 때까지 suspend 상태로 대기한다. 이는 구조적 동시성을 구현하는 핵심 도구로 사용된다.\nsuspend fun run() { coroutineScope { launch { delay(500) println(\u0026#34;Child 1 done\u0026#34;) } launch { delay(1000) println(\u0026#34;Child 2 done\u0026#34;) } } println(\u0026#34;All children completed\u0026#34;) } 자식 중 하나라도 실패하면 전체 스코프가 취소된다. 일반적으로 suspend 함수 내에서 사용된다. 5. supervisorScope supervisorScope는 자식 코루틴 간 실패 전파를 막고, 하나의 실패가 다른 작업에 영향을 미치지 않도록 하는 예외 격리 기능을 제공한다. 내부적으로 SupervisorJob을 사용하여 고립된 실행 환경을 형성한다.\nsuspend fun run() { supervisorScope { launch { throw RuntimeException(\u0026#34;Child failed\u0026#34;) } launch { delay(1000) println(\u0026#34;Other child still runs\u0026#34;) } } } 하나의 자식이 예외를 발생시켜도 다른 자식은 계속 실행된다. 실시간 처리나 부분 실패를 허용하는 작업에 적합하다. 7. 결론 코루틴의 실행 컨텍스트 선택은 코드의 동시성 구조와 예외 처리 전략에 직접적인 영향을 미친다. runBlocking은 동기-비동기 경계를 연결하는 데 유용하며, coroutineScope는 구조적 동시성을 제공하고, supervisorScope는 자식 코루틴의 독립 실행을 보장한다. 각 스코프의 특성을 이해하고 상황에 맞게 사용하는 것이 안전하고 예측 가능한 비동기 프로그래밍을 구현하는 데 핵심이 된다.\n","date":"2025-02-19T00:00:00Z","permalink":"https://jaemin-baek.github.io/post/coroutinescope/","title":"Kotlin 코루틴의 runBlocking, coroutineScope, supervisorScope 비교"},{"content":"Kotlin Coroutine의 멀티스레드 동작 방식 1. 개요 Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(CoroutineDispatcher)의 역할과 실행 흐름에 대해 서술한다.\n2. 코루틴과 스레드의 관계 Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.\n3. CoroutineDispatcher의 역할 CoroutineDispatcher는 코루틴이 실행될 스레드를 결정하는 핵심 컴포넌트이다. 주요 디스패처는 다음과 같다.\nDispatchers.Default: CPU 집약적인 작업을 위한 공유 스레드 풀을 사용한다. 일반적으로 코어 수에 비례한 스레드를 할당한다. Dispatchers.IO: 블로킹 I/O 작업에 최적화된 디스패처로, 더 많은 수의 스레드를 동적으로 생성하여 처리한다. Dispatchers.Main: UI 기반 애플리케이션에서 메인 스레드에서 실행되도록 보장한다. 안드로이드 또는 JavaFX 환경에서 사용된다. newSingleThreadContext(name: String): 명시적으로 단일 스레드를 생성하여 해당 코루틴만을 위해 사용할 수 있도록 한다. 각 디스패처는 코루틴이 실행되는 스레드의 종류를 정의함으로써, 개발자가 동시성 또는 병렬성을 세밀하게 제어할 수 있도록 한다.\n4. 실행 예시 및 스레드 분산 다음은 다양한 디스패처를 지정하여 코루틴이 각각 다른 스레드에서 실행되는 예시이다.\nimport kotlinx.coroutines.* fun main() = runBlocking { launch(Dispatchers.Default) { println(\u0026#34;Default dispatcher: ${Thread.currentThread().name}\u0026#34;) } launch(Dispatchers.IO) { println(\u0026#34;IO dispatcher: ${Thread.currentThread().name}\u0026#34;) } launch(newSingleThreadContext(\u0026#34;MyThread\u0026#34;)) { println(\u0026#34;Single thread context: ${Thread.currentThread().name}\u0026#34;) } } 위 예제는 세 개의 코루틴이 서로 다른 스레드에서 동시에 실행되는 구조를 갖는다. 이로써 코루틴이 단일 스레드에 국한되지 않으며, 디스패처 설정에 따라 명시적으로 병렬 실행이 가능함을 확인할 수 있다.\n실행 결과: Default dispatcher: DefaultDispatcher-worker-1 IO dispatcher: DefaultDispatcher-worker-1 Single thread context: MyThread 그런데 Default, IO 가 기대했던 DefaultDispatcher-worker-1 , DefaultDispatcher-worker-2 가 아니다.\n이건 Dispatchers.Default와 Dispatchers.IO가 같은 스레드에서 실행된 것처럼 보이는 현상인데 이유는 아래와 같다.\n왜 Dispatchers.Default와 IO가 같은 스레드 이름일까? 공유 풀을 사용 중 Dispatchers.Default와 Dispatchers.IO는 모두 스레드 풀(thread pool) 기반이다. 둘 다 내부적으로 DefaultExecutor와 IOExecutor를 공유하는 구조가 있다. JVM이 할당한 첫 번째 워커 스레드(worker-1)가 여러 코루틴에 재사용될 수 있다. Dispatcher 설명 Dispatchers.Default CPU 중심 작업용, 코어 수만큼의 스레드 풀 사용 Dispatchers.IO I/O 중심 작업용, 무제한 스레드 풀, 내부적으로 Default를 재사용함 newSingleThreadContext() 오직 1개의 전용 스레드만 사용하는 디스패처, 명시적으로 생성한 스레드 사용 즉, 같은 워커가 같은 순간에 여러 코루틴을 처리하지 않더라도, 스레드 풀 안에서 동적으로 배정되다 보니 같은 이름이 출력될 수 있다.\n작은 예제라 워커 수가 1개로 충분한 상황 runBlocking + 3개의 launch를 실행할 뿐이라서, 코어 수가 충분하거나 작업이 짧을 경우 JVM은 worker-1만 사용한다. 내부적으로 DefaultDispatcher-worker-1, -2, -3 등이 필요 시 생성\n확인 실험 fun main() = runBlocking { repeat(10) { launch(Dispatchers.Default) { println(\u0026#34;Default dispatcher: ${Thread.currentThread().name}\u0026#34;) } launch(Dispatchers.IO) { println(\u0026#34;IO dispatcher: ${Thread.currentThread().name}\u0026#34;) } } launch(newSingleThreadContext(\u0026#34;MyThread\u0026#34;)) { println(\u0026#34;Single thread context: ${Thread.currentThread().name}\u0026#34;) } } 실행 결과 Default dispatcher: DefaultDispatcher-worker-1 IO dispatcher: DefaultDispatcher-worker-1 Default dispatcher: DefaultDispatcher-worker-1 IO dispatcher: DefaultDispatcher-worker-2 Default dispatcher: DefaultDispatcher-worker-1 IO dispatcher: DefaultDispatcher-worker-4 Default dispatcher: DefaultDispatcher-worker-3 Default dispatcher: DefaultDispatcher-worker-1 IO dispatcher: DefaultDispatcher-worker-2 IO dispatcher: DefaultDispatcher-worker-6 Default dispatcher: DefaultDispatcher-worker-2 IO dispatcher: DefaultDispatcher-worker-6 Default dispatcher: DefaultDispatcher-worker-5 Default dispatcher: DefaultDispatcher-worker-7 IO dispatcher: DefaultDispatcher-worker-5 Default dispatcher: DefaultDispatcher-worker-6 Default dispatcher: DefaultDispatcher-worker-7 IO dispatcher: DefaultDispatcher-worker-3 IO dispatcher: DefaultDispatcher-worker-5 IO dispatcher: DefaultDispatcher-worker-4 Single thread context: MyThread 5. 코루틴의 스레드 전환 코루틴은 withContext() 함수를 통해 실행 중인 스레드를 동적으로 전환할 수 있다. 이는 컨텍스트 전환(Context Switch)을 명시적으로 수행하는 것으로, 특정 블록의 실행을 다른 디스패처가 관리하도록 위임하는 방식이다.\nsuspend fun sample() { println(\u0026#34;Start: ${Thread.currentThread().name}\u0026#34;) withContext(Dispatchers.IO) { println(\u0026#34;IO context: ${Thread.currentThread().name}\u0026#34;) } println(\u0026#34;Resume: ${Thread.currentThread().name}\u0026#34;) } 이 구조는 코루틴의 유연성과 구조적 동시성(Structured Concurrency)을 강화하는 핵심 기제로 작용한다.\n실행 결과: Start: main IO context: DefaultDispatcher-worker-1 Resume: main 6. 동시성과 병렬성 코루틴은 기본적으로 협조적(concurrent) 실행을 지향하나, 다중 디스패처를 활용하면 병렬성(parallelism)도 구현 가능하다. async와 await를 활용하면 서로 독립적인 계산을 동시에 수행하면서 결과를 효율적으로 병합할 수 있다. 다음은 Kotlin의 async와 await를 활용하여 두 작업을 병렬로 실행하고, 그 결과를 합산하는 예제이다.\n// await: 결과가 준비될 때까지 suspend val resultA = async(Dispatchers.Default) { computeA() } val resultB = async(Dispatchers.IO) { computeB() } val combined = resultA.await() + resultB.await() 실행 흐름 설명 computeA()는 Dispatchers.Default 디스패처에서 실행되며, 이는 CPU 집약적인 작업을 위한 공용 스레드 풀을 사용한다. computeB()는 Dispatchers.IO 디스패처에서 실행되며, I/O 블로킹 작업에 최적화된 스레드 풀에서 처리된다. async를 통해 두 작업은 동시에 실행되며, 서로 다른 스레드에서 병렬로 수행된다. await()는 각각의 결과가 준비될 때까지 suspend 상태로 대기하며, 이 동안 다른 코루틴이 실행될 수 있다. 두 await() 호출이 완료되면 resultA와 resultB의 값을 더하여 combined에 결과를 저장한다. 이러한 병렬 실행은 코어 수에 따른 스레드 분산을 통해 실행 성능을 높이는 데 효과적이다.\n예시 구현 suspend fun computeA(): Int { println(\u0026#34;Running computeA on: ${Thread.currentThread().name}\u0026#34;) delay(500) return 10 } suspend fun computeB(): Int { println(\u0026#34;Running computeB on: ${Thread.currentThread().name}\u0026#34;) delay(1000) return 20 } 실행 결과: Running computeA on: DefaultDispatcher-worker-1 Running computeB on: DefaultDispatcher-worker-2 computeA()는 약 500ms 후 10을 반환하고, computeB()는 약 1000ms 후 20을 반환한다. 따라서 combined의 값은 30이다.\n7. 결론 Kotlin의 코루틴은 전통적인 스레드 기반 프로그래밍의 한계를 극복하고, 비동기 처리를 보다 안전하고 구조적으로 구현할 수 있도록 설계되었다. 멀티스레드 환경에서의 코루틴 실행은 디스패처 설정을 통해 세밀히 제어되며, 협조적 실행 모델을 기반으로 하되 병렬 처리를 통해 성능 최적화도 가능하다. 이는 현대 애플리케이션 개발에서 요구되는 고성능 동시 처리 요구를 효과적으로 충족시킨다.\n","date":"2025-02-16T00:00:00Z","permalink":"https://jaemin-baek.github.io/post/coroutine/","title":"Kotlin 코루틴의 멀티스레드 동작 방식"}]