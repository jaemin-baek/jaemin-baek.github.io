<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>WithContext on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/withcontext/</link><description>Recent content in WithContext on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/withcontext/index.xml" rel="self" type="application/rss+xml"/><item><title>[v.0.0] Kotlin Coroutine에서 withContext, launch, async의 개념 및 실행 방식 비교</title><link>https://jaemin-baek.github.io/post/withcontext/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/withcontext/</guid><description>&lt;h2 id="kotlin-coroutine에서-withcontext-launch-async의-개념-및-실행-방식-비교">Kotlin Coroutine에서 withContext, launch, async의 개념 및 실행 방식 비교
&lt;/h2>&lt;p>Kotlin 코루틴은 비동기 흐름 제어를 위한 고수준 추상화를 제공하며, 이를 위한 핵심 도구로 &lt;code>withContext&lt;/code>, &lt;code>launch&lt;/code>, &lt;code>async&lt;/code>가 사용된다. 이 세 도구는 각각 목적과 동작 방식이 뚜렷하게 구분되며, 올바른 사용을 위해 그 차이를 명확히 이해하는 것이 중요하다. 본 문서에서는 이 세 가지 코루틴 구성 요소의 구조적 차이, 실행 방식, 반환값, 예외 처리 특성을 중심으로 비교하고 그 활용 맥락을 제시한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개념적-정의">1. 개념적 정의
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>기본 용도&lt;/th>
&lt;th>실행 컨텍스트&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>withContext&lt;/code>&lt;/td>
&lt;td>컨텍스트 전환 및 작업 수행&lt;/td>
&lt;td>같은 코루틴 내에서 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>launch&lt;/code>&lt;/td>
&lt;td>새로운 코루틴 시작 (단순 실행)&lt;/td>
&lt;td>독립된 Job 생성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>async&lt;/code>&lt;/td>
&lt;td>결과값 반환이 필요한 코루틴 시작&lt;/td>
&lt;td>&lt;code>Deferred&amp;lt;T&amp;gt;&lt;/code> 반환&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="2-시그니처-비교">2. 시그니처 비교
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">withContext&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context: CoroutineContext,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> block: &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): T
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.async(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context: CoroutineContext = EmptyCoroutineContext,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> block: &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): Deferred&amp;lt;T&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>withContext: suspend 함수이며, 호출한 코루틴의 흐름을 일시 정지하고 컨텍스트 전환 후 실행&lt;/li>
&lt;li>launch: 새로운 코루틴을 시작하고 Job을 반환&lt;/li>
&lt;li>async: 결과값을 비동기적으로 계산하며 Deferred&lt;!-- raw HTML omitted -->를 반환&lt;/li>
&lt;/ul>
&lt;h3 id="3-사용-예시">3. 사용 예시
&lt;/h3>&lt;h4 id="31-withcontext">3.1 withContext
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">loadData&lt;/span>(): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 블로킹 IO → 비동기 전환
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> fetchDataFromNetwork()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>현재 코루틴을 일시 정지하고 Dispatchers.IO로 전환하여 작업을 수행&lt;/li>
&lt;li>완료 후 이전 컨텍스트로 복귀&lt;/li>
&lt;/ul>
&lt;h4 id="32-launch">3.2 launch
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">startLogging&lt;/span>(scope: CoroutineScope) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Logging started.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>독립 실행 → 결과 반환 없이 작업 수행&lt;/li>
&lt;li>Job을 통해 수명 및 취소 여부 제어 가능&lt;/li>
&lt;/ul>
&lt;h4 id="33-async">3.3 async
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">aggregate&lt;/span>(): Int = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async { computeA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async { computeB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.await() + b.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>결과가 필요한 두 작업을 병렬로 실행&lt;/li>
&lt;li>await() 호출 시 각각의 연산 결과를 비동기적으로 수집&lt;/li>
&lt;/ul>
&lt;h3 id="4-비교-요약-표">4. 비교 요약 표
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>withContext&lt;/code>&lt;/th>
&lt;th>&lt;code>launch&lt;/code>&lt;/th>
&lt;th>&lt;code>async&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>새 코루틴 생성 여부&lt;/td>
&lt;td>❌ (현재 코루틴 내부에서 실행)&lt;/td>
&lt;td>✅ 새 코루틴 시작&lt;/td>
&lt;td>✅ 새 코루틴 시작&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>반환값&lt;/td>
&lt;td>✅ 반환값을 직접 반환&lt;/td>
&lt;td>❌ 반환값 없음 (&lt;code>Unit&lt;/code>)&lt;/td>
&lt;td>✅ &lt;code>Deferred&amp;lt;T&amp;gt;&lt;/code>로 비동기 결과 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>병렬 실행&lt;/td>
&lt;td>❌ 순차 실행&lt;/td>
&lt;td>✅ 병렬 가능&lt;/td>
&lt;td>✅ 병렬 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 전파 방식&lt;/td>
&lt;td>즉시 전파됨&lt;/td>
&lt;td>부모 &lt;code>Job&lt;/code>으로 전파됨&lt;/td>
&lt;td>&lt;code>await()&lt;/code> 시 전파됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>컨텍스트 전환&lt;/td>
&lt;td>✅ 주 용도&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>취소 전파&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주 사용 목적&lt;/td>
&lt;td>컨텍스트 전환 + 결과 처리&lt;/td>
&lt;td>단순한 백그라운드 실행&lt;/td>
&lt;td>병렬 작업 + 결과 수집&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="5-결론">5. 결론
&lt;/h3>&lt;p>&lt;code>withContext&lt;/code>, &lt;code>launch&lt;/code>, &lt;code>async&lt;/code>는 Kotlin 코루틴의 비동기 실행 모델을 구성하는 핵심 도구로서, 각기 다른 목적과 특성을 가진다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>withContext&lt;/code>는 &lt;strong>기존 코루틴의 흐름 안에서 Dispatcher나 Job 등 컨텍스트만 전환&lt;/strong>하여 특정 블록을 실행하고 결과를 반환하는 데 사용된다.&lt;/li>
&lt;li>&lt;code>launch&lt;/code>는 &lt;strong>새로운 코루틴을 시작하여 병렬로 독립적인 작업을 수행&lt;/strong>하는 데 적합하며, 결과값이 필요 없는 단순 작업에 주로 쓰인다.&lt;/li>
&lt;li>&lt;code>async&lt;/code>는 &lt;strong>결과값을 반환해야 하는 병렬 작업&lt;/strong>에 적합하며, &lt;code>Deferred&amp;lt;T&amp;gt;&lt;/code>를 통해 &lt;code>await()&lt;/code>로 값을 추후 사용할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;p>이들 각각은 코루틴의 &lt;strong>생명주기 관리, 예외 처리 흐름, 병렬성 확보 방식&lt;/strong>에 차이를 가지며, 목적에 맞는 선택을 통해 더 안정적이고 예측 가능한 비동기 시스템을 설계할 수 있다.&lt;/p></description></item></channel></rss>