<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Structured Concurrency on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/structured-concurrency/</link><description>Recent content in Structured Concurrency on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 19 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/structured-concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>구조적 동시성이란 무엇인가? 코루틴의 안정성과 예측 가능성을 위한 원칙</title><link>https://jaemin-baek.github.io/post/coroutinestructuredconcurrency/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinestructuredconcurrency/</guid><description>&lt;h2 id="구조적-동시성이란-무엇인가">구조적 동시성이란 무엇인가?
&lt;/h2>&lt;p>코루틴의 안정성과 예측 가능성을 위한 원칙&lt;/p>
&lt;p>Kotlin의 코루틴 철학에서 가장 핵심적인 개념 중 하나가 바로 **구조적 동시성(Structured Concurrency)**이다.&lt;br>
이 개념은 코루틴이 언제 시작되고 언제 종료되는지를 &lt;strong>코드의 구조(스코프)에 따라 명확하게 보장&lt;/strong>하도록 만든다.&lt;/p>
&lt;hr>
&lt;h3 id="한줄-정의">한줄 정의
&lt;/h3>&lt;blockquote>
&lt;p>**구조적 동시성(Structured Concurrency)**이란&lt;br>
&amp;ldquo;&lt;strong>코루틴의 실행 범위와 생명주기를 코드 구조에 따라 명확하게 관리&lt;/strong>하는 방식&amp;quot;이다.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h3 id="왜-필요한가">왜 필요한가?
&lt;/h3>&lt;p>전통적인 비동기 코드에서는 다음과 같은 문제가 자주 발생한다:&lt;/p>
&lt;ul>
&lt;li>콜백 지옥&lt;/li>
&lt;li>예외가 무시됨&lt;/li>
&lt;li>남은 코루틴이 언제 끝날지 알 수 없음&lt;/li>
&lt;li>메모리 누수&lt;/li>
&lt;/ul>
&lt;p>구조적 동시성은 이를 해결한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>구조적 동시성에서 보장되는 동작&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>코루틴 생명주기&lt;/td>
&lt;td>부모 스코프가 닫히면 자식 코루틴도 종료됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 처리&lt;/td>
&lt;td>자식 예외는 부모로 전파됨 (또는 Supervisor로 분리 처리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 누수 방지&lt;/td>
&lt;td>스코프 바깥에 살아남는 코루틴 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>테스트 가능성&lt;/td>
&lt;td>어느 시점에 어떤 작업이 실행 중인지 추론 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="예시-구조적-동시성이-없는-코드">예시: 구조적 동시성이 없는 코드
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GlobalScope&lt;/span>.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 이 코루틴은 언제 끝날지 아무도 모름
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>GlobalScope&lt;/code>는 앱 전체 생명주기에 묶여 있으므로 정리 불가&lt;/li>
&lt;li>호출한 쪽에서는 &lt;strong>코루틴 취소, 예외 추적 불가능&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="예시-구조적-동시성이-적용된-코드">예시: 구조적 동시성이 적용된 코드
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { getUser() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { getPosts() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>coroutineScope&lt;/code> 안에서 실행된 모든 코루틴은 이 블록이 끝날 때까지 완료되어야 한다.&lt;/li>
&lt;li>이 블록이 끝난다는 것은 &lt;strong>모든 자식 코루틴이 정상 종료되었음을 보장&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="구조적-동시성의-핵심-규칙">구조적 동시성의 핵심 규칙
&lt;/h3>&lt;ol>
&lt;li>모든 코루틴은 &lt;strong>명확한 부모 스코프&lt;/strong> 내에서 실행된다&lt;/li>
&lt;li>부모가 종료되면 자식 코루틴도 자동으로 취소된다&lt;/li>
&lt;li>예외는 위로 전파되어 일관된 방식으로 처리된다&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="kotlin이-구조적-동시성을-지원하는-방식">Kotlin이 구조적 동시성을 지원하는 방식
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>CoroutineScope&lt;/code>&lt;/td>
&lt;td>생명주기 단위 스코프 정의&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>coroutineScope {}&lt;/code>&lt;/td>
&lt;td>suspend 함수 내부 일시적 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 간 예외 전파 제어&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>withContext&lt;/code>&lt;/td>
&lt;td>부모-자식 관계를 유지한 채 컨텍스트 전환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>viewModelScope&lt;/code>, &lt;code>lifecycleScope&lt;/code>&lt;/td>
&lt;td>Android 앱 생명주기에 연동된 구조적 스코프 제공&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="요약-정리">요약 정리
&lt;/h3>&lt;blockquote>
&lt;p>구조적 동시성은 &lt;strong>코루틴이 언제 시작되고 언제 종료되는지를 명확하게 통제&lt;/strong>할 수 있도록 한다.&lt;br>
이를 통해 개발자는 &lt;strong>예측 가능한 흐름, 자동 정리, 안정적인 에러 전파&lt;/strong>를 기반으로&lt;br>
복잡한 비동기 프로그램을 안전하게 설계할 수 있다.&lt;/p>&lt;/blockquote></description></item><item><title>구조적 동시성과 SupervisorJob의 실제 설계 활용</title><link>https://jaemin-baek.github.io/post/coroutinestructured/</link><pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinestructured/</guid><description>&lt;h3 id="1-구조적-동시성이란">1. 구조적 동시성이란?
&lt;/h3>&lt;p>코루틴은 &lt;strong>스코프 기반으로 생성되며&lt;/strong>, 스코프가 종료되면&lt;br>
하위의 모든 자식 코루틴도 함께 종료된다.&lt;/p>
&lt;p>즉, 부모가 죽으면 자식도 죽고, 자식이 죽으면 부모도 영향을 받는다.&lt;br>
이는 다음과 같은 전통적인 구조를 따른다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { taskA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { taskB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>taskA()&lt;/code>에서 예외가 발생하면 → 부모 코루틴도 취소됨&lt;/li>
&lt;li>따라서 &lt;code>taskB()&lt;/code>도 함께 취소된다&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-문제-상황-일부-실패는-무시하고-싶을-때">2. 문제 상황: 일부 실패는 무시하고 싶을 때
&lt;/h3>&lt;h4 id="예-병렬-api-요청-처리">예: 병렬 API 요청 처리
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> comments = async { fetchComments() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> suggestions = async { fetchSuggestions() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AggregatedData(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> comments = comments.await(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> suggestions = suggestions.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>fetchComments()&lt;/code>에서 예외 발생 시 → &lt;code>fetchSuggestions()&lt;/code>도 중단됨&lt;/li>
&lt;li>전체가 실패로 처리됨 → &lt;strong>너무 강한 연결 구조&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-해결책-supervisorjob을-사용한-독립-실행-구조">3. 해결책: &lt;code>SupervisorJob&lt;/code>을 사용한 독립 실행 구조
&lt;/h3>&lt;p>&lt;code>SupervisorJob&lt;/code>을 사용하면,&lt;br>
&lt;strong>자식 중 하나가 예외를 던져도 다른 자식에 영향을 주지 않는다.&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> dataA = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> dataB = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = ResultData(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dataA = dataA.await(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dataB = dataB.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#66d9ef">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>fetchA()&lt;/code>가 실패해도 &lt;code>fetchB()&lt;/code>는 정상 실행됨&lt;/li>
&lt;li>각각 독립적으로 예외 처리하고, 전체 구조는 안정성을 유지함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-내부-구조-요약">4. 내부 구조 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Job 유형&lt;/th>
&lt;th>예외 전파 방식&lt;/th>
&lt;th>사용 상황&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Job&lt;/code>&lt;/td>
&lt;td>자식 예외 → 부모로 전파 → 형제도 취소됨&lt;/td>
&lt;td>전체 실패 시 모두 중단해야 할 때&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 예외는 부모에게 영향을 주지 않음&lt;/td>
&lt;td>부분 실패 허용, 독립적 작업 병렬 실행 시&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="5-실무-적용-사례">5. 실무 적용 사례
&lt;/h3>&lt;h4 id="병렬-데이터-수집">병렬 데이터 수집
&lt;/h4>&lt;ul>
&lt;li>API 여러 개 동시에 호출&lt;/li>
&lt;li>하나 실패해도 가능한 응답만으로 화면 구성&lt;/li>
&lt;/ul>
&lt;h4 id="백그라운드-동기화">백그라운드 동기화
&lt;/h4>&lt;ul>
&lt;li>다수의 파일 동기화 작업&lt;/li>
&lt;li>일부 실패는 로그로 남기고 나머지 계속 처리&lt;/li>
&lt;/ul>
&lt;h4 id="사용자-입력-처리">사용자 입력 처리
&lt;/h4>&lt;ul>
&lt;li>검색어 자동완성, 추천어, 최근 검색어 등 병렬로 가져올 때&lt;/li>
&lt;li>하나 실패해도 나머지는 계속 보여주고자 할 때&lt;/li>
&lt;/ul>
&lt;hr></description></item></channel></rss>