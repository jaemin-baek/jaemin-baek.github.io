<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/android/</link><description>Recent content in Android on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 29 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android UI 성능 저하 요인: Frame Skipping, Jank, GPU Overdraw</title><link>https://jaemin-baek.github.io/post/android_performance_issues/</link><pubDate>Thu, 29 May 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_performance_issues/</guid><description>&lt;h1 id="android-ui-성능-저하-요인-frame-skipping-jank-gpu-overdraw">Android UI 성능 저하 요인: Frame Skipping, Jank, GPU Overdraw
&lt;/h1>&lt;p>Android에서 부드러운 UI와 애니메이션을 구현하기 위해서는 **60FPS(또는 그 이상)**의 일정한 프레임 유지가 중요합니다. 하지만 다양한 원인으로 인해 &lt;strong>프레임이 건너뛰거나 끊기는 현상&lt;/strong>이 발생할 수 있습니다.&lt;/p>
&lt;p>이 글에서는 UI 렌더링 성능을 저하시킬 수 있는 대표적인 요인인 &lt;strong>Frame Skipping&lt;/strong>, &lt;strong>Jank&lt;/strong>, &lt;strong>GPU Overdraw&lt;/strong>를 살펴봅니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-frame-skipping-프레임-스킵">1. Frame Skipping (프레임 스킵)
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Frame Skipping&lt;/strong>은 VSync 타이밍(예: 16.6ms)을 넘겨 GPU가 프레임을 제때 제출하지 못할 때 발생합니다.&lt;/li>
&lt;li>결과적으로 해당 프레임은 건너뛰어지고, 애니메이션이 순간적으로 끊긴 것처럼 보입니다.&lt;/li>
&lt;/ul>
&lt;h3 id="원인">원인
&lt;/h3>&lt;ul>
&lt;li>레이아웃 연산 과다 (&lt;code>onLayout&lt;/code>, &lt;code>onMeasure&lt;/code>)&lt;/li>
&lt;li>복잡한 View 계층 또는 ConstraintLayout 오용&lt;/li>
&lt;li>무거운 이미지 디코딩, 비효율적 메모리 사용&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2-jank-잭-or-잔커">2. Jank (잭 or 잔커)
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Jank&lt;/strong>는 프레임 간 시간 간격이 일정하지 않아서 눈에 띄게 화면이 &lt;strong>끊기는 듯한 현상&lt;/strong>&lt;/li>
&lt;li>Frame Skipping이 누적되면 발생&lt;/li>
&lt;li>Jank는 UX에서 매우 민감하게 인식됨&lt;/li>
&lt;/ul>
&lt;h3 id="지표로-확인">지표로 확인
&lt;/h3>&lt;ul>
&lt;li>&lt;code>FrameTime &amp;gt; 16.6ms&lt;/code> → 하나의 Jank&lt;/li>
&lt;li>연속된 프레임 지연 → 체감 끊김이 심해짐&lt;/li>
&lt;/ul>
&lt;h3 id="해결-방법">해결 방법
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>메인 스레드에서의 무거운 연산 제거&lt;/strong>&lt;/li>
&lt;li>&lt;strong>레이아웃 단순화&lt;/strong>&lt;/li>
&lt;li>Glide, Coil 등 &lt;strong>비동기 이미지 로딩 라이브러리 사용&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="3-gpu-overdraw">3. GPU Overdraw
&lt;/h2>&lt;ul>
&lt;li>GPU가 동일한 픽셀을 여러 번 그리는 현상&lt;/li>
&lt;li>예: 배경 → 반투명 패널 → 버튼 → 텍스트 → 그림자 등 같은 위치 픽셀을 반복 렌더링&lt;/li>
&lt;/ul>
&lt;h3 id="overdraw-레벨">Overdraw 레벨
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>색상 (디버깅 모드)&lt;/th>
&lt;th>의미&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>파란색&lt;/td>
&lt;td>1회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>초록색&lt;/td>
&lt;td>2회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>분홍색&lt;/td>
&lt;td>3회&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>빨간색&lt;/td>
&lt;td>4회 이상 (심각)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="해결-방법-1">해결 방법
&lt;/h3>&lt;ul>
&lt;li>배경 중복 제거 (e.g. &lt;code>android:background&lt;/code> 대신 테마 활용)&lt;/li>
&lt;li>겹치는 View 계층 최소화&lt;/li>
&lt;li>&lt;code>ConstraintLayout&lt;/code>에서 투명한 View 중복 피하기&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="4-디버깅-도구-요약">4. 디버깅 도구 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>도구&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>adb shell dumpsys gfxinfo&lt;/code>&lt;/td>
&lt;td>프레임 시간, Jank 통계&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Android Studio Profiler&lt;/td>
&lt;td>CPU, GPU, 메모리 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>GPU Overdraw&lt;/code> (개발자 옵션)&lt;/td>
&lt;td>픽셀 과다 그리기 시각화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Layout Inspector&lt;/code>&lt;/td>
&lt;td>뷰 계층 구조 분석&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="결론">결론
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>성능 저하 요소&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>해결 전략&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Frame Skipping&lt;/td>
&lt;td>프레임 제출 실패&lt;/td>
&lt;td>렌더링 병목 제거&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Jank&lt;/td>
&lt;td>불규칙한 프레임 타이밍&lt;/td>
&lt;td>View 최적화, 스레드 분리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>GPU Overdraw&lt;/td>
&lt;td>중복 픽셀 렌더링&lt;/td>
&lt;td>View 계층 간소화&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>안드로이드 UI 성능은 단순히 코드를 잘 짜는 것만으로는 부족합니다. &lt;strong>눈에 보이지 않는 렌더링 비용을 인식하고 최적화하는 시야가 중요&lt;/strong>합니다.&lt;/p>
&lt;p>다음 글에서는 &lt;code>Display Refresh Rate&lt;/code>, &lt;code>Adaptive Sync&lt;/code>, &lt;code>Frame Pacing&lt;/code>과 같은 &lt;strong>고주사율 디스플레이 대응 전략&lt;/strong>을 다뤄보겠습니다.&lt;/p></description></item><item><title>Android 프레임 동기화 기술: BufferQueue, VSync, Triple Buffering</title><link>https://jaemin-baek.github.io/post/android_frame_sync/</link><pubDate>Thu, 29 May 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_frame_sync/</guid><description>&lt;h1 id="android-프레임-동기화-기술-bufferqueue-vsync-triple-buffering">Android 프레임 동기화 기술: BufferQueue, VSync, Triple Buffering
&lt;/h1>&lt;p>Android에서 프레임 렌더링은 단순히 GPU에서 그리는 작업으로 끝나지 않습니다. &lt;strong>디스플레이와 GPU 사이의 타이밍을 맞추는 동기화 기술&lt;/strong>이 반드시 필요합니다. 이를 담당하는 핵심 기술이 &lt;strong>VSync&lt;/strong>, &lt;strong>BufferQueue&lt;/strong>, &lt;strong>Triple Buffering&lt;/strong>입니다.&lt;/p>
&lt;p>이 글에서는 이 세 가지 기술이 어떻게 Android의 부드러운 화면 출력과 성능 최적화를 돕는지 알아보겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-vsync-vertical-synchronization">1. VSync (Vertical Synchronization)
&lt;/h2>&lt;ul>
&lt;li>디스플레이는 보통 초당 60번(60Hz) 화면을 갱신합니다.&lt;/li>
&lt;li>VSync는 GPU가 &lt;strong>디스플레이의 새로고침 주기&lt;/strong>에 맞춰 프레임을 보내도록 강제하는 기술입니다.&lt;/li>
&lt;li>목적: &lt;strong>티어링(tearing)&lt;/strong> 현상 방지&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Tearing: GPU가 프레임을 디스플레이에 보내는 도중, 디스플레이가 화면을 갱신하면 생기는 찢어진 이미지 현상&lt;/p>&lt;/blockquote>
&lt;h3 id="vsync-타이밍-흐름">VSync 타이밍 흐름
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GPU: 프레임 준비 완료
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (대기)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Display: VSync 신호 발생
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GPU: 프레임 제출
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="2-bufferqueue">2. BufferQueue
&lt;/h2>&lt;ul>
&lt;li>Android에서 GPU와 디스플레이 시스템(SurfaceFlinger) 사이의 &lt;strong>프레임 버퍼 교환 메커니즘&lt;/strong>&lt;/li>
&lt;li>&lt;strong>생산자-소비자 모델&lt;/strong>로 작동:
&lt;ul>
&lt;li>생산자: 앱 (예: RenderThread, GPU)&lt;/li>
&lt;li>소비자: SurfaceFlinger&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구성-요소">구성 요소
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GraphicBuffer&lt;/td>
&lt;td>실제 픽셀 데이터를 담는 버퍼&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BufferSlot&lt;/td>
&lt;td>버퍼들을 순환 처리하는 슬롯 (일반적으로 3개)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Queue/Dequeue&lt;/td>
&lt;td>버퍼를 예약하거나 소비하는 단계&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>앱이 프레임을 그리면 &lt;code>dequeueBuffer&lt;/code> → GPU가 작성 → &lt;code>queueBuffer&lt;/code> → SurfaceFlinger가 읽음&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="3-triple-buffering">3. Triple Buffering
&lt;/h2>&lt;ul>
&lt;li>프레임 버퍼를 &lt;strong>3개 유지&lt;/strong>하여 GPU와 디스플레이 간의 동기화 지연을 줄이는 기법&lt;/li>
&lt;li>Double Buffering보다 한 단계 더 유연함&lt;/li>
&lt;/ul>
&lt;h3 id="버퍼-상태-예시">버퍼 상태 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[Front Buffer] → 디스플레이가 읽는 중
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Middle Buffer] → 다음 프레임 준비 대기 중
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Back Buffer] → GPU가 현재 그리고 있는 중
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조 덕분에:&lt;/p>
&lt;ul>
&lt;li>GPU가 VSync를 기다리지 않고 계속 작업 가능&lt;/li>
&lt;li>디스플레이는 가장 마지막으로 완료된 프레임을 안정적으로 표시&lt;/li>
&lt;li>단점: 메모리 사용량 증가&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="4-전체-동작-흐름-요약">4. 전체 동작 흐름 요약
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[App GPU Rendering]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (dequeueBuffer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Back Buffer에서 그림]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (queueBuffer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[BufferQueue에 제출]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (VSync 타이밍에 따라)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[SurfaceFlinger가 Middle Buffer를 Front로 전환]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[디스플레이 출력]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="5-성능-디버깅-도구">5. 성능 디버깅 도구
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>도구&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>dumpsys SurfaceFlinger --latency&lt;/code>&lt;/td>
&lt;td>프레임 시간 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>systrace&lt;/code> 또는 &lt;code>perfetto&lt;/code>&lt;/td>
&lt;td>GPU / VSync 타이밍 시각화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gfxinfo&lt;/code>&lt;/td>
&lt;td>프레임 드롭/지연 통계 제공&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="결론">결론
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>VSync&lt;/strong>는 디스플레이와 GPU 타이밍 동기화&lt;/li>
&lt;li>&lt;strong>BufferQueue&lt;/strong>는 프레임 전달의 중계자&lt;/li>
&lt;li>&lt;strong>Triple Buffering&lt;/strong>은 지연 없이 렌더링을 이어가기 위한 메커니즘&lt;/li>
&lt;/ul>
&lt;p>이러한 동기화 기술 덕분에 Android는 티어링 없는 부드러운 애니메이션을 유지하면서, GPU와 디스플레이 간 효율적인 작업 분할을 수행할 수 있습니다.&lt;/p>
&lt;p>다음 글에서는 &lt;code>Frame Skipping&lt;/code>, &lt;code>Jank&lt;/code>, &lt;code>GPU Overdraw&lt;/code>과 같은 성능 저하 요인에 대해 다뤄보겠습니다.&lt;/p></description></item><item><title>Android 렌더링 파이프라인 심화: Skia, HardwareRenderer, SurfaceFlinger</title><link>https://jaemin-baek.github.io/post/android_render_pipeline/</link><pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_render_pipeline/</guid><description>&lt;h1 id="android-렌더링-파이프라인-심화-skia-hardwarerenderer-surfaceflinger">Android 렌더링 파이프라인 심화: Skia, HardwareRenderer, SurfaceFlinger
&lt;/h1>&lt;p>이 글에서는 Android 시스템이 UI를 어떻게 실제 화면에 렌더링하는지, 그 과정에 참여하는 핵심 구성 요소인 &lt;strong>Skia&lt;/strong>, &lt;strong>RenderThread&lt;/strong>, &lt;strong>HardwareRenderer&lt;/strong>, &lt;strong>SurfaceFlinger&lt;/strong>에 대해 구조적으로 살펴봅니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-android-렌더링-전체-흐름">1. Android 렌더링 전체 흐름
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[앱의 View 계층]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[DisplayList 생성]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[RenderThread]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[HardwareRenderer (Skia 활용)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[SurfaceFlinger]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Surface (Framebuffer) → 디스플레이]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="2-skia란">2. Skia란?
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Skia&lt;/strong>는 Google에서 만든 고성능 2D 그래픽 라이브러리입니다.&lt;/li>
&lt;li>Android의 &lt;code>Canvas&lt;/code> API는 내부적으로 Skia를 사용합니다.&lt;/li>
&lt;li>포인트, 선, 텍스트, 곡선 등을 GPU 또는 CPU 기반으로 그릴 수 있습니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>예: &lt;code>canvas.drawText(...)&lt;/code> → Skia가 실제 텍스트 패스를 폴리곤화하여 GPU에 전달&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="3-renderthread">3. RenderThread
&lt;/h2>&lt;ul>
&lt;li>Android 5.0(Lollipop) 이후 도입&lt;/li>
&lt;li>View의 그리기 연산을 메인 스레드에서 분리하여 처리&lt;/li>
&lt;li>&lt;strong>DisplayList를 수집하고, Skia를 통해 그리기 명령을 GPU에 전달&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>메인 스레드는 UI 이벤트와 로직 처리, RenderThread는 GPU 렌더링 전용&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="4-hardwarerenderer">4. HardwareRenderer
&lt;/h2>&lt;ul>
&lt;li>Skia를 통해 실제 그리기를 수행하는 핵심 클래스&lt;/li>
&lt;li>&lt;code>HardwareRenderer&lt;/code>는 각 Window에 대한 렌더링 컨텍스트를 관리&lt;/li>
&lt;li>GPU 백엔드(OpenGL ES 또는 Vulkan)에 맞춰 최적화된 렌더링 명령 생성&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>ViewRootImpl&lt;/code>이 이 Renderer를 호출하여 &lt;code>Surface&lt;/code>에 그려줌&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="5-surfaceflinger">5. SurfaceFlinger
&lt;/h2>&lt;ul>
&lt;li>안드로이드 시스템의 &lt;strong>디스플레이 합성 관리자&lt;/strong>&lt;/li>
&lt;li>앱들이 그린 Surface들을 모아서 화면에 보여주는 역할&lt;/li>
&lt;li>각 앱은 독립된 Surface에 그림 → SurfaceFlinger가 하나의 프레임으로 합성하여 디스플레이로 전송&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>**WMS(WindowManagerService)**와 통신하며, &lt;code>BufferQueue&lt;/code> 기반으로 동작&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="6-렌더링-파이프라인-전체-요약">6. 렌더링 파이프라인 전체 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>단계&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>View → DisplayList&lt;/td>
&lt;td>UI 계층의 그리기 명령 수집&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RenderThread&lt;/td>
&lt;td>메인 스레드 분리 렌더링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HardwareRenderer&lt;/td>
&lt;td>Skia로 GPU 명령 생성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SurfaceFlinger&lt;/td>
&lt;td>여러 Surface 합성 후 화면 출력&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="7-디버깅-팁">7. 디버깅 팁
&lt;/h2>&lt;ul>
&lt;li>&lt;code>adb shell dumpsys SurfaceFlinger&lt;/code> → 현재 화면 레이어 구조 확인&lt;/li>
&lt;li>&lt;code>GPU Rendering Profile&lt;/code> (개발자 옵션) → 프레임 시간 시각화&lt;/li>
&lt;li>&lt;code>systrace&lt;/code> / &lt;code>perfetto&lt;/code> → 전체 프레임 렌더링 타임라인 분석&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="마무리">마무리
&lt;/h2>&lt;p>Android는 단순한 View 그리기뿐 아니라, 실제로 매우 정교한 &lt;strong>GPU 기반 렌더링 파이프라인&lt;/strong>을 갖추고 있습니다. 특히 Skia, HardwareRenderer, SurfaceFlinger를 이해하면 &lt;strong>UI 성능 최적화, 커스텀 뷰, 하드웨어 가속&lt;/strong>에 대해 깊은 인사이트를 얻을 수 있습니다.&lt;/p>
&lt;p>다음 글에서는 &lt;code>BufferQueue&lt;/code>, &lt;code>VSync&lt;/code>, &lt;code>Triple Buffering&lt;/code> 같은 프레임 동기화 기술에 대해 다뤄보겠습니다.&lt;/p></description></item><item><title>안드로이드에서의 GPU 렌더링 구조: Vertex Buffer와 Index Buffer 이해하기</title><link>https://jaemin-baek.github.io/post/android_gpu_rendering/</link><pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_gpu_rendering/</guid><description>&lt;h1 id="안드로이드에서의-gpu-렌더링-구조-vertex-buffer와-index-buffer-이해하기">안드로이드에서의 GPU 렌더링 구조: Vertex Buffer와 Index Buffer 이해하기
&lt;/h1>&lt;p>Android 앱을 개발하면서 UI를 구성할 때 우리는 보통 XML로 &lt;code>TextView&lt;/code>, &lt;code>ImageView&lt;/code>, &lt;code>Button&lt;/code> 등을 배치합니다. 그러나 이러한 UI 요소들은 실제로 화면에 표시될 때 GPU(Graphics Processing Unit) 를 통해 렌더링됩니다. 이 렌더링은 내부적으로 어떻게 동작할까요?&lt;/p>
&lt;p>이 글에서는 Android의 GPU 렌더링 구조를 이해하기 위해 &lt;strong>Vertex Buffer&lt;/strong>와 &lt;strong>Index Buffer&lt;/strong>를 중심으로 살펴보겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-gpu는-삼각형을-그리는-기계">1. GPU는 삼각형을 그리는 기계
&lt;/h2>&lt;p>GPU는 기본적으로 &lt;strong>삼각형(triangle)&lt;/strong> 단위로 모든 그래픽을 처리합니다. 원, 사각형, 글자 등 모든 형태는 결국 &lt;strong>삼각형의 집합&lt;/strong>으로 변환되어 GPU에 전달됩니다.&lt;/p>
&lt;p>이를 위해 필요한 것이 바로 다음 두 가지입니다:&lt;/p>
&lt;ul>
&lt;li>Vertex Buffer (정점 버퍼): 위치, 색상, 텍스처 좌표 등의 정점 데이터&lt;/li>
&lt;li>Index Buffer (인덱스 버퍼): 어떤 정점들을 연결해 삼각형을 만들지에 대한 순서 정보&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2-opengl-es--vulkan에서의-구조">2. OpenGL ES / Vulkan에서의 구조
&lt;/h2>&lt;p>Android에서 직접 OpenGL ES나 Vulkan을 사용하는 경우, 아래와 같은 방식으로 데이터를 GPU에 전달합니다.&lt;/p>
&lt;h3 id="-vertex-buffer">🔹 Vertex Buffer
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>GLfloat vertices[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// x, y, r, g, b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#ae81ff">1.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#75715e">// 정점 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">1.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#75715e">// 정점 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">1.0f&lt;/span> &lt;span style="color:#75715e">// 정점 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>정점 데이터에는 &lt;strong>위치 정보&lt;/strong>와 함께 &lt;strong>색상, 텍스처 좌표, 법선벡터&lt;/strong> 등이 포함될 수 있습니다.&lt;/p>
&lt;h3 id="-index-buffer">🔹 Index Buffer
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>GLuint indices[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예시는 정점 0-1-2를 연결하여 &lt;strong>삼각형 하나&lt;/strong>를 만드는 구조입니다.&lt;/p>
&lt;hr>
&lt;h2 id="3-android-뷰-시스템은-어떻게-렌더링할까">3. Android 뷰 시스템은 어떻게 렌더링할까?
&lt;/h2>&lt;p>일반적인 Android UI(&lt;code>View&lt;/code>, &lt;code>TextView&lt;/code>, &lt;code>LinearLayout&lt;/code> 등)는 개발자가 직접 GPU 명령을 다루지는 않지만, 내부에서는 아래와 같은 과정을 거칩니다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>View → DisplayList 생성&lt;/strong>&lt;br>
View가 자신의 그리기 명령을 &lt;code>DisplayList&lt;/code>라는 객체에 기록합니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>RenderThread → Skia → GPU 호출&lt;/strong>&lt;br>
Android는 &lt;code>Skia&lt;/code>라는 2D 그래픽 엔진을 사용하여 이 명령들을 GPU 친화적인 형태로 변환하고, OpenGL ES 또는 Vulkan API를 통해 GPU에 전달합니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>GPU는 결국 정점과 삼각형으로 처리&lt;/strong>&lt;br>
사각형 버튼 하나도 두 개의 삼각형으로 분할되어 렌더링됩니다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="4-왜-index-buffer를-쓸까">4. 왜 Index Buffer를 쓸까?
&lt;/h2>&lt;p>Index Buffer는 중복된 정점 데이터를 재사용할 수 있게 해줍니다. 예를 들어 사각형을 두 개의 삼각형으로 만들 때:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>정점: 0, 1, 2, 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>삼각형 1: 0, 1, 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>삼각형 2: 2, 3, 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 하면 정점 2는 두 삼각형에 공유되어 메모리 사용이 효율적이고, 성능이 향상됩니다.&lt;/p>
&lt;hr>
&lt;h2 id="5-android에서-직접-사용하는-예-opengl-es-예제">5. Android에서 직접 사용하는 예: OpenGL ES 예제
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glGenBuffers&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>vbo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBindBuffer&lt;/span>(GL_ARRAY_BUFFER, vbo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBufferData&lt;/span>(GL_ARRAY_BUFFER, &lt;span style="color:#66d9ef">sizeof&lt;/span>(vertices), vertices, GL_STATIC_DRAW);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glGenBuffers&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ebo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBindBuffer&lt;/span>(GL_ELEMENT_ARRAY_BUFFER, ebo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBufferData&lt;/span>(GL_ELEMENT_ARRAY_BUFFER, &lt;span style="color:#66d9ef">sizeof&lt;/span>(indices), indices, GL_STATIC_DRAW);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glDrawElements&lt;/span>(GL_TRIANGLES, &lt;span style="color:#ae81ff">6&lt;/span>, GL_UNSIGNED_INT, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 정점 버퍼와 인덱스 버퍼를 생성하고, 삼각형을 그리는 명령입니다.&lt;/p>
&lt;hr>
&lt;h2 id="6-결론-안드로이드에서의-gpu-렌더링-핵심-요약">6. 결론: 안드로이드에서의 GPU 렌더링 핵심 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>개념&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Vertex Buffer&lt;/strong>&lt;/td>
&lt;td>정점 데이터 (위치, 색상, UV 등)를 GPU에 전달&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Index Buffer&lt;/strong>&lt;/td>
&lt;td>삼각형을 구성할 정점 순서 정의&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Draw Call&lt;/strong>&lt;/td>
&lt;td>정점 + 인덱스를 이용해 삼각형을 GPU가 그림&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>View 시스템&lt;/strong>&lt;/td>
&lt;td>Skia와 RenderThread를 통해 내부적으로 이 구조 사용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>즉, Android 앱에서 버튼 하나를 그리더라도, 내부적으로는 &lt;strong>삼각형 메쉬를 GPU가 렌더링&lt;/strong>하고 있다는 점을 이해하면 성능 최적화나 커스텀 렌더링 구현에 큰 도움이 됩니다.&lt;/p>
&lt;hr>
&lt;p>향후에는 &lt;code>HardwareRenderer&lt;/code>, &lt;code>SurfaceFlinger&lt;/code>, &lt;code>Skia&lt;/code> 등을 통해 Android의 렌더링 파이프라인을 더 깊이 있게 알아보겠습니다.&lt;/p></description></item></channel></rss>