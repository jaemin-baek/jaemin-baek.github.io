<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Android on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/android/</link><description>Recent content in Android on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/android/index.xml" rel="self" type="application/rss+xml"/><item><title>Android 렌더링 파이프라인 심화: Skia, HardwareRenderer, SurfaceFlinger</title><link>https://jaemin-baek.github.io/post/android_render_pipeline/</link><pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_render_pipeline/</guid><description>&lt;h1 id="android-렌더링-파이프라인-심화-skia-hardwarerenderer-surfaceflinger">Android 렌더링 파이프라인 심화: Skia, HardwareRenderer, SurfaceFlinger
&lt;/h1>&lt;p>이 글에서는 Android 시스템이 UI를 어떻게 실제 화면에 렌더링하는지, 그 과정에 참여하는 핵심 구성 요소인 &lt;strong>Skia&lt;/strong>, &lt;strong>RenderThread&lt;/strong>, &lt;strong>HardwareRenderer&lt;/strong>, &lt;strong>SurfaceFlinger&lt;/strong>에 대해 구조적으로 살펴봅니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-android-렌더링-전체-흐름">1. Android 렌더링 전체 흐름
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[앱의 View 계층]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[DisplayList 생성]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[RenderThread]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[HardwareRenderer (Skia 활용)]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[SurfaceFlinger]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Surface (Framebuffer) → 디스플레이]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="2-skia란">2. Skia란?
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>Skia&lt;/strong>는 Google에서 만든 고성능 2D 그래픽 라이브러리입니다.&lt;/li>
&lt;li>Android의 &lt;code>Canvas&lt;/code> API는 내부적으로 Skia를 사용합니다.&lt;/li>
&lt;li>포인트, 선, 텍스트, 곡선 등을 GPU 또는 CPU 기반으로 그릴 수 있습니다.&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>예: &lt;code>canvas.drawText(...)&lt;/code> → Skia가 실제 텍스트 패스를 폴리곤화하여 GPU에 전달&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="3-renderthread">3. RenderThread
&lt;/h2>&lt;ul>
&lt;li>Android 5.0(Lollipop) 이후 도입&lt;/li>
&lt;li>View의 그리기 연산을 메인 스레드에서 분리하여 처리&lt;/li>
&lt;li>&lt;strong>DisplayList를 수집하고, Skia를 통해 그리기 명령을 GPU에 전달&lt;/strong>&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>메인 스레드는 UI 이벤트와 로직 처리, RenderThread는 GPU 렌더링 전용&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="4-hardwarerenderer">4. HardwareRenderer
&lt;/h2>&lt;ul>
&lt;li>Skia를 통해 실제 그리기를 수행하는 핵심 클래스&lt;/li>
&lt;li>&lt;code>HardwareRenderer&lt;/code>는 각 Window에 대한 렌더링 컨텍스트를 관리&lt;/li>
&lt;li>GPU 백엔드(OpenGL ES 또는 Vulkan)에 맞춰 최적화된 렌더링 명령 생성&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>&lt;code>ViewRootImpl&lt;/code>이 이 Renderer를 호출하여 &lt;code>Surface&lt;/code>에 그려줌&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="5-surfaceflinger">5. SurfaceFlinger
&lt;/h2>&lt;ul>
&lt;li>안드로이드 시스템의 &lt;strong>디스플레이 합성 관리자&lt;/strong>&lt;/li>
&lt;li>앱들이 그린 Surface들을 모아서 화면에 보여주는 역할&lt;/li>
&lt;li>각 앱은 독립된 Surface에 그림 → SurfaceFlinger가 하나의 프레임으로 합성하여 디스플레이로 전송&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>**WMS(WindowManagerService)**와 통신하며, &lt;code>BufferQueue&lt;/code> 기반으로 동작&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="6-렌더링-파이프라인-전체-요약">6. 렌더링 파이프라인 전체 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>단계&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>View → DisplayList&lt;/td>
&lt;td>UI 계층의 그리기 명령 수집&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>RenderThread&lt;/td>
&lt;td>메인 스레드 분리 렌더링&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HardwareRenderer&lt;/td>
&lt;td>Skia로 GPU 명령 생성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>SurfaceFlinger&lt;/td>
&lt;td>여러 Surface 합성 후 화면 출력&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="7-디버깅-팁">7. 디버깅 팁
&lt;/h2>&lt;ul>
&lt;li>&lt;code>adb shell dumpsys SurfaceFlinger&lt;/code> → 현재 화면 레이어 구조 확인&lt;/li>
&lt;li>&lt;code>GPU Rendering Profile&lt;/code> (개발자 옵션) → 프레임 시간 시각화&lt;/li>
&lt;li>&lt;code>systrace&lt;/code> / &lt;code>perfetto&lt;/code> → 전체 프레임 렌더링 타임라인 분석&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="마무리">마무리
&lt;/h2>&lt;p>Android는 단순한 View 그리기뿐 아니라, 실제로 매우 정교한 &lt;strong>GPU 기반 렌더링 파이프라인&lt;/strong>을 갖추고 있습니다. 특히 Skia, HardwareRenderer, SurfaceFlinger를 이해하면 &lt;strong>UI 성능 최적화, 커스텀 뷰, 하드웨어 가속&lt;/strong>에 대해 깊은 인사이트를 얻을 수 있습니다.&lt;/p>
&lt;p>👉 다음 글에서는 &lt;code>BufferQueue&lt;/code>, &lt;code>VSync&lt;/code>, &lt;code>Triple Buffering&lt;/code> 같은 프레임 동기화 기술에 대해 다뤄보겠습니다.&lt;/p></description></item><item><title>안드로이드에서의 GPU 렌더링 구조: Vertex Buffer와 Index Buffer 이해하기</title><link>https://jaemin-baek.github.io/post/android_gpu_rendering/</link><pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_gpu_rendering/</guid><description>&lt;h1 id="안드로이드에서의-gpu-렌더링-구조-vertex-buffer와-index-buffer-이해하기">안드로이드에서의 GPU 렌더링 구조: Vertex Buffer와 Index Buffer 이해하기
&lt;/h1>&lt;p>Android 앱을 개발하면서 UI를 구성할 때 우리는 보통 XML로 &lt;code>TextView&lt;/code>, &lt;code>ImageView&lt;/code>, &lt;code>Button&lt;/code> 등을 배치합니다. 그러나 이러한 UI 요소들은 실제로 화면에 표시될 때 GPU(Graphics Processing Unit) 를 통해 렌더링됩니다. 이 렌더링은 내부적으로 어떻게 동작할까요?&lt;/p>
&lt;p>이 글에서는 Android의 GPU 렌더링 구조를 이해하기 위해 &lt;strong>Vertex Buffer&lt;/strong>와 &lt;strong>Index Buffer&lt;/strong>를 중심으로 살펴보겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-gpu는-삼각형을-그리는-기계">1. GPU는 삼각형을 그리는 기계
&lt;/h2>&lt;p>GPU는 기본적으로 &lt;strong>삼각형(triangle)&lt;/strong> 단위로 모든 그래픽을 처리합니다. 원, 사각형, 글자 등 모든 형태는 결국 &lt;strong>삼각형의 집합&lt;/strong>으로 변환되어 GPU에 전달됩니다.&lt;/p>
&lt;p>이를 위해 필요한 것이 바로 다음 두 가지입니다:&lt;/p>
&lt;ul>
&lt;li>Vertex Buffer (정점 버퍼): 위치, 색상, 텍스처 좌표 등의 정점 데이터&lt;/li>
&lt;li>Index Buffer (인덱스 버퍼): 어떤 정점들을 연결해 삼각형을 만들지에 대한 순서 정보&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="2-opengl-es--vulkan에서의-구조">2. OpenGL ES / Vulkan에서의 구조
&lt;/h2>&lt;p>Android에서 직접 OpenGL ES나 Vulkan을 사용하는 경우, 아래와 같은 방식으로 데이터를 GPU에 전달합니다.&lt;/p>
&lt;h3 id="-vertex-buffer">🔹 Vertex Buffer
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>GLfloat vertices[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// x, y, r, g, b
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#ae81ff">1.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#75715e">// 정점 0
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">1.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#75715e">// 정점 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">0.5f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">0.0f&lt;/span>, &lt;span style="color:#ae81ff">1.0f&lt;/span> &lt;span style="color:#75715e">// 정점 2
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>정점 데이터에는 &lt;strong>위치 정보&lt;/strong>와 함께 &lt;strong>색상, 텍스처 좌표, 법선벡터&lt;/strong> 등이 포함될 수 있습니다.&lt;/p>
&lt;h3 id="-index-buffer">🔹 Index Buffer
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>GLuint indices[] &lt;span style="color:#f92672">=&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span>, &lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>};
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예시는 정점 0-1-2를 연결하여 &lt;strong>삼각형 하나&lt;/strong>를 만드는 구조입니다.&lt;/p>
&lt;hr>
&lt;h2 id="3-android-뷰-시스템은-어떻게-렌더링할까">3. Android 뷰 시스템은 어떻게 렌더링할까?
&lt;/h2>&lt;p>일반적인 Android UI(&lt;code>View&lt;/code>, &lt;code>TextView&lt;/code>, &lt;code>LinearLayout&lt;/code> 등)는 개발자가 직접 GPU 명령을 다루지는 않지만, 내부에서는 아래와 같은 과정을 거칩니다:&lt;/p>
&lt;ol>
&lt;li>
&lt;p>&lt;strong>View → DisplayList 생성&lt;/strong>&lt;br>
View가 자신의 그리기 명령을 &lt;code>DisplayList&lt;/code>라는 객체에 기록합니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>RenderThread → Skia → GPU 호출&lt;/strong>&lt;br>
Android는 &lt;code>Skia&lt;/code>라는 2D 그래픽 엔진을 사용하여 이 명령들을 GPU 친화적인 형태로 변환하고, OpenGL ES 또는 Vulkan API를 통해 GPU에 전달합니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>GPU는 결국 정점과 삼각형으로 처리&lt;/strong>&lt;br>
사각형 버튼 하나도 두 개의 삼각형으로 분할되어 렌더링됩니다.&lt;/p>
&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h2 id="4-왜-index-buffer를-쓸까">4. 왜 Index Buffer를 쓸까?
&lt;/h2>&lt;p>Index Buffer는 중복된 정점 데이터를 재사용할 수 있게 해줍니다. 예를 들어 사각형을 두 개의 삼각형으로 만들 때:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>정점: 0, 1, 2, 3
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>삼각형 1: 0, 1, 2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>삼각형 2: 2, 3, 0
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 하면 정점 2는 두 삼각형에 공유되어 메모리 사용이 효율적이고, 성능이 향상됩니다.&lt;/p>
&lt;hr>
&lt;h2 id="5-android에서-직접-사용하는-예-opengl-es-예제">5. Android에서 직접 사용하는 예: OpenGL ES 예제
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-c" data-lang="c">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glGenBuffers&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>vbo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBindBuffer&lt;/span>(GL_ARRAY_BUFFER, vbo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBufferData&lt;/span>(GL_ARRAY_BUFFER, &lt;span style="color:#66d9ef">sizeof&lt;/span>(vertices), vertices, GL_STATIC_DRAW);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glGenBuffers&lt;/span>(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#f92672">&amp;amp;&lt;/span>ebo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBindBuffer&lt;/span>(GL_ELEMENT_ARRAY_BUFFER, ebo);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glBufferData&lt;/span>(GL_ELEMENT_ARRAY_BUFFER, &lt;span style="color:#66d9ef">sizeof&lt;/span>(indices), indices, GL_STATIC_DRAW);
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">glDrawElements&lt;/span>(GL_TRIANGLES, &lt;span style="color:#ae81ff">6&lt;/span>, GL_UNSIGNED_INT, &lt;span style="color:#ae81ff">0&lt;/span>);
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 코드는 정점 버퍼와 인덱스 버퍼를 생성하고, 삼각형을 그리는 명령입니다.&lt;/p>
&lt;hr>
&lt;h2 id="6-결론-안드로이드에서의-gpu-렌더링-핵심-요약">6. 결론: 안드로이드에서의 GPU 렌더링 핵심 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>개념&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Vertex Buffer&lt;/strong>&lt;/td>
&lt;td>정점 데이터 (위치, 색상, UV 등)를 GPU에 전달&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Index Buffer&lt;/strong>&lt;/td>
&lt;td>삼각형을 구성할 정점 순서 정의&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Draw Call&lt;/strong>&lt;/td>
&lt;td>정점 + 인덱스를 이용해 삼각형을 GPU가 그림&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>View 시스템&lt;/strong>&lt;/td>
&lt;td>Skia와 RenderThread를 통해 내부적으로 이 구조 사용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>즉, Android 앱에서 버튼 하나를 그리더라도, 내부적으로는 &lt;strong>삼각형 메쉬를 GPU가 렌더링&lt;/strong>하고 있다는 점을 이해하면 성능 최적화나 커스텀 렌더링 구현에 큰 도움이 됩니다.&lt;/p>
&lt;hr>
&lt;p>향후에는 &lt;code>HardwareRenderer&lt;/code>, &lt;code>SurfaceFlinger&lt;/code>, &lt;code>Skia&lt;/code> 등을 통해 Android의 렌더링 파이프라인을 더 깊이 있게 알아보겠습니다.&lt;/p></description></item></channel></rss>