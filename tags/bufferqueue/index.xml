<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Bufferqueue on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/bufferqueue/</link><description>Recent content in Bufferqueue on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 15 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/bufferqueue/index.xml" rel="self" type="application/rss+xml"/><item><title>Android 프레임 동기화 기술: BufferQueue, VSync, Triple Buffering</title><link>https://jaemin-baek.github.io/post/android_frame_sync/</link><pubDate>Sat, 15 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/android_frame_sync/</guid><description>&lt;h1 id="android-프레임-동기화-기술-bufferqueue-vsync-triple-buffering">Android 프레임 동기화 기술: BufferQueue, VSync, Triple Buffering
&lt;/h1>&lt;p>Android에서 프레임 렌더링은 단순히 GPU에서 그리는 작업으로 끝나지 않습니다. &lt;strong>디스플레이와 GPU 사이의 타이밍을 맞추는 동기화 기술&lt;/strong>이 반드시 필요합니다. 이를 담당하는 핵심 기술이 &lt;strong>VSync&lt;/strong>, &lt;strong>BufferQueue&lt;/strong>, &lt;strong>Triple Buffering&lt;/strong>입니다.&lt;/p>
&lt;p>이 글에서는 이 세 가지 기술이 어떻게 Android의 부드러운 화면 출력과 성능 최적화를 돕는지 알아보겠습니다.&lt;/p>
&lt;hr>
&lt;h2 id="1-vsync-vertical-synchronization">1. VSync (Vertical Synchronization)
&lt;/h2>&lt;ul>
&lt;li>디스플레이는 보통 초당 60번(60Hz) 화면을 갱신합니다.&lt;/li>
&lt;li>VSync는 GPU가 &lt;strong>디스플레이의 새로고침 주기&lt;/strong>에 맞춰 프레임을 보내도록 강제하는 기술입니다.&lt;/li>
&lt;li>목적: &lt;strong>티어링(tearing)&lt;/strong> 현상 방지&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Tearing: GPU가 프레임을 디스플레이에 보내는 도중, 디스플레이가 화면을 갱신하면 생기는 찢어진 이미지 현상&lt;/p>&lt;/blockquote>
&lt;h3 id="vsync-타이밍-흐름">VSync 타이밍 흐름
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>GPU: 프레임 준비 완료
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (대기)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Display: VSync 신호 발생
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>GPU: 프레임 제출
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="2-bufferqueue">2. BufferQueue
&lt;/h2>&lt;ul>
&lt;li>Android에서 GPU와 디스플레이 시스템(SurfaceFlinger) 사이의 &lt;strong>프레임 버퍼 교환 메커니즘&lt;/strong>&lt;/li>
&lt;li>&lt;strong>생산자-소비자 모델&lt;/strong>로 작동:
&lt;ul>
&lt;li>생산자: 앱 (예: RenderThread, GPU)&lt;/li>
&lt;li>소비자: SurfaceFlinger&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="구성-요소">구성 요소
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GraphicBuffer&lt;/td>
&lt;td>실제 픽셀 데이터를 담는 버퍼&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>BufferSlot&lt;/td>
&lt;td>버퍼들을 순환 처리하는 슬롯 (일반적으로 3개)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Queue/Dequeue&lt;/td>
&lt;td>버퍼를 예약하거나 소비하는 단계&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>앱이 프레임을 그리면 &lt;code>dequeueBuffer&lt;/code> → GPU가 작성 → &lt;code>queueBuffer&lt;/code> → SurfaceFlinger가 읽음&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="3-triple-buffering">3. Triple Buffering
&lt;/h2>&lt;ul>
&lt;li>프레임 버퍼를 &lt;strong>3개 유지&lt;/strong>하여 GPU와 디스플레이 간의 동기화 지연을 줄이는 기법&lt;/li>
&lt;li>Double Buffering보다 한 단계 더 유연함&lt;/li>
&lt;/ul>
&lt;h3 id="버퍼-상태-예시">버퍼 상태 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[Front Buffer] → 디스플레이가 읽는 중
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Middle Buffer] → 다음 프레임 준비 대기 중
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Back Buffer] → GPU가 현재 그리고 있는 중
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조 덕분에:&lt;/p>
&lt;ul>
&lt;li>GPU가 VSync를 기다리지 않고 계속 작업 가능&lt;/li>
&lt;li>디스플레이는 가장 마지막으로 완료된 프레임을 안정적으로 표시&lt;/li>
&lt;li>단점: 메모리 사용량 증가&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="4-전체-동작-흐름-요약">4. 전체 동작 흐름 요약
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-text" data-lang="text">&lt;span style="display:flex;">&lt;span>[App GPU Rendering]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (dequeueBuffer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[Back Buffer에서 그림]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (queueBuffer)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[BufferQueue에 제출]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓ (VSync 타이밍에 따라)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[SurfaceFlinger가 Middle Buffer를 Front로 전환]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ↓
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[디스플레이 출력]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="5-성능-디버깅-도구">5. 성능 디버깅 도구
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>도구&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>dumpsys SurfaceFlinger --latency&lt;/code>&lt;/td>
&lt;td>프레임 시간 분석&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>systrace&lt;/code> 또는 &lt;code>perfetto&lt;/code>&lt;/td>
&lt;td>GPU / VSync 타이밍 시각화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>gfxinfo&lt;/code>&lt;/td>
&lt;td>프레임 드롭/지연 통계 제공&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="결론">결론
&lt;/h2>&lt;ul>
&lt;li>&lt;strong>VSync&lt;/strong>는 디스플레이와 GPU 타이밍 동기화&lt;/li>
&lt;li>&lt;strong>BufferQueue&lt;/strong>는 프레임 전달의 중계자&lt;/li>
&lt;li>&lt;strong>Triple Buffering&lt;/strong>은 지연 없이 렌더링을 이어가기 위한 메커니즘&lt;/li>
&lt;/ul>
&lt;p>이러한 동기화 기술 덕분에 Android는 티어링 없는 부드러운 애니메이션을 유지하면서, GPU와 디스플레이 간 효율적인 작업 분할을 수행할 수 있습니다.&lt;/p>
&lt;p>다음 글에서는 &lt;code>Frame Skipping&lt;/code>, &lt;code>Jank&lt;/code>, &lt;code>GPU Overdraw&lt;/code>과 같은 성능 저하 요인에 대해 다뤄보겠습니다.&lt;/p></description></item></channel></rss>