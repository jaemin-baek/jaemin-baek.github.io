<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Concurrency on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/concurrency/</link><description>Recent content in Concurrency on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 10 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/concurrency/index.xml" rel="self" type="application/rss+xml"/><item><title>코루틴 장점1: 코루틴은 일시 중단과 재개가 가능한 함수</title><link>https://jaemin-baek.github.io/post/coroutine1/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutine1/</guid><description>&lt;h2 id="코루틴은-일시-중단과-재개가-가능한-함수">코루틴은 일시 중단과 재개가 가능한 함수
&lt;/h2>&lt;p>코틀린에서는 &lt;strong>일시 중단&lt;/strong>을 suspend 라는 키워드로 표현합니다.&lt;/p>
&lt;p>suspend는 &lt;strong>이 함수는 중단(suspend)될 수 있다&lt;/strong>는 의미이죠&lt;/p>
&lt;p>즉, 함수가 실행 도중 잠시 멈췄다가 나중에 이어서 다시 실행될 수 있음을 나타냅니다.&lt;/p>
&lt;p>이런 함수는 코루틴 안에서만 호출할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchUserData&lt;/span>(): User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>) &lt;span style="color:#75715e">// 1초 일시 중단 (non-blocking)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;jaemin&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 delay(1000)은 현재 실행 중인 스레드를 막지 않고 (코루틴을 실행하고 있던 스레드를 블로킹하지 않고)
1초 동안 코루틴만 일시 중단합니다.&lt;/p>
&lt;p>이게 코루틴의 핵심 장점이죠 — 효율적이고 가벼운 비동기 처리.&lt;/p>
&lt;p>suspend 함수는 코루틴 컨텍스트 안에서만 실행 가능합니다.
즉, 코루틴 블록 안에서만 호출 가능하죠&lt;/p>
&lt;p>일반 함수는 실행을 시작하면 → 끝날 때까지 쭉 실행됨.
→ 중간에 멈추거나 재개하는 기능 없음&lt;/p>
&lt;p>suspend 함수는 실행 중 &amp;ldquo;중단&amp;quot;했다가 &amp;ldquo;재개&amp;quot;할 수 있음
→ 이게 코루틴의 핵심 기능&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> kotlinx.coroutines.*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;🕒 코루틴 A: 작업 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">2000&lt;/span>) &lt;span style="color:#75715e">// 여기서 중단됨 (2초 동안 멈춤)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;✅ 코루틴 A: 작업 완료&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;💡 코루틴 B: 작업 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(&lt;span style="color:#ae81ff">5&lt;/span>) { i &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;💡 코루틴 B: &lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">400&lt;/span>) &lt;span style="color:#75715e">// 반복하면서 작업함
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;💡 코루틴 B: 작업 완료&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>1 → 2 → 3 한 번에 실행됨. 멈추거나 나중에 이어서 실행 못함&lt;/p>
&lt;p>suspend 함수 (코루틴)
중간에 멈출 수 있음&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">helloSuspend&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>) &lt;span style="color:#75715e">// 💡 여기서 중단됨! (다른 일 가능)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 💡 1초 후에 여기서 다시 이어서 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="왜-일반-함수는-중단재개-안-되나">왜 일반 함수는 중단/재개 안 되나?
&lt;/h3>&lt;p>일반 함수는 JVM 바이트코드 수준에서 스택 기반으로 한 번에 실행되도록 설계됨.&lt;/p>
&lt;p>반면 suspend 함수는 컴파일 시 내부적으로 Continuation이라는 상태 저장 구조로 변환됨.
즉, **“지금 어디까지 실행했는지 기억하는 설계”**가 적용되는 것.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;🅰️ A 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">2000&lt;/span>) &lt;span style="color:#75715e">// ← 여기서 코루틴 A는 &amp;#34;suspend&amp;#34; = 대기 상태로 빠짐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;🅰️ A 끝&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(&lt;span style="color:#ae81ff">5&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;🅱️ B: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">400&lt;/span>) &lt;span style="color:#75715e">// ← 이것도 suspend 지점
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="결과">결과:
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅰️&lt;/span> A 시작: &lt;span style="color:#ae81ff">1747879622324&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">0&lt;/span> at &lt;span style="color:#ae81ff">1747879622329&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">1&lt;/span> at &lt;span style="color:#ae81ff">1747879622735&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">2&lt;/span> at &lt;span style="color:#ae81ff">1747879623140&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">3&lt;/span> at &lt;span style="color:#ae81ff">1747879623545&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">4&lt;/span> at &lt;span style="color:#ae81ff">1747879623947&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅰️&lt;/span> A 끝: &lt;span style="color:#ae81ff">1747879624333&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">5&lt;/span> at &lt;span style="color:#ae81ff">1747879624351&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">6&lt;/span> at &lt;span style="color:#ae81ff">1747879624755&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">7&lt;/span> at &lt;span style="color:#ae81ff">1747879625160&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">8&lt;/span> at &lt;span style="color:#ae81ff">1747879625565&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">9&lt;/span> at &lt;span style="color:#ae81ff">1747879625970&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="실행-흐름">실행 흐름:
&lt;/h4>&lt;p>A는 0ms에 시작해서 → delay(2000) → 2000ms쯤에 다시 실행될 준비 완료&lt;/p>
&lt;p>B는 0ms부터 시작해서 → 400ms 간격으로 반복&lt;/p>
&lt;p>2000ms쯤 되면 B는 5번째나 6번째 반복 중일 텐데&lt;/p>
&lt;p>그 타이밍에 스레드가 A를 재개할 틈이 생기면, A가 다시 실행됩니다&lt;/p>
&lt;h4 id="이게-가능한-이유">이게 가능한 이유:
&lt;/h4>&lt;p>코루틴은 항상 suspend → resume을 반복&lt;/p>
&lt;p>스레드가 놀지 않고 실행 가능한 코루틴에게 계속 작업을 넘김&lt;/p>
&lt;p>시간 순서가 충족되면 → A가 우선순위 없이도 재개됨&lt;/p>
&lt;h2 id="결론">결론:
&lt;/h2>&lt;p>코루틴은 일시 중단(suspend)과 재개(resume)가 가능한 함수로, 비동기 코드를 동기 코드처럼 쉽게 작성하게 해준다&lt;/p></description></item><item><title>코루틴 장점2: 비동기 코드를 동기 코드처럼 쉽게 작성하게 해준다</title><link>https://jaemin-baek.github.io/post/coroutine2/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutine2/</guid><description>&lt;h2 id="비동기-코드를-동기-코드처럼-쉽게-작성하게-해준다">비동기 코드를 동기 코드처럼 쉽게 작성하게 해준다
&lt;/h2>&lt;p>먼저 &amp;ldquo;비동기 코드를 동기처럼&amp;quot;이란 무슨 뜻인가?
비동기 코드는 원래 **콜백(callback)**이나 &lt;strong>이벤트 리스너&lt;/strong>로 작성되기 때문에,
코드 흐름이 분리되고 복잡해지기 쉬워요.&lt;/p>
&lt;p>하지만 코루틴을 사용하면, 그런 복잡한 구조를 &amp;ldquo;한 줄씩 순차적으로&amp;rdquo; 작성할 수 있어서
**마치 일반 함수(=동기 함수)**처럼 코드를 짤 수 있다는 뜻이에요.&lt;/p>
&lt;h3 id="예시-1-비동기-코드-콜백-지옥">예시 1: 비동기 코드 (콜백 지옥)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>getUser { user &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getProfile(user.id) { profile &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getPosts(profile.id) { posts &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;완료: &lt;/span>&lt;span style="color:#e6db74">$posts&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>중첩 콜백이 많아짐 (일명 콜백 헬/지옥)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>코드 흐름이 위→아래로 자연스럽지 않음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>예외 처리도 복잡&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="예시-2-코루틴-사용-동기처럼-보임">예시 2: 코루틴 사용 (동기처럼 보임)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchAll&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> user = getUser()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> profile = getProfile(user.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> posts = getPosts(profile.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;완료: &lt;/span>&lt;span style="color:#e6db74">$posts&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>마치 동기 함수처럼 보이죠?&lt;/p>
&lt;p>하지만 실제로는 getUser, getProfile, getPosts는 각각 suspend 함수이고&lt;/p>
&lt;p>내부적으로는 중단과 재개가 발생하지만, 작성 방식은 순차적이고 간단&lt;/p>
&lt;h3 id="다시-말해-한-줄-요약하면">다시 말해 한 줄 요약하면..!
&lt;/h3>&lt;blockquote>
&lt;p>&amp;ldquo;비동기 코드를 동기 코드처럼 쓴다&amp;rdquo; = 비동기의 복잡함을 숨기고, 자연스러운 코드 흐름을 만든다.&lt;/p>&lt;/blockquote></description></item><item><title>Kotlin 코루틴의 runBlocking, coroutineScope, supervisorScope 비교</title><link>https://jaemin-baek.github.io/post/coroutinescope/</link><pubDate>Wed, 19 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescope/</guid><description>&lt;h2 id="kotlin-코루틴의-실행-스코프-비교-runblocking-coroutinescope-supervisorscope">Kotlin 코루틴의 실행 스코프 비교: runBlocking, coroutineScope, supervisorScope
&lt;/h2>&lt;p>Kotlin의 코루틴 시스템은 다양한 실행 스코프 제공을 통해 구조적 동시성과 예외 분리를 가능하게 한다. 본 문서에서는 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>의 기능과 목적을 비교하고, 각각의 사용 상황과 실행 흐름 차이에 대해 기술한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 전통적인 스레드 기반 프로그래밍에 비해 더 적은 리소스로 동시성을 지원하며, 이를 위해 다양한 스코프 빌더가 제공된다. 그중 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>는 가장 자주 사용되는 고수준 코루틴 빌더로, 이들은 실행 방식과 예외 처리 구조에 있어 중요한 차이를 갖는다.&lt;/p>
&lt;hr>
&lt;h3 id="2-주요-차이점-요약">2. 주요 차이점 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>runBlocking&lt;/code>&lt;/th>
&lt;th>&lt;code>coroutineScope&lt;/code>&lt;/th>
&lt;th>&lt;code>supervisorScope&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>차단 여부&lt;/td>
&lt;td>호출한 &lt;strong>스레드를 차단&lt;/strong>&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 위치&lt;/td>
&lt;td>&lt;code>main()&lt;/code> 함수, 테스트&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자식 실패 전파&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>실패해도 다른 자식은 계속 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생성 스코프&lt;/td>
&lt;td>새 &lt;code>CoroutineScope&lt;/code> 생성&lt;/td>
&lt;td>상위 스코프 상속&lt;/td>
&lt;td>&lt;code>SupervisorJob&lt;/code> 기반 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 목적&lt;/td>
&lt;td>일반 코드와 코루틴 연결&lt;/td>
&lt;td>구조적 동시성&lt;/td>
&lt;td>예외 고립 및 분리 실행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="3-runblocking">3. runBlocking
&lt;/h3>&lt;p>&lt;code>runBlocking&lt;/code>은 코루틴 진입점을 제공하는 함수로, 일반적인 블로킹 코드(main 함수 등)에서 &lt;code>suspend&lt;/code> 함수를 사용할 수 있도록 한다. 내부적으로 현재 스레드를 차단하며, 코루틴이 완료될 때까지 대기한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>호출한 스레드를 직접 차단하며, UI 스레드에서는 사용을 지양해야 한다.&lt;/li>
&lt;li>&lt;code>CoroutineScope&lt;/code>를 생성하여 내부에서 &lt;code>launch&lt;/code>, &lt;code>async&lt;/code> 등을 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-coroutinescope">4. coroutineScope
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 현재 컨텍스트를 상속하는 &lt;code>CoroutineScope&lt;/code>를 생성하며, 내부의 모든 자식 코루틴이 종료될 때까지 &lt;code>suspend&lt;/code> 상태로 대기한다. 이는 구조적 동시성을 구현하는 핵심 도구로 사용된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child 1 done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child 2 done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;All children completed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>자식 중 하나라도 실패하면 전체 스코프가 취소된다.&lt;/li>
&lt;li>일반적으로 suspend 함수 내에서 사용된다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="5-supervisorscope">5. supervisorScope
&lt;/h3>&lt;p>supervisorScope는 자식 코루틴 간 실패 전파를 막고, 하나의 실패가 다른 작업에 영향을 미치지 않도록 하는 예외 격리 기능을 제공한다. 내부적으로 SupervisorJob을 사용하여 고립된 실행 환경을 형성한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> supervisorScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Child failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Other child still runs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>하나의 자식이 예외를 발생시켜도 다른 자식은 계속 실행된다.&lt;/li>
&lt;li>실시간 처리나 부분 실패를 허용하는 작업에 적합하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>코루틴의 실행 컨텍스트 선택은 코드의 동시성 구조와 예외 처리 전략에 직접적인 영향을 미친다. runBlocking은 동기-비동기 경계를 연결하는 데 유용하며, coroutineScope는 구조적 동시성을 제공하고, supervisorScope는 자식 코루틴의 독립 실행을 보장한다. 각 스코프의 특성을 이해하고 상황에 맞게 사용하는 것이 안전하고 예측 가능한 비동기 프로그래밍을 구현하는 데 핵심이 된다.&lt;/p>
&lt;hr></description></item><item><title>Kotlin 코루틴의 멀티스레드 동작 방식</title><link>https://jaemin-baek.github.io/post/coroutine/</link><pubDate>Sun, 16 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutine/</guid><description>&lt;h2 id="kotlin-coroutine의-멀티스레드-동작-방식">Kotlin Coroutine의 멀티스레드 동작 방식
&lt;/h2>&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(&lt;code>CoroutineDispatcher&lt;/code>)의 역할과 실행 흐름에 대해 서술한다.&lt;/p>
&lt;hr>
&lt;h3 id="2-코루틴과-스레드의-관계">2. 코루틴과 스레드의 관계
&lt;/h3>&lt;p>Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.&lt;/p>
&lt;hr>
&lt;h3 id="3-coroutinedispatcher의-역할">3. CoroutineDispatcher의 역할
&lt;/h3>&lt;p>&lt;code>CoroutineDispatcher&lt;/code>는 코루틴이 실행될 스레드를 결정하는 핵심 컴포넌트이다. 주요 디스패처는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Dispatchers.Default&lt;/code>: CPU 집약적인 작업을 위한 공유 스레드 풀을 사용한다. 일반적으로 코어 수에 비례한 스레드를 할당한다.&lt;/li>
&lt;li>&lt;code>Dispatchers.IO&lt;/code>: 블로킹 I/O 작업에 최적화된 디스패처로, 더 많은 수의 스레드를 동적으로 생성하여 처리한다.&lt;/li>
&lt;li>&lt;code>Dispatchers.Main&lt;/code>: UI 기반 애플리케이션에서 메인 스레드에서 실행되도록 보장한다. 안드로이드 또는 JavaFX 환경에서 사용된다.&lt;/li>
&lt;li>&lt;code>newSingleThreadContext(name: String)&lt;/code>: 명시적으로 단일 스레드를 생성하여 해당 코루틴만을 위해 사용할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;p>각 디스패처는 코루틴이 실행되는 스레드의 종류를 정의함으로써, 개발자가 동시성 또는 병렬성을 세밀하게 제어할 수 있도록 한다.&lt;/p>
&lt;hr>
&lt;h3 id="4-실행-예시-및-스레드-분산">4. 실행 예시 및 스레드 분산
&lt;/h3>&lt;p>다음은 다양한 디스패처를 지정하여 코루틴이 각각 다른 스레드에서 실행되는 예시이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> kotlinx.coroutines.*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Default dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;IO dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(newSingleThreadContext(&lt;span style="color:#e6db74">&amp;#34;MyThread&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Single thread context: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 세 개의 코루틴이 서로 다른 스레드에서 동시에 실행되는 구조를 갖는다. 이로써 코루틴이 단일 스레드에 국한되지 않으며, 디스패처 설정에 따라 명시적으로 병렬 실행이 가능함을 확인할 수 있다.&lt;/p>
&lt;h3 id="실행-결과">실행 결과:
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Single thread context: MyThread
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그런데 Default, IO 가 기대했던 DefaultDispatcher-worker-1 , DefaultDispatcher-worker-2 가 아니다.&lt;/p>
&lt;p>이건 Dispatchers.Default와 Dispatchers.IO가 같은 스레드에서 실행된 것처럼 보이는 현상인데 이유는 아래와 같다.&lt;/p>
&lt;h3 id="왜-dispatchersdefault와-io가-같은-스레드-이름일까">왜 Dispatchers.Default와 IO가 같은 스레드 이름일까?
&lt;/h3>&lt;h4 id="공유-풀을-사용-중">공유 풀을 사용 중
&lt;/h4>&lt;ol>
&lt;li>Dispatchers.Default와 Dispatchers.IO는 모두 스레드 풀(thread pool) 기반이다.&lt;/li>
&lt;li>둘 다 내부적으로 DefaultExecutor와 IOExecutor를 공유하는 구조가 있다.&lt;/li>
&lt;li>JVM이 할당한 첫 번째 워커 스레드(worker-1)가 여러 코루틴에 재사용될 수 있다.&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Dispatcher&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Dispatchers.Default&lt;/code>&lt;/td>
&lt;td>CPU 중심 작업용, &lt;strong>코어 수만큼의 스레드 풀&lt;/strong> 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Dispatchers.IO&lt;/code>&lt;/td>
&lt;td>I/O 중심 작업용, &lt;strong>무제한 스레드 풀&lt;/strong>, 내부적으로 &lt;code>Default&lt;/code>를 재사용함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>newSingleThreadContext()&lt;/code>&lt;/td>
&lt;td>오직 &lt;strong>1개의 전용 스레드&lt;/strong>만 사용하는 디스패처, 명시적으로 생성한 스레드 사용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>즉, 같은 워커가 같은 순간에 여러 코루틴을 처리하지 않더라도, 스레드 풀 안에서 동적으로 배정되다 보니 같은 이름이 출력될 수 있다.&lt;/p>
&lt;h4 id="작은-예제라-워커-수가-1개로-충분한-상황">작은 예제라 워커 수가 1개로 충분한 상황
&lt;/h4>&lt;p>runBlocking + 3개의 launch를 실행할 뿐이라서, 코어 수가 충분하거나 작업이 짧을 경우 JVM은 worker-1만 사용한다. 내부적으로 DefaultDispatcher-worker-1, -2, -3 등이 필요 시 생성&lt;/p>
&lt;h3 id="확인-실험">확인 실험
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Default dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;IO dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(newSingleThreadContext(&lt;span style="color:#e6db74">&amp;#34;MyThread&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Single thread context: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="실행-결과-1">실행 결과
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Single thread context: MyThread
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="5-코루틴의-스레드-전환">5. 코루틴의 스레드 전환
&lt;/h3>&lt;p>코루틴은 &lt;code>withContext()&lt;/code> 함수를 통해 실행 중인 스레드를 동적으로 전환할 수 있다. 이는 컨텍스트 전환(Context Switch)을 명시적으로 수행하는 것으로, 특정 블록의 실행을 다른 디스패처가 관리하도록 위임하는 방식이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sample&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Start: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;IO context: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Resume: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 코루틴의 유연성과 구조적 동시성(Structured Concurrency)을 강화하는 핵심 기제로 작용한다.&lt;/p>
&lt;h3 id="실행-결과-2">실행 결과:
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Start: main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO context: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Resume: main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="6-동시성과-병렬성">6. 동시성과 병렬성
&lt;/h3>&lt;p>코루틴은 기본적으로 협조적(concurrent) 실행을 지향하나, 다중 디스패처를 활용하면 병렬성(parallelism)도 구현 가능하다. async와 await를 활용하면 서로 독립적인 계산을 동시에 수행하면서 결과를 효율적으로 병합할 수 있다.
다음은 Kotlin의 &lt;code>async&lt;/code>와 &lt;code>await&lt;/code>를 활용하여 두 작업을 병렬로 실행하고, 그 결과를 합산하는 예제이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// await: 결과가 준비될 때까지 suspend
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> resultA = async(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default) { computeA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> resultB = async(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) { computeB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> combined = resultA.await() + resultB.await()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="실행-흐름-설명">실행 흐름 설명
&lt;/h3>&lt;ol>
&lt;li>&lt;code>computeA()&lt;/code>는 &lt;code>Dispatchers.Default&lt;/code> 디스패처에서 실행되며, 이는 CPU 집약적인 작업을 위한 공용 스레드 풀을 사용한다.&lt;/li>
&lt;li>&lt;code>computeB()&lt;/code>는 &lt;code>Dispatchers.IO&lt;/code> 디스패처에서 실행되며, I/O 블로킹 작업에 최적화된 스레드 풀에서 처리된다.&lt;/li>
&lt;li>&lt;code>async&lt;/code>를 통해 두 작업은 &lt;strong>동시에 실행&lt;/strong>되며, 서로 다른 스레드에서 병렬로 수행된다.&lt;/li>
&lt;li>&lt;code>await()&lt;/code>는 각각의 결과가 준비될 때까지 &lt;strong>suspend 상태로 대기&lt;/strong>하며, 이 동안 다른 코루틴이 실행될 수 있다.&lt;/li>
&lt;li>두 &lt;code>await()&lt;/code> 호출이 완료되면 &lt;code>resultA&lt;/code>와 &lt;code>resultB&lt;/code>의 값을 더하여 &lt;code>combined&lt;/code>에 결과를 저장한다.&lt;/li>
&lt;/ol>
&lt;p>이러한 병렬 실행은 코어 수에 따른 스레드 분산을 통해 실행 성능을 높이는 데 효과적이다.&lt;/p>
&lt;h3 id="예시-구현">예시 구현
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">computeA&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Running computeA on: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">computeB&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Running computeB on: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="실행-결과-3">실행 결과:
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Running computeA on: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running computeB on: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>computeA()는 약 500ms 후 10을 반환하고, computeB()는 약 1000ms 후 20을 반환한다. 따라서 combined의 값은 30이다.&lt;/p>
&lt;hr>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>Kotlin의 코루틴은 전통적인 스레드 기반 프로그래밍의 한계를 극복하고, 비동기 처리를 보다 안전하고 구조적으로 구현할 수 있도록 설계되었다. 멀티스레드 환경에서의 코루틴 실행은 디스패처 설정을 통해 세밀히 제어되며, 협조적 실행 모델을 기반으로 하되 병렬 처리를 통해 성능 최적화도 가능하다. 이는 현대 애플리케이션 개발에서 요구되는 고성능 동시 처리 요구를 효과적으로 충족시킨다.&lt;/p></description></item></channel></rss>