<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Job on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/job/</link><description>Recent content in Job on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 19 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/job/index.xml" rel="self" type="application/rss+xml"/><item><title>구조적 동시성이란 무엇인가? 코루틴의 안정성과 예측 가능성을 위한 원칙</title><link>https://jaemin-baek.github.io/post/coroutinestructuredconcurrency/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinestructuredconcurrency/</guid><description>&lt;h2 id="구조적-동시성이란-무엇인가">구조적 동시성이란 무엇인가?
&lt;/h2>&lt;p>코루틴의 안정성과 예측 가능성을 위한 원칙&lt;/p>
&lt;p>Kotlin의 코루틴 철학에서 가장 핵심적인 개념 중 하나가 바로 **구조적 동시성(Structured Concurrency)**이다.&lt;br>
이 개념은 코루틴이 언제 시작되고 언제 종료되는지를 &lt;strong>코드의 구조(스코프)에 따라 명확하게 보장&lt;/strong>하도록 만든다.&lt;/p>
&lt;hr>
&lt;h3 id="한줄-정의">한줄 정의
&lt;/h3>&lt;blockquote>
&lt;p>**구조적 동시성(Structured Concurrency)**이란&lt;br>
&amp;ldquo;&lt;strong>코루틴의 실행 범위와 생명주기를 코드 구조에 따라 명확하게 관리&lt;/strong>하는 방식&amp;quot;이다.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h3 id="왜-필요한가">왜 필요한가?
&lt;/h3>&lt;p>전통적인 비동기 코드에서는 다음과 같은 문제가 자주 발생한다:&lt;/p>
&lt;ul>
&lt;li>콜백 지옥&lt;/li>
&lt;li>예외가 무시됨&lt;/li>
&lt;li>남은 코루틴이 언제 끝날지 알 수 없음&lt;/li>
&lt;li>메모리 누수&lt;/li>
&lt;/ul>
&lt;p>구조적 동시성은 이를 해결한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>구조적 동시성에서 보장되는 동작&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>코루틴 생명주기&lt;/td>
&lt;td>부모 스코프가 닫히면 자식 코루틴도 종료됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 처리&lt;/td>
&lt;td>자식 예외는 부모로 전파됨 (또는 Supervisor로 분리 처리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 누수 방지&lt;/td>
&lt;td>스코프 바깥에 살아남는 코루틴 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>테스트 가능성&lt;/td>
&lt;td>어느 시점에 어떤 작업이 실행 중인지 추론 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="예시-구조적-동시성이-없는-코드">예시: 구조적 동시성이 없는 코드
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GlobalScope&lt;/span>.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 이 코루틴은 언제 끝날지 아무도 모름
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>GlobalScope&lt;/code>는 앱 전체 생명주기에 묶여 있으므로 정리 불가&lt;/li>
&lt;li>호출한 쪽에서는 &lt;strong>코루틴 취소, 예외 추적 불가능&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="예시-구조적-동시성이-적용된-코드">예시: 구조적 동시성이 적용된 코드
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { getUser() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { getPosts() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>coroutineScope&lt;/code> 안에서 실행된 모든 코루틴은 이 블록이 끝날 때까지 완료되어야 한다.&lt;/li>
&lt;li>이 블록이 끝난다는 것은 &lt;strong>모든 자식 코루틴이 정상 종료되었음을 보장&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="구조적-동시성의-핵심-규칙">구조적 동시성의 핵심 규칙
&lt;/h3>&lt;ol>
&lt;li>모든 코루틴은 &lt;strong>명확한 부모 스코프&lt;/strong> 내에서 실행된다&lt;/li>
&lt;li>부모가 종료되면 자식 코루틴도 자동으로 취소된다&lt;/li>
&lt;li>예외는 위로 전파되어 일관된 방식으로 처리된다&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="kotlin이-구조적-동시성을-지원하는-방식">Kotlin이 구조적 동시성을 지원하는 방식
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>CoroutineScope&lt;/code>&lt;/td>
&lt;td>생명주기 단위 스코프 정의&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>coroutineScope {}&lt;/code>&lt;/td>
&lt;td>suspend 함수 내부 일시적 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 간 예외 전파 제어&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>withContext&lt;/code>&lt;/td>
&lt;td>부모-자식 관계를 유지한 채 컨텍스트 전환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>viewModelScope&lt;/code>, &lt;code>lifecycleScope&lt;/code>&lt;/td>
&lt;td>Android 앱 생명주기에 연동된 구조적 스코프 제공&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="요약-정리">요약 정리
&lt;/h3>&lt;blockquote>
&lt;p>구조적 동시성은 &lt;strong>코루틴이 언제 시작되고 언제 종료되는지를 명확하게 통제&lt;/strong>할 수 있도록 한다.&lt;br>
이를 통해 개발자는 &lt;strong>예측 가능한 흐름, 자동 정리, 안정적인 에러 전파&lt;/strong>를 기반으로&lt;br>
복잡한 비동기 프로그램을 안전하게 설계할 수 있다.&lt;/p>&lt;/blockquote></description></item><item><title>CoroutineContext란 무엇인가? 코루틴 실행 환경의 핵심 이해</title><link>https://jaemin-baek.github.io/post/coroutinecontext/</link><pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinecontext/</guid><description>&lt;h2 id="coroutinecontext란-무엇인가-코루틴-실행-환경의-핵심-이해">CoroutineContext란 무엇인가? 코루틴 실행 환경의 핵심 이해
&lt;/h2>&lt;p>Kotlin 코루틴을 사용하다 보면 반드시 등장하는 개념이 있다. 바로 &lt;code>CoroutineContext&lt;/code>.&lt;br>
이 객체는 코루틴의 실행에 필요한 모든 정보를 담고 있는 &lt;strong>컨텍스트 컨테이너&lt;/strong>이며,&lt;br>
코루틴의 동작 방식, 위치, 생명주기, 예외 처리 방식 등을 결정하는 &lt;strong>핵심 구성 요소&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;h3 id="1-coroutinecontext란">1. CoroutineContext란?
&lt;/h3>&lt;blockquote>
&lt;p>&lt;code>CoroutineContext&lt;/code>는 코루틴이 실행되기 위한 환경 정보들을 담고 있는 키-값 구조의 컨테이너이다.&lt;/p>&lt;/blockquote>
&lt;p>Kotlin에서 코루틴을 실행하려면 단순히 코드만으로는 부족하다.&lt;br>
다음과 같은 부가 정보들이 필요하다:&lt;/p>
&lt;ul>
&lt;li>어떤 스레드에서 실행할 것인가? (&lt;code>Dispatcher&lt;/code>)&lt;/li>
&lt;li>코루틴의 생명주기는 어떻게 관리할 것인가? (&lt;code>Job&lt;/code>)&lt;/li>
&lt;li>디버깅 시 어떤 이름으로 보일 것인가? (&lt;code>CoroutineName&lt;/code>)&lt;/li>
&lt;li>예외가 발생했을 때 어떻게 처리할 것인가? (&lt;code>CoroutineExceptionHandler&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>이 모든 정보를 하나로 묶은 것이 바로 &lt;code>CoroutineContext&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;h3 id="2-주요-구성-요소">2. 주요 구성 요소
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>요소&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>예시&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Job&lt;/code>&lt;/td>
&lt;td>코루틴의 생명주기 추적 및 취소 관리&lt;/td>
&lt;td>&lt;code>Job()&lt;/code>, &lt;code>SupervisorJob()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Dispatcher&lt;/code>&lt;/td>
&lt;td>코루틴을 실행할 스레드 결정&lt;/td>
&lt;td>&lt;code>Dispatchers.Default&lt;/code>, &lt;code>Dispatchers.IO&lt;/code>, &lt;code>Dispatchers.Main&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CoroutineName&lt;/code>&lt;/td>
&lt;td>디버깅용 이름&lt;/td>
&lt;td>&lt;code>CoroutineName(&amp;quot;LoginFlow&amp;quot;)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CoroutineExceptionHandler&lt;/code>&lt;/td>
&lt;td>예외 처리 전략&lt;/td>
&lt;td>&lt;code>CoroutineExceptionHandler { _, e -&amp;gt; log(e) }&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="3-coroutinecontext-조합-방법">3. CoroutineContext 조합 방법
&lt;/h3>&lt;p>&lt;code>CoroutineContext&lt;/code>는 &lt;code>+&lt;/code> 연산자를 통해 여러 구성 요소를 결합할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> context = Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + CoroutineName(&lt;span style="color:#e6db74">&amp;#34;ExampleCoroutine&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>위 코드에서는 Job, Dispatcher, CoroutineName이 하나의 Context로 결합된다.&lt;/li>
&lt;li>이 Context는 CoroutineScope나 launch 등에서 사용 가능하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-coroutinescope와-coroutinecontext">4. CoroutineScope와 CoroutineContext
&lt;/h3>&lt;p>CoroutineScope는 내부적으로 반드시 하나의 CoroutineContext를 포함한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO + Job())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 Scope에서 launch한 모든 코루틴은 이 Context를 상속받는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Context: &lt;/span>&lt;span style="color:#e6db74">$coroutineContext&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="출력-예시">출력 예시
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Context: [JobImpl{Active}&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>a67cf4c, &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="5-withcontext와-coroutinecontext">5. withContext와 CoroutineContext
&lt;/h3>&lt;p>코루틴의 Context를 전환하려면 withContext를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 이 블록은 IO 스레드에서 실행됨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>현재 코루틴은 일시 정지되고&lt;/li>
&lt;li>새로운 Context에서 블록이 실행되며&lt;/li>
&lt;li>완료 후 원래 Context로 복귀된다&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="6-coroutinecontext-키워드">6. coroutineContext 키워드
&lt;/h3>&lt;p>코루틴 내부에서는 coroutineContext 키워드를 통해
자신이 실행 중인 Context를 언제든지 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(coroutineContext[Job]) &lt;span style="color:#75715e">// 현재 Job
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(coroutineContext[CoroutineName]) &lt;span style="color:#75715e">// 이름 (있다면)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="7-실전-활용-예시">7. 실전 활용 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + CoroutineName(&lt;span style="color:#e6db74">&amp;#34;Worker&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Context: &lt;/span>&lt;span style="color:#e6db74">$coroutineContext&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>출력 예&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Context: [JobImpl{Active}&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>e5c3f4, CoroutineName(Worker), &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="8-결론">8. 결론
&lt;/h3>&lt;p>CoroutineContext는 Kotlin 코루틴의 실행 환경을 구성하는 핵심 구조다.
Dispatcher, Job, Name, ExceptionHandler 등 다양한 정보가 담겨 있으며,
CoroutineScope, withContext, launch, async 등 코루틴 관련 도구들은 모두 이 Context를 바탕으로 동작한다.&lt;/p>
&lt;p>코루틴을 잘 다루려면 단순한 launch나 async뿐 아니라,
이들을 감싸고 있는 CoroutineContext의 구조와 흐름을 정확히 이해하는 것이 중요하다.&lt;/p></description></item><item><title>CoroutineScope.cancel()과 Job.cancel()은 같은가?</title><link>https://jaemin-baek.github.io/post/coroutinejobcancel/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinejobcancel/</guid><description>&lt;h2 id="coroutinescopecancel과-jobcancel은-같은가">CoroutineScope.cancel()과 Job.cancel()은 같은가?
&lt;/h2>&lt;p>Kotlin 코루틴을 사용하다 보면 &lt;code>CoroutineScope.cancel()&lt;/code>과 &lt;code>Job.cancel()&lt;/code>을 모두 보게 된다. 이 둘은 이름은 비슷하지만, 실제로 동일한 기능일까? 둘의 차이는 어디에 있을까? 본 포스트에서는 이 질문을 중심으로, Kotlin 표준과 &lt;code>kotlinx.coroutines&lt;/code>의 차이를 기반으로 정확한 동작 방식을 설명한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-job이란">1. Job이란?
&lt;/h3>&lt;p>&lt;code>Job&lt;/code>은 Kotlin 코루틴의 생명주기와 상태를 관리하는 객체다.&lt;br>
각 코루틴에는 하나의 Job이 할당되며, 이를 통해 다음을 제어할 수 있다:&lt;/p>
&lt;ul>
&lt;li>코루틴의 실행 상태 추적 (활성, 취소, 완료)&lt;/li>
&lt;li>&lt;code>cancel()&lt;/code>을 통한 중단 신호 전달&lt;/li>
&lt;li>&lt;code>join()&lt;/code>을 통한 종료 대기&lt;/li>
&lt;li>부모-자식 관계 관리&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-coroutinescope는-job을-포함한다">2. CoroutineScope는 Job을 포함한다
&lt;/h3>&lt;p>&lt;code>CoroutineScope&lt;/code>는 코루틴을 실행할 수 있는 컨텍스트이며, 내부적으로 &lt;code>CoroutineContext&lt;/code>를 통해 &lt;strong>Job을 반드시 포함&lt;/strong>한다. 예를 들어 다음과 같은 코드가 있을 때:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실제로는 다음과 같은 컨텍스트가 구성된다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, Job은 자동 생성되며 scope 안에 숨겨져 있다. 하지만 이 Job에 직접 접근할 수는 없다.&lt;/p>
&lt;hr>
&lt;h3 id="3-scopecancel은-왜-되는가">3. scope.cancel()은 왜 되는가?
&lt;/h3>&lt;p>Kotlin 표준의 CoroutineScope 인터페이스는 cancel() 함수를 직접 정의하지 않는다.
하지만 kotlinx.coroutines 라이브러리는 다음과 같은 확장 함수를 제공한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.cancel(cause: CancellationException? = &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineContext[Job]&lt;span style="color:#f92672">?.&lt;/span>cancel(cause)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, CoroutineScope.cancel()은 실제로는 자신의 CoroutineContext에서 Job을 꺼내고, 그 Job의 cancel()을 호출하는 확장 함수일 뿐이다.&lt;/p>
&lt;p>따라서 다음과 같은 코드는 정상적으로 작동한다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.cancel() &lt;span style="color:#75715e">// kotlinx.coroutines 확장 함수로 동작
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="4-job을-명시적으로-만들면-어떤-이점이-있나">4. Job을 명시적으로 만들면 어떤 이점이 있나?
&lt;/h3>&lt;p>Job을 직접 변수로 만들어 Scope에 넣으면, Scope 밖에서도 Job을 통해 상태를 제어할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = Job()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(job + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>job.cancel() &lt;span style="color:#75715e">// scope의 모든 코루틴 취소 가능
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>CoroutineScope.cancel()은 Kotlin 표준의 기능이 아니라,
kotlinx.coroutines에서 제공하는 확장 함수이다.
내부적으로는 Job.cancel()을 위임 호출하며, 같은 대상이라면 동작 결과는 동일하다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 SupervisorJob의 역할과 scopeJob 구조</title><link>https://jaemin-baek.github.io/post/supervisorjob/</link><pubDate>Tue, 25 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/supervisorjob/</guid><description>&lt;h2 id="kotlin-coroutine에서-supervisorjob의-역할과-scopejob-구조">Kotlin Coroutine에서 SupervisorJob의 역할과 &lt;code>scopeJob&lt;/code> 구조
&lt;/h2>&lt;p>Kotlin 코루틴에서는 비동기 작업의 생명주기와 예외 처리를 체계적으로 관리하기 위해 &lt;code>Job&lt;/code> 기반의 구조적 동시성을 제공한다. 본 문서에서는 그 중 &lt;code>SupervisorJob&lt;/code>을 중심으로 하는 &lt;code>scopeJob&lt;/code>의 역할과 필요성, 그리고 일반 &lt;code>Job&lt;/code>과의 차이에 대해 고찰한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 &lt;code>CoroutineScope&lt;/code> 내에서 생성된 자식 코루틴들과 부모 코루틴 간의 관계를 명확히 하여 예측 가능한 동시 실행을 가능하게 한다. 이때 &lt;code>Job&lt;/code>은 각 코루틴의 생명주기를 추적하고, 취소 여부를 상위 또는 하위로 전파하는 핵심 구성요소로 작동한다. Kotlin에서는 &lt;code>Job&lt;/code> 외에도 &lt;code>SupervisorJob&lt;/code>이라는 특별한 형태의 Job을 제공하여, 자식 간의 실패 전파를 제어할 수 있다.&lt;/p>
&lt;hr>
&lt;h3 id="2-구조-예시">2. 구조 예시
&lt;/h3>&lt;p>아래는 &lt;code>SupervisorJob&lt;/code>을 기반으로 한 &lt;code>scopeJob&lt;/code>을 생성하는 전형적인 코드 예시이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scopeJob = SupervisorJob()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(scopeJob + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 scope 내에서 생성되는 모든 자식 코루틴이 SupervisorJob을 공유하도록 구성되며, 하나의 자식이 실패하더라도 다른 자식은 영향을 받지 않고 독립적으로 실행을 계속할 수 있도록 한다.&lt;/p>
&lt;hr>
&lt;h3 id="3-supervisorjob의-동작-원리">3. SupervisorJob의 동작 원리
&lt;/h3>&lt;p>&lt;code>SupervisorJob&lt;/code>은 일반 &lt;code>Job&lt;/code>과 달리, 자식 코루틴이 실패(Exception 발생 등)하더라도 &lt;strong>부모나 다른 자식 코루틴에게 실패를 전파하지 않는다&lt;/strong>. 이를 통해 &lt;strong>고립된 실패 처리&lt;/strong>와 &lt;strong>부분 성공 전략&lt;/strong>을 구현할 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>Job (기본)&lt;/th>
&lt;th>SupervisorJob&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>자식 실패 시&lt;/td>
&lt;td>전체 스코프 취소&lt;/td>
&lt;td>실패한 자식만 취소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>형제 간 전파&lt;/td>
&lt;td>예외 전파됨&lt;/td>
&lt;td>전파되지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 목적&lt;/td>
&lt;td>전체 작업의 일관성 보장&lt;/td>
&lt;td>부분 실패 허용, 독립 실행 구조&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>SupervisorJob&lt;/code>은 &lt;code>supervisorScope {}&lt;/code> 또는 직접 Scope를 구성할 때 명시적으로 사용되며, &lt;code>CoroutineScope(SupervisorJob())&lt;/code> 형태로 자주 활용된다.&lt;/p>
&lt;hr>
&lt;h3 id="4-실용적-사용-맥락">4. 실용적 사용 맥락
&lt;/h3>&lt;ul>
&lt;li>병렬로 다수의 외부 API를 호출할 때&lt;/li>
&lt;li>자식 코루틴 중 하나가 실패하더라도 나머지 결과가 유효한 경우&lt;/li>
&lt;li>백그라운드 데이터 동기화 작업에서 개별 요청 단위의 실패를 분리하고 싶은 경우&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 개별 작업 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 개별 작업 2 (실패해도 다른 작업에는 영향 없음)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 scope 내부에서 수행되는 코루틴들이 독립적인 실행 환경을 갖도록 보장한다.&lt;/p>
&lt;hr>
&lt;h3 id="5-예외-처리와-결합">5. 예외 처리와 결합
&lt;/h3>&lt;p>실제 응용에서는 SupervisorJob과 함께 CoroutineExceptionHandler를 결합하여 보다 견고한 예외 처리를 구현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> exceptionHandler = CoroutineExceptionHandler { _, throwable &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#e6db74">&amp;#34;Unhandled exception: &lt;/span>&lt;span style="color:#e6db74">$throwable&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + exceptionHandler)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 실패한 자식 코루틴의 예외를 처리하면서도 전체 스코프를 안정적으로 유지할 수 있게 한다.&lt;/p>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>SupervisorJob은 Kotlin 코루틴 기반 구조에서 자식 간의 예외 전파를 분리하고, 작업 단위의 독립성과 견고성을 확보하기 위한 중요한 구성요소이다. 일반 Job이 전체 일괄 실패를 선호하는 전략이라면, SupervisorJob은 부분 실패를 수용하며 전체 서비스의 연속성을 유지하는 전략에 적합하다. 이를 통해 복잡한 비동기 시스템에서도 예측 가능한 실행 흐름과 회복 가능한 오류 처리가 가능해진다.&lt;/p>
&lt;hr></description></item></channel></rss>