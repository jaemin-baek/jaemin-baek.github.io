<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Coroutinescope on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/coroutinescope/</link><description>Recent content in Coroutinescope on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/coroutinescope/index.xml" rel="self" type="application/rss+xml"/><item><title>CoroutineScope.cancel()과 Job.cancel()은 같은가?</title><link>https://jaemin-baek.github.io/post/coroutinejobcancel/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinejobcancel/</guid><description>&lt;h2 id="coroutinescopecancel과-jobcancel은-같은가">CoroutineScope.cancel()과 Job.cancel()은 같은가?
&lt;/h2>&lt;p>Kotlin 코루틴을 사용하다 보면 &lt;code>CoroutineScope.cancel()&lt;/code>과 &lt;code>Job.cancel()&lt;/code>을 모두 보게 된다. 이 둘은 이름은 비슷하지만, 실제로 동일한 기능일까? 둘의 차이는 어디에 있을까? 본 포스트에서는 이 질문을 중심으로, Kotlin 표준과 &lt;code>kotlinx.coroutines&lt;/code>의 차이를 기반으로 정확한 동작 방식을 설명한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-job이란">1. Job이란?
&lt;/h3>&lt;p>&lt;code>Job&lt;/code>은 Kotlin 코루틴의 생명주기와 상태를 관리하는 객체다.&lt;br>
각 코루틴에는 하나의 Job이 할당되며, 이를 통해 다음을 제어할 수 있다:&lt;/p>
&lt;ul>
&lt;li>코루틴의 실행 상태 추적 (활성, 취소, 완료)&lt;/li>
&lt;li>&lt;code>cancel()&lt;/code>을 통한 중단 신호 전달&lt;/li>
&lt;li>&lt;code>join()&lt;/code>을 통한 종료 대기&lt;/li>
&lt;li>부모-자식 관계 관리&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-coroutinescope는-job을-포함한다">2. CoroutineScope는 Job을 포함한다
&lt;/h3>&lt;p>&lt;code>CoroutineScope&lt;/code>는 코루틴을 실행할 수 있는 컨텍스트이며, 내부적으로 &lt;code>CoroutineContext&lt;/code>를 통해 &lt;strong>Job을 반드시 포함&lt;/strong>한다. 예를 들어 다음과 같은 코드가 있을 때:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실제로는 다음과 같은 컨텍스트가 구성된다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, Job은 자동 생성되며 scope 안에 숨겨져 있다. 하지만 이 Job에 직접 접근할 수는 없다.&lt;/p>
&lt;hr>
&lt;h3 id="3-scopecancel은-왜-되는가">3. scope.cancel()은 왜 되는가?
&lt;/h3>&lt;p>Kotlin 표준의 CoroutineScope 인터페이스는 cancel() 함수를 직접 정의하지 않는다.
하지만 kotlinx.coroutines 라이브러리는 다음과 같은 확장 함수를 제공한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.cancel(cause: CancellationException? = &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineContext[Job]&lt;span style="color:#f92672">?.&lt;/span>cancel(cause)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, CoroutineScope.cancel()은 실제로는 자신의 CoroutineContext에서 Job을 꺼내고, 그 Job의 cancel()을 호출하는 확장 함수일 뿐이다.&lt;/p>
&lt;p>따라서 다음과 같은 코드는 정상적으로 작동한다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.cancel() &lt;span style="color:#75715e">// kotlinx.coroutines 확장 함수로 동작
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="4-job을-명시적으로-만들면-어떤-이점이-있나">4. Job을 명시적으로 만들면 어떤 이점이 있나?
&lt;/h3>&lt;p>Job을 직접 변수로 만들어 Scope에 넣으면, Scope 밖에서도 Job을 통해 상태를 제어할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = Job()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(job + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>job.cancel() &lt;span style="color:#75715e">// scope의 모든 코루틴 취소 가능
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>CoroutineScope.cancel()은 Kotlin 표준의 기능이 아니라,
kotlinx.coroutines에서 제공하는 확장 함수이다.
내부적으로는 Job.cancel()을 위임 호출하며, 같은 대상이라면 동작 결과는 동일하다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 coroutineScope의 일시 정지(suspend) 동작 해석</title><link>https://jaemin-baek.github.io/post/coroutinescopesuspend/</link><pubDate>Sun, 02 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescopesuspend/</guid><description>&lt;h2 id="kotlin-coroutine에서-coroutinescope의-일시-정지suspend-동작-해석">Kotlin Coroutine에서 &lt;code>coroutineScope&lt;/code>의 일시 정지(suspend) 동작 해석
&lt;/h2>&lt;p>Kotlin의 코루틴은 비동기 제어 흐름을 지원하는 언어 차원의 기능으로, 실행의 흐름을 일시적으로 중단하고 재개할 수 있는 &lt;code>suspend&lt;/code> 키워드를 핵심으로 한다. 이 가운데 &lt;code>coroutineScope&lt;/code> 빌더는 구조적 동시성(Structured Concurrency)을 구성하는 대표적 구성 요소이며, “현재 코루틴을 일시 정지시킨다”는 표현으로 설명되곤 한다. 본 문서에서는 이 표현의 기술적 의미와 실제 실행 흐름을 해석한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개념적-정의">1. 개념적 정의
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 &lt;code>suspend&lt;/code> 함수 내에서 사용 가능한 고차 함수로, 내부에서 생성된 자식 코루틴들이 &lt;strong>모두 완료될 때까지&lt;/strong> 현재 코루틴의 실행을 &lt;strong>일시 정지(suspend)&lt;/strong> 상태로 유지한다. 이 suspend는 &lt;strong>스레드 블로킹(blocking)이 아닌, 코루틴 자체의 일시 정지&lt;/strong>를 의미하며, 이는 코루틴 스케줄러 수준에서 관리된다.&lt;/p>
&lt;hr>
&lt;h3 id="2-코드-예시-및-실행-흐름">2. 코드 예시 및 실행 흐름
&lt;/h3>&lt;p>다음은 &lt;code>coroutineScope&lt;/code>의 대표적인 사용 예이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">outerFunction&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;1. 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;2. 자식 코루틴 완료&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;3. coroutineScope 블록 종료 후 실행됨&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="예상-출력-순서">예상 출력 순서
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1.&lt;/span> 시작
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2.&lt;/span> 자식 코루틴 완료
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3.&lt;/span> coroutineScope 블록 종료 후 실행됨
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="동작-설명">동작 설명
&lt;/h3>&lt;ul>
&lt;li>outerFunction은 하나의 suspend 함수이며 코루틴 컨텍스트 내에서 실행된다.&lt;/li>
&lt;li>그 안의 coroutineScope는 내부에서 자식 코루틴을 생성하고, **해당 자식이 완료될 때까지 현재 코루틴의 실행을 일시 중단(suspend)**한다.&lt;/li>
&lt;li>자식이 완료되면 다시 이어서 실행되며, 이후의 println(&amp;ldquo;3. &amp;hellip;&amp;quot;)이 실행된다.&lt;/li>
&lt;/ul>
&lt;h3 id="3-suspend와-blocking의-구분">3. suspend와 blocking의 구분
&lt;/h3>&lt;p>&lt;code>suspend&lt;/code>는 &lt;strong>비동기 흐름 제어&lt;/strong>를 위한 메커니즘으로, 스레드를 점유하지 않고 중단할 수 있다. 이는 &lt;code>Thread.sleep&lt;/code>과 같은 &lt;strong>스레드 차단(blocking)&lt;/strong> 방식과 본질적으로 다르다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>suspend&lt;/th>
&lt;th>blocking&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대상&lt;/td>
&lt;td>코루틴&lt;/td>
&lt;td>스레드&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>리소스 점유&lt;/td>
&lt;td>없음&lt;/td>
&lt;td>있음 (CPU 점유)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실행 재개 방식&lt;/td>
&lt;td>코루틴 스케줄러가 재개&lt;/td>
&lt;td>외부 조건이 충족되어야 해제&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>대표 예시&lt;/td>
&lt;td>&lt;code>delay()&lt;/code>, &lt;code>coroutineScope {}&lt;/code>&lt;/td>
&lt;td>&lt;code>Thread.sleep()&lt;/code>, &lt;code>runBlocking {}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>병렬성 확보&lt;/td>
&lt;td>고성능 병렬 처리 가능&lt;/td>
&lt;td>동시성 제한, 블로킹 자원 증가&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>따라서 &amp;ldquo;&lt;code>현재 코루틴을 일시 정지시킨다&lt;/code>&amp;ldquo;는 표현은 &lt;strong>스레드가 멈추는 것이 아니라&lt;/strong>,&lt;br>
해당 suspend 함수의 &lt;strong>논리적 실행 흐름만 대기 상태로 전환된다&lt;/strong>는 의미이다.&lt;/p>
&lt;hr>
&lt;h3 id="4-구조적-동시성과의-관계">4. 구조적 동시성과의 관계
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 구조적 동시성을 보장하는 코루틴 빌더로,&lt;br>
블록 내 자식 코루틴이 &lt;strong>모두 완료되기 전까지 suspend 상태를 유지&lt;/strong>한다.&lt;br>
이 구조는 다음과 같은 특징을 가진다:&lt;/p>
&lt;ul>
&lt;li>모든 자식 코루틴이 종료되기 전까지 다음 코드로 진행되지 않음&lt;/li>
&lt;li>자식 중 하나라도 실패하면 전체 블록이 예외와 함께 취소됨&lt;/li>
&lt;li>suspend 함수 안에서 사용되어 자연스럽게 일시 중단을 허용함&lt;/li>
&lt;/ul>
&lt;p>이러한 특성은 복잡한 비동기 로직의 안정성을 높이고, 예외 흐름을 간결하게 구성할 수 있게 해준다.&lt;/p>
&lt;hr>
&lt;h3 id="5-결론">5. 결론
&lt;/h3>&lt;p>&amp;ldquo;&lt;code>coroutineScope&lt;/code>는 현재 코루틴을 일시 정지시킨다&amp;quot;는 표현은&lt;br>
&lt;strong>비동기 흐름 내에서 해당 suspend 함수의 실행이 자식 코루틴의 완료 시점까지 일시적으로 중단(suspend)&lt;/strong>&lt;br>
된다는 의미로 해석해야 한다.&lt;/p>
&lt;p>이는 스레드를 차단하지 않으면서도 자식 작업을 &lt;strong>안전하게 동기화&lt;/strong>할 수 있게 하며,&lt;br>
Kotlin 코루틴의 구조적 동시성 모델에서 핵심적인 개념 중 하나이다.&lt;/p>
&lt;p>개발자는 &lt;code>suspend&lt;/code>와 &lt;code>blocking&lt;/code>의 차이를 명확히 이해함으로써,&lt;br>
불필요한 스레드 점유 없이 효율적인 비동기 시스템을 설계할 수 있다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 CoroutineScope와 coroutineScope 빌더의 개념적 차이</title><link>https://jaemin-baek.github.io/post/coroutinescopevsbuilder/</link><pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescopevsbuilder/</guid><description>&lt;h2 id="kotlin-coroutine에서-coroutinescope와-coroutinescope-빌더의-개념적-차이">Kotlin Coroutine에서 CoroutineScope와 coroutineScope 빌더의 개념적 차이
&lt;/h2>&lt;p>Kotlin 코루틴은 구조적 동시성(Structured Concurrency)을 구현하기 위해 다양한 스코프(scope) 기반의 실행 환경을 제공한다. 그중 &lt;code>CoroutineScope(...)&lt;/code> 생성자와 &lt;code>coroutineScope {}&lt;/code> 빌더는 이름이 유사하지만, &lt;strong>역할과 사용 위치, 생명주기 및 제어 방식에 있어 명확히 구분되는 개념&lt;/strong>이다. 본 문서에서는 이 둘의 본질적인 차이와 각각의 실용적 쓰임에 대해 기술한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 자체적인 실행 컨텍스트를 요구하며, 이를 정의하는 단위가 CoroutineScope이다. 코루틴 스코프는 일반적으로 명시적으로 생성하거나, 일시적으로 suspend 함수 내에서 빌더로 선언하여 사용된다. 이 두 방식은 각각 &lt;code>CoroutineScope(...)&lt;/code> 생성자와 &lt;code>coroutineScope {}&lt;/code> 빌더로 구분되며, 코드 구조와 실행 흐름에 결정적인 영향을 미친다.&lt;/p>
&lt;hr>
&lt;h3 id="2-coroutinescope-생성자">2. CoroutineScope(&amp;hellip;) 생성자
&lt;/h3>&lt;p>&lt;code>CoroutineScope(context: CoroutineContext)&lt;/code>는 &lt;strong>클래스나 객체 수준&lt;/strong>에서 코루틴 실행 환경을 명시적으로 구성할 때 사용된다. 생성된 스코프는 별도로 &lt;code>cancel()&lt;/code>하거나 생명주기를 관리해야 하며, 장기 실행되는 컴포넌트(ViewModel, Service 등)에 적합하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 장기 실행되는 비동기 작업
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>외부에서 scope.cancel()을 호출하면 해당 스코프 하위의 모든 코루틴이 취소된다.&lt;/li>
&lt;li>CoroutineScope는 클래스 필드나 전역 컨텍스트로 주입되며, 수동 관리가 필수이다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-coroutinescope---빌더">3. coroutineScope { } 빌더
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 &lt;code>suspend fun&lt;/code> 내부에서 사용 가능한 코루틴 빌더이며, 해당 블록 내에서 생성된 자식 코루틴들이 모두 완료되기 전까지 현재 코루틴을 일시 정지시킨다. 구조적 동시성을 구현하기 위한 핵심 기제로 작동하며, 블록 범위 외부로 생명주기가 확장되지 않는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>(): UserData = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async { fetchA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async { fetchB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserData(a.await(), b.await())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>블록이 종료되면 자식 코루틴은 모두 정리되고 스코프도 자동으로 사라진다.&lt;/li>
&lt;li>coroutineScope 자체를 변수로 저장하거나 외부에서 cancel()하는 것은 불가능하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-비교-표">4. 비교 표
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>CoroutineScope(...)&lt;/code>&lt;/th>
&lt;th>&lt;code>coroutineScope { }&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>타입&lt;/td>
&lt;td>클래스 생성자&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내 빌더&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 위치&lt;/td>
&lt;td>전역, 클래스 필드 등&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생명주기&lt;/td>
&lt;td>외부에서 수동으로 관리 (&lt;code>cancel()&lt;/code>)&lt;/td>
&lt;td>블록 내부에서 자동 관리됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조적 동시성&lt;/td>
&lt;td>보장되지 않음 (설계에 따라 가능)&lt;/td>
&lt;td>기본적으로 보장됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>외부에서 종료 가능 여부&lt;/td>
&lt;td>가능 (&lt;code>cancel()&lt;/code>)&lt;/td>
&lt;td>불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자식 예외 전파 방식&lt;/td>
&lt;td>Job 종류에 따라 다름 (ex. &lt;code>SupervisorJob&lt;/code>)&lt;/td>
&lt;td>자식 실패 시 전체 블록 취소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일반적 사용 용도&lt;/td>
&lt;td>ViewModel, Repository, Service 등 장기 생존 객체&lt;/td>
&lt;td>일시적 작업 조합, suspend 함수 내부 동시 실행 처리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="5-사용-예시-비교">5. 사용 예시 비교
&lt;/h3>&lt;h4 id="51-coroutinescope-예시">5.1 CoroutineScope 예시
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DataFetcher&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">startFetching&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fetchSomething()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">stop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.cancel() &lt;span style="color:#75715e">// 명시적으로 종료
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>장기 실행되는 비동기 작업을 관리하는 데 적합하며, cancel()을 통한 명확한 종료가 가능하다.&lt;/li>
&lt;/ul>
&lt;h4 id="52-coroutinescope-예시">5.2 coroutineScope 예시
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchAll&lt;/span>(): List&amp;lt;Result&amp;gt; = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async { fetchA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async { fetchB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(a.await(), b.await())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>일시적인 데이터 병렬 수집이나 처리 시에 적합하며, 외부 생명주기와 무관하다.&lt;/li>
&lt;/ul>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>&lt;code>CoroutineScope(...)&lt;/code>는 명시적 실행 환경을 구성하고, 생명주기를 외부에서 직접 제어해야 하는 경우에 사용된다. 반면 &lt;code>coroutineScope {}&lt;/code>는 일시적이고 지역적인 suspend 블록으로서, 블록 내부의 자식 코루틴들의 실행을 제어하고, 자동 정리되는 구조적 동시성을 제공한다. 이 둘은 유사한 이름을 가졌으나, 설계 철학과 활용 맥락이 명확히 구분되어야 하며, 적절한 선택이 안정적이고 예측 가능한 코루틴 기반 시스템 설계의 핵심이 된다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 SupervisorJob의 역할과 scopeJob 구조</title><link>https://jaemin-baek.github.io/post/supervisorjob/</link><pubDate>Tue, 25 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/supervisorjob/</guid><description>&lt;h2 id="kotlin-coroutine에서-supervisorjob의-역할과-scopejob-구조">Kotlin Coroutine에서 SupervisorJob의 역할과 &lt;code>scopeJob&lt;/code> 구조
&lt;/h2>&lt;p>Kotlin 코루틴에서는 비동기 작업의 생명주기와 예외 처리를 체계적으로 관리하기 위해 &lt;code>Job&lt;/code> 기반의 구조적 동시성을 제공한다. 본 문서에서는 그 중 &lt;code>SupervisorJob&lt;/code>을 중심으로 하는 &lt;code>scopeJob&lt;/code>의 역할과 필요성, 그리고 일반 &lt;code>Job&lt;/code>과의 차이에 대해 고찰한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 &lt;code>CoroutineScope&lt;/code> 내에서 생성된 자식 코루틴들과 부모 코루틴 간의 관계를 명확히 하여 예측 가능한 동시 실행을 가능하게 한다. 이때 &lt;code>Job&lt;/code>은 각 코루틴의 생명주기를 추적하고, 취소 여부를 상위 또는 하위로 전파하는 핵심 구성요소로 작동한다. Kotlin에서는 &lt;code>Job&lt;/code> 외에도 &lt;code>SupervisorJob&lt;/code>이라는 특별한 형태의 Job을 제공하여, 자식 간의 실패 전파를 제어할 수 있다.&lt;/p>
&lt;hr>
&lt;h3 id="2-구조-예시">2. 구조 예시
&lt;/h3>&lt;p>아래는 &lt;code>SupervisorJob&lt;/code>을 기반으로 한 &lt;code>scopeJob&lt;/code>을 생성하는 전형적인 코드 예시이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scopeJob = SupervisorJob()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(scopeJob + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 scope 내에서 생성되는 모든 자식 코루틴이 SupervisorJob을 공유하도록 구성되며, 하나의 자식이 실패하더라도 다른 자식은 영향을 받지 않고 독립적으로 실행을 계속할 수 있도록 한다.&lt;/p>
&lt;hr>
&lt;h3 id="3-supervisorjob의-동작-원리">3. SupervisorJob의 동작 원리
&lt;/h3>&lt;p>&lt;code>SupervisorJob&lt;/code>은 일반 &lt;code>Job&lt;/code>과 달리, 자식 코루틴이 실패(Exception 발생 등)하더라도 &lt;strong>부모나 다른 자식 코루틴에게 실패를 전파하지 않는다&lt;/strong>. 이를 통해 &lt;strong>고립된 실패 처리&lt;/strong>와 &lt;strong>부분 성공 전략&lt;/strong>을 구현할 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>Job (기본)&lt;/th>
&lt;th>SupervisorJob&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>자식 실패 시&lt;/td>
&lt;td>전체 스코프 취소&lt;/td>
&lt;td>실패한 자식만 취소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>형제 간 전파&lt;/td>
&lt;td>예외 전파됨&lt;/td>
&lt;td>전파되지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 목적&lt;/td>
&lt;td>전체 작업의 일관성 보장&lt;/td>
&lt;td>부분 실패 허용, 독립 실행 구조&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>SupervisorJob&lt;/code>은 &lt;code>supervisorScope {}&lt;/code> 또는 직접 Scope를 구성할 때 명시적으로 사용되며, &lt;code>CoroutineScope(SupervisorJob())&lt;/code> 형태로 자주 활용된다.&lt;/p>
&lt;hr>
&lt;h3 id="4-실용적-사용-맥락">4. 실용적 사용 맥락
&lt;/h3>&lt;ul>
&lt;li>병렬로 다수의 외부 API를 호출할 때&lt;/li>
&lt;li>자식 코루틴 중 하나가 실패하더라도 나머지 결과가 유효한 경우&lt;/li>
&lt;li>백그라운드 데이터 동기화 작업에서 개별 요청 단위의 실패를 분리하고 싶은 경우&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 개별 작업 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 개별 작업 2 (실패해도 다른 작업에는 영향 없음)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 scope 내부에서 수행되는 코루틴들이 독립적인 실행 환경을 갖도록 보장한다.&lt;/p>
&lt;hr>
&lt;h3 id="5-예외-처리와-결합">5. 예외 처리와 결합
&lt;/h3>&lt;p>실제 응용에서는 SupervisorJob과 함께 CoroutineExceptionHandler를 결합하여 보다 견고한 예외 처리를 구현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> exceptionHandler = CoroutineExceptionHandler { _, throwable &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#e6db74">&amp;#34;Unhandled exception: &lt;/span>&lt;span style="color:#e6db74">$throwable&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + exceptionHandler)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 실패한 자식 코루틴의 예외를 처리하면서도 전체 스코프를 안정적으로 유지할 수 있게 한다.&lt;/p>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>SupervisorJob은 Kotlin 코루틴 기반 구조에서 자식 간의 예외 전파를 분리하고, 작업 단위의 독립성과 견고성을 확보하기 위한 중요한 구성요소이다. 일반 Job이 전체 일괄 실패를 선호하는 전략이라면, SupervisorJob은 부분 실패를 수용하며 전체 서비스의 연속성을 유지하는 전략에 적합하다. 이를 통해 복잡한 비동기 시스템에서도 예측 가능한 실행 흐름과 회복 가능한 오류 처리가 가능해진다.&lt;/p>
&lt;hr></description></item><item><title>Kotlin 코루틴의 runBlocking, coroutineScope, supervisorScope 비교</title><link>https://jaemin-baek.github.io/post/coroutinescope/</link><pubDate>Wed, 19 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescope/</guid><description>&lt;h2 id="kotlin-코루틴의-실행-스코프-비교-runblocking-coroutinescope-supervisorscope">Kotlin 코루틴의 실행 스코프 비교: runBlocking, coroutineScope, supervisorScope
&lt;/h2>&lt;p>Kotlin의 코루틴 시스템은 다양한 실행 스코프 제공을 통해 구조적 동시성과 예외 분리를 가능하게 한다. 본 문서에서는 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>의 기능과 목적을 비교하고, 각각의 사용 상황과 실행 흐름 차이에 대해 기술한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 전통적인 스레드 기반 프로그래밍에 비해 더 적은 리소스로 동시성을 지원하며, 이를 위해 다양한 스코프 빌더가 제공된다. 그중 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>는 가장 자주 사용되는 고수준 코루틴 빌더로, 이들은 실행 방식과 예외 처리 구조에 있어 중요한 차이를 갖는다.&lt;/p>
&lt;hr>
&lt;h3 id="2-주요-차이점-요약">2. 주요 차이점 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>runBlocking&lt;/code>&lt;/th>
&lt;th>&lt;code>coroutineScope&lt;/code>&lt;/th>
&lt;th>&lt;code>supervisorScope&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>차단 여부&lt;/td>
&lt;td>호출한 &lt;strong>스레드를 차단&lt;/strong>&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 위치&lt;/td>
&lt;td>&lt;code>main()&lt;/code> 함수, 테스트&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자식 실패 전파&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>실패해도 다른 자식은 계속 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생성 스코프&lt;/td>
&lt;td>새 &lt;code>CoroutineScope&lt;/code> 생성&lt;/td>
&lt;td>상위 스코프 상속&lt;/td>
&lt;td>&lt;code>SupervisorJob&lt;/code> 기반 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 목적&lt;/td>
&lt;td>일반 코드와 코루틴 연결&lt;/td>
&lt;td>구조적 동시성&lt;/td>
&lt;td>예외 고립 및 분리 실행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="3-runblocking">3. runBlocking
&lt;/h3>&lt;p>&lt;code>runBlocking&lt;/code>은 코루틴 진입점을 제공하는 함수로, 일반적인 블로킹 코드(main 함수 등)에서 &lt;code>suspend&lt;/code> 함수를 사용할 수 있도록 한다. 내부적으로 현재 스레드를 차단하며, 코루틴이 완료될 때까지 대기한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>호출한 스레드를 직접 차단하며, UI 스레드에서는 사용을 지양해야 한다.&lt;/li>
&lt;li>&lt;code>CoroutineScope&lt;/code>를 생성하여 내부에서 &lt;code>launch&lt;/code>, &lt;code>async&lt;/code> 등을 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-coroutinescope">4. coroutineScope
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 현재 컨텍스트를 상속하는 &lt;code>CoroutineScope&lt;/code>를 생성하며, 내부의 모든 자식 코루틴이 종료될 때까지 &lt;code>suspend&lt;/code> 상태로 대기한다. 이는 구조적 동시성을 구현하는 핵심 도구로 사용된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child 1 done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child 2 done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;All children completed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>자식 중 하나라도 실패하면 전체 스코프가 취소된다.&lt;/li>
&lt;li>일반적으로 suspend 함수 내에서 사용된다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="5-supervisorscope">5. supervisorScope
&lt;/h3>&lt;p>supervisorScope는 자식 코루틴 간 실패 전파를 막고, 하나의 실패가 다른 작업에 영향을 미치지 않도록 하는 예외 격리 기능을 제공한다. 내부적으로 SupervisorJob을 사용하여 고립된 실행 환경을 형성한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> supervisorScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Child failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Other child still runs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>하나의 자식이 예외를 발생시켜도 다른 자식은 계속 실행된다.&lt;/li>
&lt;li>실시간 처리나 부분 실패를 허용하는 작업에 적합하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>코루틴의 실행 컨텍스트 선택은 코드의 동시성 구조와 예외 처리 전략에 직접적인 영향을 미친다. runBlocking은 동기-비동기 경계를 연결하는 데 유용하며, coroutineScope는 구조적 동시성을 제공하고, supervisorScope는 자식 코루틴의 독립 실행을 보장한다. 각 스코프의 특성을 이해하고 상황에 맞게 사용하는 것이 안전하고 예측 가능한 비동기 프로그래밍을 구현하는 데 핵심이 된다.&lt;/p>
&lt;hr></description></item></channel></rss>