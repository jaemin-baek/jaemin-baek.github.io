<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Exception on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/exception/</link><description>Recent content in Exception on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/exception/index.xml" rel="self" type="application/rss+xml"/><item><title>[v.0.0] Java에서 Exception과 Error의 차이와 명명 이유</title><link>https://jaemin-baek.github.io/post/java_exception_vs_error/</link><pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/java_exception_vs_error/</guid><description>&lt;h1 id="java에서-exception과-error의-차이와-명명-이유">Java에서 Exception과 Error의 차이와 명명 이유
&lt;/h1>&lt;p>Java에서 &lt;code>Exception&lt;/code>이라는 용어를 사용한 이유는 단순한 문법의 선택이 아니라 &lt;strong>철학적으로 오류를 &amp;ldquo;예외적인 상황(exceptional situation)&amp;ldquo;으로 분류하려는 시도&lt;/strong>에 뿌리를 두고 있습니다. 이 개념은 C++ 등 객체지향 언어에서 비롯되었고, Java는 이를 명시적 언어 설계 요소로 적극 도입했습니다.&lt;/p>
&lt;hr>
&lt;h2 id="-java가-exception이라는-용어를-채택한-배경">🔍 Java가 &lt;code>Exception&lt;/code>이라는 용어를 채택한 배경
&lt;/h2>&lt;h3 id="1-예외exception와-오류error의-구분">1. 예외(Exception)와 오류(Error)의 구분
&lt;/h3>&lt;p>Java에서는 예외(Exception)와 오류(Error)를 &lt;strong>논리적으로 명확히 구분&lt;/strong>합니다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>Java 클래스&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;strong>Exception&lt;/strong>&lt;/td>
&lt;td>애플리케이션에서 예측 가능한 문제, 복구 가능&lt;/td>
&lt;td>&lt;code>IOException&lt;/code>, &lt;code>SQLException&lt;/code>, &lt;code>NullPointerException&lt;/code> 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;strong>Error&lt;/strong>&lt;/td>
&lt;td>시스템 수준의 복구 불가능한 심각한 문제&lt;/td>
&lt;td>&lt;code>OutOfMemoryError&lt;/code>, &lt;code>StackOverflowError&lt;/code> 등&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="2-예외는-비정상적이지만-제어-가능한-흐름">2. 예외는 비정상적이지만 제어 가능한 흐름
&lt;/h3>&lt;ul>
&lt;li>예외(Exception)는 &lt;strong>일반적이지 않은 제어 흐름&lt;/strong>을 나타냅니다.&lt;/li>
&lt;li>Java는 &lt;code>try-catch-finally&lt;/code>를 통해 예외 발생 시에도 &lt;strong>프로그램 흐름을 유지하면서 처리&lt;/strong>할 수 있도록 지원합니다.&lt;/li>
&lt;li>이는 코드 실행 중 조건이 깨졌을 때의 대응 절차를 정의할 수 있게 합니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-exception-vs-error-철학">3. Exception vs. Error: 철학
&lt;/h3>&lt;ul>
&lt;li>&lt;code>Exception&lt;/code>: &lt;strong>프로그래머가 처리할 수 있는 예외 상황&lt;/strong>&lt;/li>
&lt;li>&lt;code>Error&lt;/code>: &lt;strong>JVM 또는 시스템 레벨의 문제로, 처리하지 않기를 기대&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="-용어-비교-java-vs-swift-vs-kotlin">📚 용어 비교 (Java vs Swift vs Kotlin)
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>언어&lt;/th>
&lt;th>주요 용어&lt;/th>
&lt;th>처리 방식&lt;/th>
&lt;th>특징&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Java&lt;/td>
&lt;td>&lt;code>Exception&lt;/code>, &lt;code>Error&lt;/code>&lt;/td>
&lt;td>&lt;code>try-catch&lt;/code>&lt;/td>
&lt;td>체크 예외/언체크 예외 구분, 명확한 계층 구조&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Swift&lt;/td>
&lt;td>&lt;code>Error&lt;/code> (Protocol)&lt;/td>
&lt;td>&lt;code>try-catch&lt;/code>, &lt;code>throws&lt;/code>&lt;/td>
&lt;td>대부분 &lt;code>enum&lt;/code>, 구조체 기반, 복구 중심&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin&lt;/td>
&lt;td>&lt;code>Exception&lt;/code>&lt;/td>
&lt;td>&lt;code>try-catch&lt;/code>&lt;/td>
&lt;td>Java 계승, 체크 예외 없음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="-결론">✨ 결론
&lt;/h2>&lt;p>Java에서 &lt;code>Exception&lt;/code>이라는 용어는 오류를 &lt;strong>논리적으로 설명 가능한 &amp;lsquo;예외적 사건&amp;rsquo;&lt;/strong> 으로 정의하며, 개발자가 이를 &lt;strong>정제된 방식으로 처리&lt;/strong>하도록 유도하기 위해 선택된 개념입니다.&lt;br>
반면 &lt;code>Error&lt;/code>는 시스템적 결함을 나타내며 &lt;strong>정상적인 흐름에서의 개입을 금지&lt;/strong>하는 철학을 따릅니다.&lt;/p></description></item><item><title>[v.0.0] 예외(Exception)를 반대하는 개발자들의 주장과 대안</title><link>https://jaemin-baek.github.io/post/exception-opposition-summary/</link><pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/exception-opposition-summary/</guid><description>&lt;h1 id="예외exception를-반대하는-개발자들의-주장과-대안">예외(Exception)를 반대하는 개발자들의 주장과 대안
&lt;/h1>&lt;p>프로그래밍에서 Exception(예외)은 매우 흔한 오류 처리 방식이지만, 이를 &lt;strong>반대하거나 제한적으로 사용해야 한다는 주장도 꾸준히 존재&lt;/strong>합니다. 이 문서에서는 그 주요 논거들과 대안을 정리합니다.&lt;/p>
&lt;hr>
&lt;h2 id="예외-사용을-반대하는-주요-주장">예외 사용을 반대하는 주요 주장
&lt;/h2>&lt;h3 id="1-제어-흐름을-숨긴다-control-flow-hiding">1. 제어 흐름을 숨긴다 (Control Flow Hiding)
&lt;/h3>&lt;ul>
&lt;li>예외는 함수 시그니처에 드러나지 않음&lt;/li>
&lt;li>호출자가 어떤 예외가 발생할지 예측하기 어려움&lt;/li>
&lt;li>코드 흐름이 불명확해짐 → 유지보수 어려움&lt;/li>
&lt;/ul>
&lt;h3 id="2-함수형-프로그래밍에서는-예외-대신-값을-사용">2. 함수형 프로그래밍에서는 예외 대신 값을 사용
&lt;/h3>&lt;ul>
&lt;li>&lt;code>Result&lt;/code>, &lt;code>Either&lt;/code>, &lt;code>Try&lt;/code> 등으로 오류를 모델링&lt;/li>
&lt;li>오류가 &lt;strong>타입 시스템에 명시&lt;/strong>되어 컴파일 타임에 예측 가능&lt;/li>
&lt;li>안정적인 체이닝과 패턴 매칭이 가능&lt;/li>
&lt;/ul>
&lt;h3 id="3-성능-비용-존재">3. 성능 비용 존재
&lt;/h3>&lt;ul>
&lt;li>스택 추적 생성, GC 부하, 최적화 방해 요소 존재&lt;/li>
&lt;li>성능 민감한 시스템에서는 오히려 성능 저하 요인&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="주요-인물-및-커뮤니티의-입장">주요 인물 및 커뮤니티의 입장
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>인물/집단&lt;/th>
&lt;th>입장 요약&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Rob Pike (Go 설계자)&lt;/td>
&lt;td>Go는 &lt;code>error&lt;/code>를 반환값으로 처리하고 예외를 피함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Haskell 커뮤니티&lt;/td>
&lt;td>오류는 타입으로 표현하고 예외는 피함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin 함수형 지향&lt;/td>
&lt;td>&lt;code>Result&amp;lt;T&amp;gt;&lt;/code>와 &lt;code>sealed class&lt;/code>로 오류 모델링 선호&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>C++ 일부 진영&lt;/td>
&lt;td>예외 대신 명시적 오류 코드 사용 선호&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="예외를-대체하는-방식">예외를 대체하는 방식
&lt;/h2>&lt;ul>
&lt;li>&lt;code>sealed class&lt;/code> + &lt;code>when&lt;/code> 구문&lt;/li>
&lt;li>&lt;code>Result&amp;lt;T&amp;gt;&lt;/code>, &lt;code>Either&amp;lt;L, R&amp;gt;&lt;/code> (Arrow 등)&lt;/li>
&lt;li>&lt;code>Try&amp;lt;T&amp;gt;&lt;/code>&lt;/li>
&lt;li>명시적 error code (&lt;code>Boolean&lt;/code>, &lt;code>null&lt;/code> 등)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="실무에서의-현실적-판단">실무에서의 현실적 판단
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>관점&lt;/th>
&lt;th>예외 사용&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>명령형 언어 (Java 등)&lt;/td>
&lt;td>널리 사용됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>함수형 패러다임&lt;/td>
&lt;td>예외 대신 오류를 값으로 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>시스템 프로그래밍&lt;/td>
&lt;td>성능 및 안정성 위해 예외 최소화&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실무&lt;/td>
&lt;td>&lt;strong>예외 + Result 혼합 전략&lt;/strong> 자주 사용됨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="결론">결론
&lt;/h2>&lt;p>Exception은 강력하고 편리하지만, &lt;strong>코드 가독성, 예측 가능성, 성능 측면에서 단점&lt;/strong>도 존재합니다.&lt;br>
따라서, &lt;strong>도메인 요구사항과 설계 철학에 따라 예외와 값 기반 오류 처리 방식을 혼합하여 사용하는 전략이 가장 실용적&lt;/strong>입니다.&lt;/p></description></item><item><title>[v.0.0] Kotlin 코루틴에서 에러 처리 제대로 이해하기</title><link>https://jaemin-baek.github.io/post/coroutineerror/</link><pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutineerror/</guid><description>&lt;h2 id="kotlin-코루틴에서-에러-처리-제대로-이해하기">Kotlin 코루틴에서 에러 처리 제대로 이해하기
&lt;/h2>&lt;p>코틀린 코루틴은 비동기 코드의 예외 처리 방식을 명확하게 구조화하고 있다.&lt;br>
단순한 &lt;code>try-catch&lt;/code>를 넘어서, &lt;code>Job&lt;/code>, &lt;code>SupervisorJob&lt;/code>, &lt;code>CoroutineExceptionHandler&lt;/code> 등 다양한 메커니즘이 존재하며,&lt;br>
이들은 &lt;strong>구조적 동시성(Structured Concurrency)&lt;/strong> 원칙 하에 작동한다.&lt;br>
이 글에서는 Kotlin 코루틴의 예외 처리 구조를 단계적으로 설명하고, 실전 예제를 통해 이해를 돕고자 한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-코루틴의-예외-처리-기본-try-catch">1. 코루틴의 예외 처리 기본: &lt;code>try-catch&lt;/code>
&lt;/h3>&lt;p>가장 단순한 예외 처리는 &lt;code>try-catch&lt;/code> 블록을 사용하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> riskySuspendFunction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;에러 발생: &lt;/span>&lt;span style="color:#e6db74">$e&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>위 코드는 launch 내부에서 발생한 예외를 catch로 처리한다.&lt;/li>
&lt;li>하지만 모든 상황에서 try-catch가 동작하는 것은 아니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-launch-vs-async의-예외-처리-차이">2. launch vs async의 예외 처리 차이
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>코루틴 빌더&lt;/th>
&lt;th>예외 발생 시 처리 방식&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>launch&lt;/code>&lt;/td>
&lt;td>예외가 즉시 전파됨 → 부모 Job에 전달되거나 &lt;code>CoroutineExceptionHandler&lt;/code>에서 처리됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>async&lt;/code>&lt;/td>
&lt;td>예외가 &lt;code>Deferred&lt;/code>에 저장됨 → &lt;code>await()&lt;/code> 호출 시 예외가 발생함&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default).launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;launch 내부 예외&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 즉시 전파됨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> deferred = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default).async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;async 내부 예외&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 바로 안 터짐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deferred.await() &lt;span style="color:#75715e">// 여기서 예외가 발생함
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="3-coroutineexceptionhandler-사용">3. CoroutineExceptionHandler 사용
&lt;/h3>&lt;p>코루틴 전체에 적용되는 전역 예외 처리자 역할을 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> handler = CoroutineExceptionHandler { _, exception &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;핸들러에서 처리된 예외: &lt;/span>&lt;span style="color:#e6db74">$exception&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + handler)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;예외 발생!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>CoroutineExceptionHandler는 **launch나 actor와 같은 &amp;lsquo;최상위 코루틴&amp;rsquo;**에서만 작동&lt;/li>
&lt;li>async에는 작동하지 않음 → 예외는 반드시 await()로 수동 처리해야 함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-부모-자식-관계와-예외-전파">4. 부모-자식 관계와 예외 전파
&lt;/h3>&lt;p>일반 Job의 경우:&lt;/p>
&lt;ul>
&lt;li>자식 코루틴이 예외를 던지면 → 부모 Job도 취소됨&lt;/li>
&lt;li>형제 코루틴도 모두 함께 취소됨&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> parent = CoroutineScope(Job())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;자식 예외&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;이 코루틴은 취소됨&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SupervisorJob을 사용할 경우:&lt;/p>
&lt;ul>
&lt;li>자식이 예외를 던져도 부모나 다른 형제에 영향 없음&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;에러 발생&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;이 코루틴은 살아있음&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 출력됨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="5-실전-패턴-안전한-동시-처리">5. 실전 패턴: 안전한 동시 처리
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">safeParallelExecution&lt;/span>(): Result = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchA() } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) { emptyList() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchB() } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) { emptyList() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Result(a.await(), b.await())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>각 작업을 별도 async로 실행&lt;/li>
&lt;li>개별 try-catch로 안전하게 감싸서 전체 실패를 막는다&lt;/li>
&lt;li>coroutineScope는 모든 async가 완료될 때까지 대기&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="6-정리-요약">6. 정리 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>try-catch&lt;/code>&lt;/td>
&lt;td>&lt;code>launch&lt;/code> 내부에서는 직접 사용 가능. &lt;code>async&lt;/code>는 &lt;code>await()&lt;/code> 호출 시 예외 발생하므로 그 시점에서 catch 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CoroutineExceptionHandler&lt;/code>&lt;/td>
&lt;td>&lt;code>launch&lt;/code>, &lt;code>actor&lt;/code> 등 &lt;strong>최상위 코루틴에서 발생한 예외만&lt;/strong> 처리. &lt;code>async&lt;/code>에서는 동작하지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>launch&lt;/code>&lt;/td>
&lt;td>예외가 발생하면 즉시 상위로 전파되며, 부모 Job이나 예외 핸들러가 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>async&lt;/code>&lt;/td>
&lt;td>예외가 &lt;code>Deferred&lt;/code> 내부에 저장되며, &lt;code>await()&lt;/code> 호출 시 예외가 발생&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 코루틴 중 하나가 실패해도, 다른 자식 코루틴에 영향을 주지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조적 동시성 (&lt;code>coroutineScope&lt;/code>)&lt;/td>
&lt;td>모든 자식 코루틴이 성공적으로 완료되어야 블록이 종료됨. 하나라도 실패하면 전체 블록이 예외로 종료됨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>코루틴의 예외 처리는 단순히 try-catch로 끝나지 않는다.
코루틴 빌더의 종류(launch vs async), Job의 구조(Job vs SupervisorJob), 전역 핸들러의 유무에 따라
예외의 전파 경로와 처리 방법이 달라진다.&lt;/p>
&lt;p>비동기 프로그램의 안정성과 복원력을 높이기 위해서는,
각 코루틴의 실행 범위와 책임, 예외 처리 방식을 명확히 설계해야 한다.&lt;/p>
&lt;h3 id="참고-예외-발생-흐름도">참고: 예외 발생 흐름도
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception() &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> 부모 Job &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> CoroutineExceptionHandler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception() &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> 저장됨 &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> await() 호출 시 &lt;span style="color:#66d9ef">throw&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>