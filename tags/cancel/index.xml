<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cancel on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/cancel/</link><description>Recent content in Cancel on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 03 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/cancel/index.xml" rel="self" type="application/rss+xml"/><item><title>[v.0.0] CoroutineScope.cancel()과 Job.cancel()은 같은가?</title><link>https://jaemin-baek.github.io/post/coroutinejobcancel/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinejobcancel/</guid><description>&lt;h2 id="coroutinescopecancel과-jobcancel은-같은가">CoroutineScope.cancel()과 Job.cancel()은 같은가?
&lt;/h2>&lt;p>Kotlin 코루틴을 사용하다 보면 &lt;code>CoroutineScope.cancel()&lt;/code>과 &lt;code>Job.cancel()&lt;/code>을 모두 보게 된다. 이 둘은 이름은 비슷하지만, 실제로 동일한 기능일까? 둘의 차이는 어디에 있을까? 본 포스트에서는 이 질문을 중심으로, Kotlin 표준과 &lt;code>kotlinx.coroutines&lt;/code>의 차이를 기반으로 정확한 동작 방식을 설명한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-job이란">1. Job이란?
&lt;/h3>&lt;p>&lt;code>Job&lt;/code>은 Kotlin 코루틴의 생명주기와 상태를 관리하는 객체다.&lt;br>
각 코루틴에는 하나의 Job이 할당되며, 이를 통해 다음을 제어할 수 있다:&lt;/p>
&lt;ul>
&lt;li>코루틴의 실행 상태 추적 (활성, 취소, 완료)&lt;/li>
&lt;li>&lt;code>cancel()&lt;/code>을 통한 중단 신호 전달&lt;/li>
&lt;li>&lt;code>join()&lt;/code>을 통한 종료 대기&lt;/li>
&lt;li>부모-자식 관계 관리&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-coroutinescope는-job을-포함한다">2. CoroutineScope는 Job을 포함한다
&lt;/h3>&lt;p>&lt;code>CoroutineScope&lt;/code>는 코루틴을 실행할 수 있는 컨텍스트이며, 내부적으로 &lt;code>CoroutineContext&lt;/code>를 통해 &lt;strong>Job을 반드시 포함&lt;/strong>한다. 예를 들어 다음과 같은 코드가 있을 때:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실제로는 다음과 같은 컨텍스트가 구성된다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, Job은 자동 생성되며 scope 안에 숨겨져 있다. 하지만 이 Job에 직접 접근할 수는 없다.&lt;/p>
&lt;hr>
&lt;h3 id="3-scopecancel은-왜-되는가">3. scope.cancel()은 왜 되는가?
&lt;/h3>&lt;p>Kotlin 표준의 CoroutineScope 인터페이스는 cancel() 함수를 직접 정의하지 않는다.
하지만 kotlinx.coroutines 라이브러리는 다음과 같은 확장 함수를 제공한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.cancel(cause: CancellationException? = &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineContext[Job]&lt;span style="color:#f92672">?.&lt;/span>cancel(cause)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, CoroutineScope.cancel()은 실제로는 자신의 CoroutineContext에서 Job을 꺼내고, 그 Job의 cancel()을 호출하는 확장 함수일 뿐이다.&lt;/p>
&lt;p>따라서 다음과 같은 코드는 정상적으로 작동한다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.cancel() &lt;span style="color:#75715e">// kotlinx.coroutines 확장 함수로 동작
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="4-job을-명시적으로-만들면-어떤-이점이-있나">4. Job을 명시적으로 만들면 어떤 이점이 있나?
&lt;/h3>&lt;p>Job을 직접 변수로 만들어 Scope에 넣으면, Scope 밖에서도 Job을 통해 상태를 제어할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = Job()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(job + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>job.cancel() &lt;span style="color:#75715e">// scope의 모든 코루틴 취소 가능
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>CoroutineScope.cancel()은 Kotlin 표준의 기능이 아니라,
kotlinx.coroutines에서 제공하는 확장 함수이다.
내부적으로는 Job.cancel()을 위임 호출하며, 같은 대상이라면 동작 결과는 동일하다.&lt;/p></description></item></channel></rss>