<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RunBlocking on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/tags/runblocking/</link><description>Recent content in RunBlocking on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Mon, 19 May 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/tags/runblocking/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin 코루틴의 runBlocking, coroutineScope, supervisorScope 비교</title><link>https://jaemin-baek.github.io/post/coroutinescope/</link><pubDate>Mon, 19 May 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescope/</guid><description>&lt;h2 id="kotlin-코루틴의-실행-스코프-비교-runblocking-coroutinescope-supervisorscope">Kotlin 코루틴의 실행 스코프 비교: runBlocking, coroutineScope, supervisorScope
&lt;/h2>&lt;p>Kotlin의 코루틴 시스템은 다양한 실행 스코프 제공을 통해 구조적 동시성과 예외 분리를 가능하게 한다. 본 문서에서는 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>의 기능과 목적을 비교하고, 각각의 사용 상황과 실행 흐름 차이에 대해 기술한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 전통적인 스레드 기반 프로그래밍에 비해 더 적은 리소스로 동시성을 지원하며, 이를 위해 다양한 스코프 빌더가 제공된다. 그중 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>는 가장 자주 사용되는 고수준 코루틴 빌더로, 이들은 실행 방식과 예외 처리 구조에 있어 중요한 차이를 갖는다.&lt;/p>
&lt;hr>
&lt;h3 id="2-주요-차이점-요약">2. 주요 차이점 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>runBlocking&lt;/code>&lt;/th>
&lt;th>&lt;code>coroutineScope&lt;/code>&lt;/th>
&lt;th>&lt;code>supervisorScope&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>차단 여부&lt;/td>
&lt;td>호출한 &lt;strong>스레드를 차단&lt;/strong>&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 위치&lt;/td>
&lt;td>&lt;code>main()&lt;/code> 함수, 테스트&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자식 실패 전파&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>실패해도 다른 자식은 계속 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생성 스코프&lt;/td>
&lt;td>새 &lt;code>CoroutineScope&lt;/code> 생성&lt;/td>
&lt;td>상위 스코프 상속&lt;/td>
&lt;td>&lt;code>SupervisorJob&lt;/code> 기반 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 목적&lt;/td>
&lt;td>일반 코드와 코루틴 연결&lt;/td>
&lt;td>구조적 동시성&lt;/td>
&lt;td>예외 고립 및 분리 실행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="3-runblocking">3. runBlocking
&lt;/h3>&lt;p>&lt;code>runBlocking&lt;/code>은 코루틴 진입점을 제공하는 함수로, 일반적인 블로킹 코드(main 함수 등)에서 &lt;code>suspend&lt;/code> 함수를 사용할 수 있도록 한다. 내부적으로 현재 스레드를 차단하며, 코루틴이 완료될 때까지 대기한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item></channel></rss>