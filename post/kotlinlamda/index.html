<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='Kotlin 리시버 람다(Receiver Lambda) 정리 Kotlin에서는 람다 표현식을 한 단계 더 확장하여, 리시버(수신자)를 가지는 람다를 정의할 수 있습니다. 이것을 리시버 람다(Receiver Lambda) 또는 확장 람다(Extension Lambda) 라고 하며, Kotlin DSL, 코루틴, 빌더 패턴 등에 자주 사용됩니다.\n기본 문법 ReceiverType.() -> ReturnType ReceiverType: 리시버(수신자)의 타입 this는 리시버를 가리킴 리시버의 멤버에 직접 접근 가능 (this. 생략 가능) 예제: String.() -> Unit val printLength: String.() -> Unit = { println("[리시버] 길이 = ${this.length}") } "Hello".printLength() // 출력: [리시버] 길이 = 5 위에서 this는 "Hello" 문자열 리시버 타입은 String 일반 람다 vs 리시버 람다 형태 설명 () -> Unit 일반 람다. 외부에서 전달받는 값만 사용 String.() -> Unit String을 리시버로 사용. 내부에서 this.length 등 사용 가능 실전 예시 1: apply {} data class User(var name: String, var age: Int) val user = User("Tom", 30).apply { name = "Jerry" // this.name 으로도 가능 age = 25 } apply는 T.apply(block: T.() -> Unit)으로 선언되어 있음 내부에서 this는 User 실전 예시 2: 코루틴 runBlocking {} fun <T> runBlocking(block: suspend CoroutineScope.() -> T): T block은 CoroutineScope를 리시버로 갖는 suspend 람다 내부에서 launch, async 등을 this. 없이 사용 가능 runBlocking { launch { println("Hi from coroutine") } } 리시버 람다의 장점 장점 설명 DSL 작성에 유리 this 생략 가능. 직관적인 문법 제공 컨텍스트 스코프 제공 내부에서 특정 타입의 기능을 자연스럽게 활용 가능 Kotlin 특유의 선언형 스타일 표현 가능 apply, with, run, build.gradle.kts 등에서 사용됨 요약 정리 Receiver.() -> T는 리시버를 갖는 람다 타입 내부에서 this는 리시버 객체를 가리킴 apply, runBlocking, withContext 등에서 사용됨 리시버 람다는 Kotlin DSL, 구조화된 코루틴, 빌더 패턴 등을 가능하게 하는 핵심적인 언어 기능입니다. Kotlin의 선언형 프로그래밍 스타일을 이해하려면 리시버 람다의 개념을 정확히 이해하는 것이 매우 중요합니다.\n'><title>[v.0.0] Kotlin Receiver Lambda</title><link rel=canonical href=https://jaemin-baek.github.io/post/kotlinlamda/><link rel=stylesheet href=/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css><meta property='og:title' content="[v.0.0] Kotlin Receiver Lambda"><meta property='og:description' content='Kotlin 리시버 람다(Receiver Lambda) 정리 Kotlin에서는 람다 표현식을 한 단계 더 확장하여, 리시버(수신자)를 가지는 람다를 정의할 수 있습니다. 이것을 리시버 람다(Receiver Lambda) 또는 확장 람다(Extension Lambda) 라고 하며, Kotlin DSL, 코루틴, 빌더 패턴 등에 자주 사용됩니다.\n기본 문법 ReceiverType.() -> ReturnType ReceiverType: 리시버(수신자)의 타입 this는 리시버를 가리킴 리시버의 멤버에 직접 접근 가능 (this. 생략 가능) 예제: String.() -> Unit val printLength: String.() -> Unit = { println("[리시버] 길이 = ${this.length}") } "Hello".printLength() // 출력: [리시버] 길이 = 5 위에서 this는 "Hello" 문자열 리시버 타입은 String 일반 람다 vs 리시버 람다 형태 설명 () -> Unit 일반 람다. 외부에서 전달받는 값만 사용 String.() -> Unit String을 리시버로 사용. 내부에서 this.length 등 사용 가능 실전 예시 1: apply {} data class User(var name: String, var age: Int) val user = User("Tom", 30).apply { name = "Jerry" // this.name 으로도 가능 age = 25 } apply는 T.apply(block: T.() -> Unit)으로 선언되어 있음 내부에서 this는 User 실전 예시 2: 코루틴 runBlocking {} fun <T> runBlocking(block: suspend CoroutineScope.() -> T): T block은 CoroutineScope를 리시버로 갖는 suspend 람다 내부에서 launch, async 등을 this. 없이 사용 가능 runBlocking { launch { println("Hi from coroutine") } } 리시버 람다의 장점 장점 설명 DSL 작성에 유리 this 생략 가능. 직관적인 문법 제공 컨텍스트 스코프 제공 내부에서 특정 타입의 기능을 자연스럽게 활용 가능 Kotlin 특유의 선언형 스타일 표현 가능 apply, with, run, build.gradle.kts 등에서 사용됨 요약 정리 Receiver.() -> T는 리시버를 갖는 람다 타입 내부에서 this는 리시버 객체를 가리킴 apply, runBlocking, withContext 등에서 사용됨 리시버 람다는 Kotlin DSL, 구조화된 코루틴, 빌더 패턴 등을 가능하게 하는 핵심적인 언어 기능입니다. Kotlin의 선언형 프로그래밍 스타일을 이해하려면 리시버 람다의 개념을 정확히 이해하는 것이 매우 중요합니다.\n'><meta property='og:url' content='https://jaemin-baek.github.io/post/kotlinlamda/'><meta property='og:site_name' content='리부트 기술 블로그v2'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='Kotlin'><meta property='article:published_time' content='2025-03-11T00:00:00+00:00'><meta property='article:modified_time' content='2025-03-11T00:00:00+00:00'><meta name=twitter:title content="[v.0.0] Kotlin Receiver Lambda"><meta name=twitter:description content='Kotlin 리시버 람다(Receiver Lambda) 정리 Kotlin에서는 람다 표현식을 한 단계 더 확장하여, 리시버(수신자)를 가지는 람다를 정의할 수 있습니다. 이것을 리시버 람다(Receiver Lambda) 또는 확장 람다(Extension Lambda) 라고 하며, Kotlin DSL, 코루틴, 빌더 패턴 등에 자주 사용됩니다.\n기본 문법 ReceiverType.() -> ReturnType ReceiverType: 리시버(수신자)의 타입 this는 리시버를 가리킴 리시버의 멤버에 직접 접근 가능 (this. 생략 가능) 예제: String.() -> Unit val printLength: String.() -> Unit = { println("[리시버] 길이 = ${this.length}") } "Hello".printLength() // 출력: [리시버] 길이 = 5 위에서 this는 "Hello" 문자열 리시버 타입은 String 일반 람다 vs 리시버 람다 형태 설명 () -> Unit 일반 람다. 외부에서 전달받는 값만 사용 String.() -> Unit String을 리시버로 사용. 내부에서 this.length 등 사용 가능 실전 예시 1: apply {} data class User(var name: String, var age: Int) val user = User("Tom", 30).apply { name = "Jerry" // this.name 으로도 가능 age = 25 } apply는 T.apply(block: T.() -> Unit)으로 선언되어 있음 내부에서 this는 User 실전 예시 2: 코루틴 runBlocking {} fun <T> runBlocking(block: suspend CoroutineScope.() -> T): T block은 CoroutineScope를 리시버로 갖는 suspend 람다 내부에서 launch, async 등을 this. 없이 사용 가능 runBlocking { launch { println("Hi from coroutine") } } 리시버 람다의 장점 장점 설명 DSL 작성에 유리 this 생략 가능. 직관적인 문법 제공 컨텍스트 스코프 제공 내부에서 특정 타입의 기능을 자연스럽게 활용 가능 Kotlin 특유의 선언형 스타일 표현 가능 apply, with, run, build.gradle.kts 등에서 사용됨 요약 정리 Receiver.() -> T는 리시버를 갖는 람다 타입 내부에서 this는 리시버 객체를 가리킴 apply, runBlocking, withContext 등에서 사용됨 리시버 람다는 Kotlin DSL, 구조화된 코루틴, 빌더 패턴 등을 가능하게 하는 핵심적인 언어 기능입니다. Kotlin의 선언형 프로그래밍 스타일을 이해하려면 리시버 람다의 개념을 정확히 이해하는 것이 매우 중요합니다.\n'></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/profile_hu_99a977ddffbecdab.png width=300 height=275 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>리부트 기술 블로그v2</a></h1><h2 class=site-description>@WEMADE</h2></div></header><ol class=menu-social><li><a href=https://github.com/jaemin-baek target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href><span></span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/kotlin/>Kotlin</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/kotlinlamda/>[v.0.0] Kotlin Receiver Lambda</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 11, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><h1 id=kotlin-리시버-람다receiver-lambda-정리>Kotlin 리시버 람다(Receiver Lambda) 정리</h1><p>Kotlin에서는 람다 표현식을 한 단계 더 확장하여, <strong>리시버(수신자)를 가지는 람다</strong>를 정의할 수 있습니다. 이것을 <strong>리시버 람다(Receiver Lambda)</strong> 또는 <strong>확장 람다(Extension Lambda)</strong> 라고 하며, Kotlin DSL, 코루틴, 빌더 패턴 등에 자주 사용됩니다.</p><hr><h2 id=기본-문법>기본 문법</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#a6e22e>ReceiverType</span>.() <span style=color:#f92672>-&gt;</span> ReturnType
</span></span></code></pre></div><ul><li><code>ReceiverType</code>: 리시버(수신자)의 타입</li><li><code>this</code>는 리시버를 가리킴</li><li>리시버의 멤버에 직접 접근 가능 (<code>this.</code> 생략 가능)</li></ul><hr><h2 id=예제-string---unit>예제: String.() -> Unit</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>val</span> printLength: <span style=color:#a6e22e>String</span>.() <span style=color:#f92672>-&gt;</span> Unit = {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;[리시버] 길이 = </span><span style=color:#e6db74>${this.length}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#e6db74>&#34;Hello&#34;</span>.printLength() <span style=color:#75715e>// 출력: [리시버] 길이 = 5
</span></span></span></code></pre></div><ul><li>위에서 <code>this</code>는 <code>"Hello"</code> 문자열</li><li>리시버 타입은 <code>String</code></li></ul><hr><h2 id=일반-람다-vs-리시버-람다>일반 람다 vs 리시버 람다</h2><div class=table-wrapper><table><thead><tr><th>형태</th><th>설명</th></tr></thead><tbody><tr><td><code>() -> Unit</code></td><td>일반 람다. 외부에서 전달받는 값만 사용</td></tr><tr><td><code>String.() -> Unit</code></td><td><code>String</code>을 리시버로 사용. 내부에서 <code>this.length</code> 등 사용 가능</td></tr></tbody></table></div><hr><h2 id=실전-예시-1-apply->실전 예시 1: <code>apply {}</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>User</span>(<span style=color:#66d9ef>var</span> name: String, <span style=color:#66d9ef>var</span> age: Int)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> user = User(<span style=color:#e6db74>&#34;Tom&#34;</span>, <span style=color:#ae81ff>30</span>).apply {
</span></span><span style=display:flex><span>    name = <span style=color:#e6db74>&#34;Jerry&#34;</span> <span style=color:#75715e>// this.name 으로도 가능
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    age = <span style=color:#ae81ff>25</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul><li><code>apply</code>는 <code>T.apply(block: T.() -> Unit)</code>으로 선언되어 있음</li><li>내부에서 <code>this</code>는 <code>User</code></li></ul><hr><h2 id=실전-예시-2-코루틴-runblocking->실전 예시 2: 코루틴 <code>runBlocking {}</code></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> &lt;<span style=color:#a6e22e>T</span>&gt; <span style=color:#a6e22e>runBlocking</span>(block: <span style=color:#66d9ef>suspend</span> <span style=color:#a6e22e>CoroutineScope</span>.() <span style=color:#f92672>-&gt;</span> T): T
</span></span></code></pre></div><ul><li><code>block</code>은 <code>CoroutineScope</code>를 리시버로 갖는 suspend 람다</li><li>내부에서 <code>launch</code>, <code>async</code> 등을 <code>this.</code> 없이 사용 가능</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>runBlocking {
</span></span><span style=display:flex><span>    launch { println(<span style=color:#e6db74>&#34;Hi from coroutine&#34;</span>) }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=리시버-람다의-장점>리시버 람다의 장점</h2><div class=table-wrapper><table><thead><tr><th>장점</th><th>설명</th></tr></thead><tbody><tr><td>DSL 작성에 유리</td><td><code>this</code> 생략 가능. 직관적인 문법 제공</td></tr><tr><td>컨텍스트 스코프 제공</td><td>내부에서 특정 타입의 기능을 자연스럽게 활용 가능</td></tr><tr><td>Kotlin 특유의 선언형 스타일 표현 가능</td><td><code>apply</code>, <code>with</code>, <code>run</code>, <code>build.gradle.kts</code> 등에서 사용됨</td></tr></tbody></table></div><hr><h2 id=요약-정리>요약 정리</h2><ul><li><code>Receiver.() -> T</code>는 <strong>리시버를 갖는 람다 타입</strong></li><li>내부에서 <code>this</code>는 리시버 객체를 가리킴</li><li><code>apply</code>, <code>runBlocking</code>, <code>withContext</code> 등에서 사용됨</li></ul><p>리시버 람다는 Kotlin DSL, 구조화된 코루틴, 빌더 패턴 등을 가능하게 하는 핵심적인 언어 기능입니다. Kotlin의 선언형 프로그래밍 스타일을 이해하려면 <strong>리시버 람다의 개념을 정확히 이해하는 것이 매우 중요</strong>합니다.</p><hr><h2 id=참고-자료>참고 자료</h2><ul><li>Kotlin 공식 문서: <a class=link href=https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver target=_blank rel=noopener>https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver</a></li><li>Kotlin 표준 라이브러리 예시: <code>apply</code>, <code>run</code>, <code>with</code></li><li>JetBrains Kotlin 슬라이드: DSL 만들기</li></ul></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>Kotlin</a></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/post/kotlinanonymousfunction/><div class=article-details><h2 class=article-title>[v.0.0] 익명 함수란? (anonymous function)</h2></div></a></article><article><a href=/post/kotlinexpressionbodyfunction/><div class=article-details><h2 class=article-title>[v.0.0] Kotlin 문법 정리: Expression Body Function</h2></div></a></article><article><a href=/post/kotlinlambdaexpression/><div class=article-details><h2 class=article-title>[v.0.0] Kotlin 문법 정리: Lambda Expression</h2></div></a></article><article><a href=/post/kotlintrailinglambdasyntax/><div class=article-details><h2 class=article-title>[v.0.0] Kotlin 문법 정리: Trailing Lambda Syntax</h2></div></a></article></div></div></aside><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 리부트 기술 블로그v2</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>