<!doctype html><html lang=en-us dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Kotlin Coroutine의 멀티스레드 동작 방식 1. 개요 Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(CoroutineDispatcher)의 역할과 실행 흐름에 대해 서술한다.\n2. 코루틴과 스레드의 관계 Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.\n"><title>[v.0.0] Kotlin 코루틴의 멀티스레드 동작 방식</title><link rel=canonical href=https://jaemin-baek.github.io/post/coroutine/><link rel=stylesheet href=/scss/style.min.946cca6c6259ef94ac55abfae7c7bf3291ea3ed5eea17ef77500b257217c6710.css><meta property='og:title' content="[v.0.0] Kotlin 코루틴의 멀티스레드 동작 방식"><meta property='og:description' content="Kotlin Coroutine의 멀티스레드 동작 방식 1. 개요 Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(CoroutineDispatcher)의 역할과 실행 흐름에 대해 서술한다.\n2. 코루틴과 스레드의 관계 Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.\n"><meta property='og:url' content='https://jaemin-baek.github.io/post/coroutine/'><meta property='og:site_name' content='리부트 기술 블로그v2'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='kotlin'><meta property='article:tag' content='coroutine'><meta property='article:tag' content='multithreading'><meta property='article:tag' content='concurrency'><meta property='article:published_time' content='2025-02-16T00:00:00+00:00'><meta property='article:modified_time' content='2025-02-16T00:00:00+00:00'><meta name=twitter:title content="[v.0.0] Kotlin 코루틴의 멀티스레드 동작 방식"><meta name=twitter:description content="Kotlin Coroutine의 멀티스레드 동작 방식 1. 개요 Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(CoroutineDispatcher)의 역할과 실행 흐름에 대해 서술한다.\n2. 코루틴과 스레드의 관계 Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.\n"></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/profile_hu_99a977ddffbecdab.png width=300 height=275 class=site-logo loading=lazy alt=Avatar></a></figure><div class=site-meta><h1 class=site-name><a href=/>리부트 기술 블로그v2</a></h1><h2 class=site-description>@WEMADE</h2></div></header><ol class=menu-social><li><a href=https://github.com/jaemin-baek target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/page/archives/><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/page/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href><span></span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/kotlin/>Kotlin</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/post/coroutine/>[v.0.0] Kotlin 코루틴의 멀티스레드 동작 방식</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Feb 16, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>4 minute read</time></div></footer></div></header><section class=article-content><h2 id=kotlin-coroutine의-멀티스레드-동작-방식>Kotlin Coroutine의 멀티스레드 동작 방식</h2><h3 id=1-개요>1. 개요</h3><p>Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(<code>CoroutineDispatcher</code>)의 역할과 실행 흐름에 대해 서술한다.</p><hr><h3 id=2-코루틴과-스레드의-관계>2. 코루틴과 스레드의 관계</h3><p>Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.</p><hr><h3 id=3-coroutinedispatcher의-역할>3. CoroutineDispatcher의 역할</h3><p><code>CoroutineDispatcher</code>는 코루틴이 실행될 스레드를 결정하는 핵심 컴포넌트이다. 주요 디스패처는 다음과 같다.</p><ul><li><code>Dispatchers.Default</code>: CPU 집약적인 작업을 위한 공유 스레드 풀을 사용한다. 일반적으로 코어 수에 비례한 스레드를 할당한다.</li><li><code>Dispatchers.IO</code>: 블로킹 I/O 작업에 최적화된 디스패처로, 더 많은 수의 스레드를 동적으로 생성하여 처리한다.</li><li><code>Dispatchers.Main</code>: UI 기반 애플리케이션에서 메인 스레드에서 실행되도록 보장한다. 안드로이드 또는 JavaFX 환경에서 사용된다.</li><li><code>newSingleThreadContext(name: String)</code>: 명시적으로 단일 스레드를 생성하여 해당 코루틴만을 위해 사용할 수 있도록 한다.</li></ul><p>각 디스패처는 코루틴이 실행되는 스레드의 종류를 정의함으로써, 개발자가 동시성 또는 병렬성을 세밀하게 제어할 수 있도록 한다.</p><hr><h3 id=4-실행-예시-및-스레드-분산>4. 실행 예시 및 스레드 분산</h3><p>다음은 다양한 디스패처를 지정하여 코루틴이 각각 다른 스레드에서 실행되는 예시이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>import</span> kotlinx.coroutines.*
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() = runBlocking {
</span></span><span style=display:flex><span>    launch(<span style=color:#a6e22e>Dispatchers</span>.Default) {
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;Default dispatcher: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    launch(<span style=color:#a6e22e>Dispatchers</span>.IO) {
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;IO dispatcher: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    launch(newSingleThreadContext(<span style=color:#e6db74>&#34;MyThread&#34;</span>)) {
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;Single thread context: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>위 예제는 세 개의 코루틴이 서로 다른 스레드에서 동시에 실행되는 구조를 갖는다. 이로써 코루틴이 단일 스레드에 국한되지 않으며, 디스패처 설정에 따라 명시적으로 병렬 실행이 가능함을 확인할 수 있다.</p><h3 id=실행-결과>실행 결과:</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Single thread context: MyThread
</span></span></code></pre></div><p>그런데 Default, IO 가 기대했던 DefaultDispatcher-worker-1 , DefaultDispatcher-worker-2 가 아니다.</p><p>이건 Dispatchers.Default와 Dispatchers.IO가 같은 스레드에서 실행된 것처럼 보이는 현상인데 이유는 아래와 같다.</p><h3 id=왜-dispatchersdefault와-io가-같은-스레드-이름일까>왜 Dispatchers.Default와 IO가 같은 스레드 이름일까?</h3><h4 id=공유-풀을-사용-중>공유 풀을 사용 중</h4><ol><li>Dispatchers.Default와 Dispatchers.IO는 모두 스레드 풀(thread pool) 기반이다.</li><li>둘 다 내부적으로 DefaultExecutor와 IOExecutor를 공유하는 구조가 있다.</li><li>JVM이 할당한 첫 번째 워커 스레드(worker-1)가 여러 코루틴에 재사용될 수 있다.</li></ol><div class=table-wrapper><table><thead><tr><th>Dispatcher</th><th>설명</th></tr></thead><tbody><tr><td><code>Dispatchers.Default</code></td><td>CPU 중심 작업용, <strong>코어 수만큼의 스레드 풀</strong> 사용</td></tr><tr><td><code>Dispatchers.IO</code></td><td>I/O 중심 작업용, <strong>무제한 스레드 풀</strong>, 내부적으로 <code>Default</code>를 재사용함</td></tr><tr><td><code>newSingleThreadContext()</code></td><td>오직 <strong>1개의 전용 스레드</strong>만 사용하는 디스패처, 명시적으로 생성한 스레드 사용</td></tr></tbody></table></div><p>즉, 같은 워커가 같은 순간에 여러 코루틴을 처리하지 않더라도, 스레드 풀 안에서 동적으로 배정되다 보니 같은 이름이 출력될 수 있다.</p><h4 id=작은-예제라-워커-수가-1개로-충분한-상황>작은 예제라 워커 수가 1개로 충분한 상황</h4><p>runBlocking + 3개의 launch를 실행할 뿐이라서, 코어 수가 충분하거나 작업이 짧을 경우 JVM은 worker-1만 사용한다. 내부적으로 DefaultDispatcher-worker-1, -2, -3 등이 필요 시 생성</p><h3 id=확인-실험>확인 실험</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>main</span>() = runBlocking {
</span></span><span style=display:flex><span>    repeat(<span style=color:#ae81ff>10</span>) {
</span></span><span style=display:flex><span>        launch(<span style=color:#a6e22e>Dispatchers</span>.Default) {
</span></span><span style=display:flex><span>            println(<span style=color:#e6db74>&#34;Default dispatcher: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        launch(<span style=color:#a6e22e>Dispatchers</span>.IO) {
</span></span><span style=display:flex><span>            println(<span style=color:#e6db74>&#34;IO dispatcher: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    launch(newSingleThreadContext(<span style=color:#e6db74>&#34;MyThread&#34;</span>)) {
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;Single thread context: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=실행-결과-1>실행 결과</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>6</span>
</span></span><span style=display:flex><span>Default dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>7</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>3</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>5</span>
</span></span><span style=display:flex><span>IO dispatcher: DefaultDispatcher-worker-<span style=color:#ae81ff>4</span>
</span></span><span style=display:flex><span>Single thread context: MyThread
</span></span></code></pre></div><h3 id=5-코루틴의-스레드-전환>5. 코루틴의 스레드 전환</h3><p>코루틴은 <code>withContext()</code> 함수를 통해 실행 중인 스레드를 동적으로 전환할 수 있다. 이는 컨텍스트 전환(Context Switch)을 명시적으로 수행하는 것으로, 특정 블록의 실행을 다른 디스패처가 관리하도록 위임하는 방식이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>sample</span>() {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Start: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    withContext(<span style=color:#a6e22e>Dispatchers</span>.IO) {
</span></span><span style=display:flex><span>        println(<span style=color:#e6db74>&#34;IO context: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Resume: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>이 구조는 코루틴의 유연성과 구조적 동시성(Structured Concurrency)을 강화하는 핵심 기제로 작용한다.</p><h3 id=실행-결과-2>실행 결과:</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>Start: main
</span></span><span style=display:flex><span>IO context: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Resume: main
</span></span></code></pre></div><hr><h3 id=6-동시성과-병렬성>6. 동시성과 병렬성</h3><p>코루틴은 기본적으로 협조적(concurrent) 실행을 지향하나, 다중 디스패처를 활용하면 병렬성(parallelism)도 구현 가능하다. async와 await를 활용하면 서로 독립적인 계산을 동시에 수행하면서 결과를 효율적으로 병합할 수 있다.
다음은 Kotlin의 <code>async</code>와 <code>await</code>를 활용하여 두 작업을 병렬로 실행하고, 그 결과를 합산하는 예제이다.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#75715e>// await: 결과가 준비될 때까지 suspend
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> resultA = async(<span style=color:#a6e22e>Dispatchers</span>.Default) { computeA() }
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> resultB = async(<span style=color:#a6e22e>Dispatchers</span>.IO) { computeB() }
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> combined = resultA.await() + resultB.await()
</span></span></code></pre></div><h3 id=실행-흐름-설명>실행 흐름 설명</h3><ol><li><code>computeA()</code>는 <code>Dispatchers.Default</code> 디스패처에서 실행되며, 이는 CPU 집약적인 작업을 위한 공용 스레드 풀을 사용한다.</li><li><code>computeB()</code>는 <code>Dispatchers.IO</code> 디스패처에서 실행되며, I/O 블로킹 작업에 최적화된 스레드 풀에서 처리된다.</li><li><code>async</code>를 통해 두 작업은 <strong>동시에 실행</strong>되며, 서로 다른 스레드에서 병렬로 수행된다.</li><li><code>await()</code>는 각각의 결과가 준비될 때까지 <strong>suspend 상태로 대기</strong>하며, 이 동안 다른 코루틴이 실행될 수 있다.</li><li>두 <code>await()</code> 호출이 완료되면 <code>resultA</code>와 <code>resultB</code>의 값을 더하여 <code>combined</code>에 결과를 저장한다.</li></ol><p>이러한 병렬 실행은 코어 수에 따른 스레드 분산을 통해 실행 성능을 높이는 데 효과적이다.</p><h3 id=예시-구현>예시 구현</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>computeA</span>(): Int {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Running computeA on: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>500</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>10</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>suspend</span> <span style=color:#66d9ef>fun</span> <span style=color:#a6e22e>computeB</span>(): Int {
</span></span><span style=display:flex><span>    println(<span style=color:#e6db74>&#34;Running computeB on: </span><span style=color:#e6db74>${Thread.currentThread().name}</span><span style=color:#e6db74>&#34;</span>)
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>1000</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>20</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=실행-결과-3>실행 결과:</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-kotlin data-lang=kotlin><span style=display:flex><span>Running computeA on: DefaultDispatcher-worker-<span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>Running computeB on: DefaultDispatcher-worker-<span style=color:#ae81ff>2</span>
</span></span></code></pre></div><p>computeA()는 약 500ms 후 10을 반환하고, computeB()는 약 1000ms 후 20을 반환한다. 따라서 combined의 값은 30이다.</p><hr><h3 id=7-결론>7. 결론</h3><p>Kotlin의 코루틴은 전통적인 스레드 기반 프로그래밍의 한계를 극복하고, 비동기 처리를 보다 안전하고 구조적으로 구현할 수 있도록 설계되었다. 멀티스레드 환경에서의 코루틴 실행은 디스패처 설정을 통해 세밀히 제어되며, 협조적 실행 모델을 기반으로 하되 병렬 처리를 통해 성능 최적화도 가능하다. 이는 현대 애플리케이션 개발에서 요구되는 고성능 동시 처리 요구를 효과적으로 충족시킨다.</p></section><footer class=article-footer><section class=article-tags><a href=/tags/kotlin/>Kotlin</a>
<a href=/tags/coroutine/>Coroutine</a>
<a href=/tags/multithreading/>Multithreading</a>
<a href=/tags/concurrency/>Concurrency</a></section></footer></article><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 리부트 기술 블로그v2</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>