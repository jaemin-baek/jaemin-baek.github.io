<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 리부트 기술 블로그v2</title><link>https://jaemin-baek.github.io/post/</link><description>Recent content in Posts on 리부트 기술 블로그v2</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Thu, 13 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://jaemin-baek.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>Kotlin Multiplatform의 expect/actual 정리</title><link>https://jaemin-baek.github.io/post/kotlinactualexpect/</link><pubDate>Thu, 13 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlinactualexpect/</guid><description>&lt;h1 id="kotlin-multiplatform의-expectactual-정리">Kotlin Multiplatform의 expect/actual 정리
&lt;/h1>&lt;p>Kotlin Multiplatform(KMP)을 이해하기 위해 반드시 알아야 할 키워드가 바로 &lt;code>expect&lt;/code>와 &lt;code>actual&lt;/code>입니다. 이 키워드는 플랫폼마다 다른 구현을 제공하면서도, 공통 인터페이스를 유지하는 &lt;strong>다형성 선언 방식&lt;/strong>을 가능하게 합니다.&lt;/p>
&lt;p>이 글에서는 &lt;code>expect&lt;/code>/&lt;code>actual&lt;/code> 키워드의 개념부터 컴파일 타임 처리 방식, IDE에서 보이지 않는 이유까지 자세히 설명합니다.&lt;/p>
&lt;hr>
&lt;h2 id="기본-개념-expect와-actual이란">기본 개념: &lt;code>expect&lt;/code>와 &lt;code>actual&lt;/code>이란?
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키워드&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>expect&lt;/code>&lt;/td>
&lt;td>공통 코드에 선언된 API 인터페이스 (stub)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>actual&lt;/code>&lt;/td>
&lt;td>각 플랫폼에서의 실제 구현&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>즉, &lt;code>expect&lt;/code>는 **계약(Contract)**이고,&lt;br>
&lt;code>actual&lt;/code>은 그 계약에 맞는 **실제 구현(Implementation)**입니다.&lt;/p>
&lt;hr>
&lt;h2 id="예시-코드">예시 코드
&lt;/h2>&lt;h3 id="commonmain-공통-모듈">commonMain (공통 모듈)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 선언만 있고 구현 없음
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">expect&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPlatformName&lt;/span>(): String
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="jvmmain">jvmMain
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">actual&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPlatformName&lt;/span>(): String = &lt;span style="color:#e6db74">&amp;#34;JVM&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="iosmain">iosMain
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">actual&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">getPlatformName&lt;/span>(): String = &lt;span style="color:#e6db74">&amp;#34;iOS&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>expect&lt;/code>는 인터페이스만 정의하고, 각 플랫폼에 맞는 &lt;code>actual&lt;/code> 구현이 연결됩니다.&lt;/p>
&lt;hr>
&lt;h2 id="왜-jar에서는-expect가-안-보일까">왜 &lt;code>.jar&lt;/code>에서는 &lt;code>expect&lt;/code>가 안 보일까?
&lt;/h2>&lt;h3 id="external-libraries에서는-expect를-찾을-수-없음">External Libraries에서는 &lt;code>expect&lt;/code>를 찾을 수 없음
&lt;/h3>&lt;p>Gradle에서 다운받은 JAR 파일(&lt;code>kotlinx-coroutines-core-jvm-1.7.3.jar&lt;/code>)은 &lt;strong>JVM에서 실행 가능한 바이트코드&lt;/strong>만 포함합니다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>expect&lt;/code>는 &lt;strong>컴파일 타임에만 존재하는 추상 선언&lt;/strong>입니다&lt;/li>
&lt;li>JVM에는 &lt;code>actual&lt;/code> 구현만 컴파일되고 포함됨&lt;/li>
&lt;li>따라서 &lt;code>.jar&lt;/code> 안에서는 &lt;code>expect&lt;/code> 선언을 확인할 수 없습니다&lt;/li>
&lt;/ul>
&lt;p>대신 &lt;code>expect&lt;/code>를 확인하려면:&lt;/p>
&lt;ul>
&lt;li>GitHub 저장소: &lt;a class="link" href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener"
>https://github.com/Kotlin/kotlinx.coroutines&lt;/a>&lt;/li>
&lt;li>경로 예: &lt;code>kotlinx-coroutines-core/commonMain/kotlin/kotlinx/coroutines/Builders.kt&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="사용-목적">사용 목적
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>상황&lt;/th>
&lt;th>이유&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>플랫폼별 파일 경로 필요&lt;/td>
&lt;td>Android: &lt;code>Context.filesDir&lt;/code>, iOS: &lt;code>NSFileManager&lt;/code> 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>UI, 시스템 API 분리&lt;/td>
&lt;td>JVM은 &lt;code>Swing&lt;/code>, iOS는 &lt;code>UIKit&lt;/code> 사용 등&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>네이티브 코드 연동&lt;/td>
&lt;td>&lt;code>actual&lt;/code>에서 C/C++ 호출 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="ide-팁-expectactual-관계-보기">IDE 팁: &lt;code>expect/actual&lt;/code> 관계 보기
&lt;/h2>&lt;ol>
&lt;li>&lt;code>commonMain&lt;/code>에 &lt;code>expect&lt;/code> 선언 추가&lt;/li>
&lt;li>&lt;code>jvmMain&lt;/code>/&lt;code>iosMain&lt;/code>에 &lt;code>actual&lt;/code> 구현 작성&lt;/li>
&lt;li>IntelliJ나 Android Studio에서는 &lt;code>Cmd+B&lt;/code>로 상호 이동 가능&lt;br>
(단, 소스가 연결되어 있어야 함)&lt;/li>
&lt;/ol>
&lt;blockquote>
&lt;p>&lt;code>expect&lt;/code>에 커서 올리면 구현된 &lt;code>actual&lt;/code> 목록을 툴팁으로 확인할 수 있음&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h2 id="정리-요약">정리 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>키워드&lt;/th>
&lt;th>목적&lt;/th>
&lt;th>컴파일 타임 존재&lt;/th>
&lt;th>런타임 존재&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>expect&lt;/code>&lt;/td>
&lt;td>공통 선언&lt;/td>
&lt;td>✅ 있음&lt;/td>
&lt;td>❌ 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>actual&lt;/code>&lt;/td>
&lt;td>플랫폼 구현&lt;/td>
&lt;td>✅ 있음&lt;/td>
&lt;td>✅ 있음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>&lt;code>.jar&lt;/code>에는 &lt;code>actual&lt;/code>만 존재 → &lt;code>expect&lt;/code>는 보이지 않음&lt;/li>
&lt;li>&lt;code>expect&lt;/code>는 &lt;strong>다형성의 선언부&lt;/strong>, &lt;code>actual&lt;/code>은 &lt;strong>구현부&lt;/strong> 역할&lt;/li>
&lt;li>Kotlin Multiplatform에서 플랫폼 특화 코드를 안전하게 관리할 수 있게 해 줌&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="참고-링크">참고 링크
&lt;/h2>&lt;ul>
&lt;li>Kotlin 공식 문서: &lt;a class="link" href="https://kotlinlang.org/docs/multiplatform.html" target="_blank" rel="noopener"
>https://kotlinlang.org/docs/multiplatform.html&lt;/a>&lt;/li>
&lt;li>GitHub: &lt;a class="link" href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener"
>https://github.com/Kotlin/kotlinx.coroutines&lt;/a>&lt;/li>
&lt;li>Expect/Actual 예제: &lt;a class="link" href="https://kotlinlang.org/docs/mpp-connect-to-apis.html" target="_blank" rel="noopener"
>https://kotlinlang.org/docs/mpp-connect-to-apis.html&lt;/a>&lt;/li>
&lt;/ul></description></item><item><title>Kotlin 언어 기능 제안 및 코드 기여 실전 가이드</title><link>https://jaemin-baek.github.io/post/kotlin_contribution_guide/</link><pubDate>Wed, 12 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlin_contribution_guide/</guid><description>&lt;h1 id="kotlin-언어-기능-제안-및-코드-기여-실전-가이드">Kotlin 언어 기능 제안 및 코드 기여 실전 가이드
&lt;/h1>&lt;p>이 문서는 Kotlin 언어에 새로운 기능을 직접 제안하고, 설계하고, 컴파일러 코드까지 기여하는 전체 과정을 다룹니다. 단순한 이슈 제기를 넘어서 실제 &lt;strong>KEEP 문서 작성부터 parser 수정, IR 처리, 테스트 작성, PR 제출까지&lt;/strong> 모든 단계를 실습 중심으로 안내합니다.&lt;/p>
&lt;hr>
&lt;h2 id="kotlin-컴파일-과정-요약-psi--fir--ir--bytecode">Kotlin 컴파일 과정 요약: PSI → FIR → IR → Bytecode
&lt;/h2>&lt;h3 id="psi-program-structure-interface">PSI (Program Structure Interface)
&lt;/h3>&lt;ul>
&lt;li>Kotlin 코드의 문법 구조를 표현하는 트리 (구문 트리)&lt;/li>
&lt;li>파서(parser)가 소스 코드를 읽고 생성&lt;/li>
&lt;/ul>
&lt;h3 id="fir-front-end-intermediate-representation">FIR (Front-end Intermediate Representation)
&lt;/h3>&lt;ul>
&lt;li>PSI를 기반으로 구성된 추상적이고 정형화된 표현식 트리&lt;/li>
&lt;li>타입 추론, 제어 흐름 해석, 스코프 관리 등을 수행&lt;/li>
&lt;/ul>
&lt;h3 id="ir-intermediate-representation">IR (Intermediate Representation)
&lt;/h3>&lt;ul>
&lt;li>FIR을 기반으로 백엔드 처리용으로 변환한 중간 표현&lt;/li>
&lt;li>JVM/JS/Native 공통 처리 가능&lt;/li>
&lt;li>최적화 및 로워링 대상&lt;/li>
&lt;/ul>
&lt;h3 id="bytecode-jvm">Bytecode (JVM)
&lt;/h3>&lt;ul>
&lt;li>최종적으로 IR이 JVM 바이트코드로 변환되어 &lt;code>.class&lt;/code>로 출력됨&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="실전-시나리오-guard-구문-제안-및-구현하기">실전 시나리오: &lt;code>guard&lt;/code> 구문 제안 및 구현하기
&lt;/h2>&lt;p>&lt;code>guard (조건) else { ... }&lt;/code> 문법은 가독성이 높고 Swift와 유사한 조기 탈출(early exit) 구문입니다. Kotlin에 이를 도입하는 과정을 처음부터 끝까지 따라가봅니다.&lt;/p>
&lt;h3 id="step-1-아이디어-공유-및-커뮤니티-피드백">Step 1. 아이디어 공유 및 커뮤니티 피드백
&lt;/h3>&lt;ul>
&lt;li>Kotlin Slack &lt;code>#language-proposals&lt;/code>에 아래 내용 공유&lt;/li>
&lt;li>&lt;code>discuss.kotlinlang.org&lt;/code>에도 같은 아이디어를 올려 반응 확인&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>Kotlin에 Swift 스타일의 &lt;code>guard (condition) else {}&lt;/code> 구문을 도입하고 싶습니다. &lt;code>if (!condition) return&lt;/code> 보다 읽기 쉽고 명확합니다. KEEP 작성 전에 커뮤니티 의견을 듣고 싶습니다.&lt;/p>&lt;/blockquote>
&lt;h3 id="step-2-keep-문서-작성-및-제출">Step 2. KEEP 문서 작성 및 제출
&lt;/h3>&lt;p>KEEP(Kotlin Evolution and Enhancement Process)은 Kotlin 언어의 새로운 기능을 제안하고 문서화하는 공식 절차입니다.&lt;/p>
&lt;h4 id="작성-위치">작성 위치:
&lt;/h4>&lt;ol>
&lt;li>GitHub 저장소: &lt;a class="link" href="https://github.com/Kotlin/KEEP" target="_blank" rel="noopener"
>https://github.com/Kotlin/KEEP&lt;/a>&lt;/li>
&lt;li>본인 계정으로 Fork 후 Clone&lt;/li>
&lt;li>&lt;code>proposals/&lt;/code> 디렉토리에 Markdown 파일 생성 (예: &lt;code>guard-expression.md&lt;/code>)&lt;/li>
&lt;/ol>
&lt;h4 id="문서-기본-템플릿-구성">문서 기본 템플릿 구성:
&lt;/h4>&lt;ul>
&lt;li>&lt;code>Summary&lt;/code>: 기능 요약&lt;/li>
&lt;li>&lt;code>Motivation&lt;/code>: 왜 필요한가?&lt;/li>
&lt;li>&lt;code>Syntax&lt;/code>: 문법 예시&lt;/li>
&lt;li>&lt;code>Semantics&lt;/code>: 내부적으로 어떻게 동작하는가&lt;/li>
&lt;li>&lt;code>Compatibility&lt;/code>: 기존 코드와 충돌 여부&lt;/li>
&lt;li>&lt;code>Implementation&lt;/code>: Token → PSI → FIR → IR 흐름&lt;/li>
&lt;li>&lt;code>Alternatives&lt;/code>: 기존 방식과의 비교&lt;/li>
&lt;/ul>
&lt;h4 id="github에-pr-제출하기">GitHub에 PR 제출하기:
&lt;/h4>&lt;ol>
&lt;li>파일 작성 후 커밋 및 본인 원격 저장소에 Push&lt;/li>
&lt;li>GitHub 웹에서 Fork 저장소 방문 → &amp;lsquo;Compare &amp;amp; Pull Request&amp;rsquo; 클릭&lt;/li>
&lt;li>base repository: &lt;code>Kotlin/KEEP&lt;/code>, base: &lt;code>master&lt;/code>, head: 본인 브랜치&lt;/li>
&lt;li>제목: &lt;code>Propose: guard keyword for early return&lt;/code>&lt;/li>
&lt;li>설명란에 문서 내용 요약 작성&lt;/li>
&lt;/ol>
&lt;h4 id="slack-공유-예시">Slack 공유 예시:
&lt;/h4>&lt;p>Slack &lt;code>#language-proposals&lt;/code> 채널에서 아래와 같이 알립니다:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>Hi all 👋
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>I&amp;#39;ve drafted a KEEP proposal introducing a new &lt;span style="color:#e6db74">`guard (cond) else {}`&lt;/span> syntax for early exits, similar to Swift.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>PR link: https://github.com/Kotlin/KEEP/pull/XXX
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Looking forward to your feedback, especially regarding parser and FIR/IR feasibility.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>CC: @elizarov @ilya-g
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Slack은 비공식 토론의 중심이며, 리뷰 반영 속도를 높이는 데 효과적입니다.&lt;/p>
&lt;h3 id="step-3-parser-수정-jettokens-kotlinparser">Step 3. parser 수정 (JetTokens, KotlinParser)
&lt;/h3>&lt;ul>
&lt;li>&lt;code>GUARD_KEYWORD&lt;/code>, &lt;code>ELSE_KEYWORD&lt;/code> 추가&lt;/li>
&lt;li>&lt;code>guard (condition) else { block }&lt;/code>를 PSI 트리로 파싱되도록 구현&lt;/li>
&lt;/ul>
&lt;h3 id="step-4-fir-구조-정의">Step 4. FIR 구조 정의
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">FirGuardExpressionImpl&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> condition: FirExpression,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> elseBlock: FirBlock
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>) : FirExpression()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>FIR 트리에 새 노드로 포함&lt;/li>
&lt;/ul>
&lt;h3 id="step-5-ir-변환-로직-작성">Step 5. IR 변환 로직 작성
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">visitGuardExpression&lt;/span>(expression: IrGuardExpression): IrStatement {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> irIfThenElse(&lt;span style="color:#f92672">..&lt;/span>.)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>if (!cond) { block }&lt;/code> 로 변환&lt;/li>
&lt;/ul>
&lt;h3 id="step-6-테스트-코드-추가">Step 6. 테스트 코드 추가
&lt;/h3>&lt;ul>
&lt;li>위치: &lt;code>compiler/tests-spec/testData/guard/Basic.kt&lt;/code>&lt;/li>
&lt;li>케이스: 조건 실패 시 블록 실행 여부 확인&lt;/li>
&lt;/ul>
&lt;h3 id="step-7-pull-request-제출">Step 7. Pull Request 제출
&lt;/h3>&lt;ul>
&lt;li>브랜치: &lt;code>feature/guard-keyword&lt;/code>&lt;/li>
&lt;li>제목: &lt;code>Add guard keyword expression&lt;/code>&lt;/li>
&lt;li>설명:&lt;/li>
&lt;/ul>
&lt;pre tabindex="0">&lt;code>This PR introduces a new syntax for early exit using `guard (cond) else {}`
- Added GUARD and ELSE tokens
- Implemented parser rule
- Introduced FirGuardExpression
- Lowered to standard if-not-else IR
- Added test cases
&lt;/code>&lt;/pre>&lt;ul>
&lt;li>공유: Slack &lt;code>#language-proposals&lt;/code>, reviewer 지정 요청&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="step-8-jetbrains-컨택-및-리뷰어-안내">Step 8. JetBrains 컨택 및 리뷰어 안내
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>이름&lt;/th>
&lt;th>역할&lt;/th>
&lt;th>GitHub ID&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Roman Elizarov&lt;/td>
&lt;td>Kotlin 리드 디자이너, 코루틴 설계자&lt;/td>
&lt;td>@elizarov&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Ilya Gorbunov&lt;/td>
&lt;td>Kotlin compiler contributor&lt;/td>
&lt;td>@ilya-g&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Svetlana Isakova&lt;/td>
&lt;td>Kotlin developer advocate&lt;/td>
&lt;td>@svetlanak999&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Egor Tolstoy&lt;/td>
&lt;td>Kotlin compiler + IntelliJ integration&lt;/td>
&lt;td>@egor-tolstoy&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;ul>
&lt;li>PR 후 Slack &lt;code>#language-proposals&lt;/code>에서 &lt;code>@멘션&lt;/code>하여 리뷰 요청&lt;/li>
&lt;li>필요 시 GitHub에서 &lt;code>ping&lt;/code>하여 응답 유도&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="step-9-기여-후-유지-관리와-후속-대응">Step 9. 기여 후 유지 관리와 후속 대응
&lt;/h2>&lt;ul>
&lt;li>기능이 릴리스 브랜치에 포함될 때까지 추적&lt;/li>
&lt;li>실험적 기능이면 opt-in 애노테이션 유지 필요&lt;/li>
&lt;li>&lt;code>kotlin-web-site&lt;/code> 문서 기여 필요&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="step-10-실제-기여-예시-탐색">Step 10. 실제 기여 예시 탐색
&lt;/h2>&lt;ul>
&lt;li>&lt;a class="link" href="https://github.com/JetBrains/kotlin/pull/4423" target="_blank" rel="noopener"
>context receivers PR&lt;/a>&lt;/li>
&lt;li>&lt;a class="link" href="https://github.com/JetBrains/kotlin/pull/3613" target="_blank" rel="noopener"
>sealed interfaces PR&lt;/a>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="step-11-공식-문서화-저장소-기여">Step 11. 공식 문서화 저장소 기여
&lt;/h2>&lt;ul>
&lt;li>저장소: &lt;a class="link" href="https://github.com/JetBrains/kotlin-web-site" target="_blank" rel="noopener"
>https://github.com/JetBrains/kotlin-web-site&lt;/a>&lt;/li>
&lt;li>위치: &lt;code>pages/docs&lt;/code>&lt;/li>
&lt;li>문서 예시:&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-markdown" data-lang="markdown">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">## guard (condition) else {}
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Introduced in Kotlin X.X
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>A new control-flow expression that simplifies early exit patterns.
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>```kotlin
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>fun example(x: Int?) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> guard (x != null) else {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&amp;#34;Invalid input&amp;#34;)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> return
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(x)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>
---
## 마무리 요약
| 단계 | 설명 |
|------|------|
| 1 | 아이디어 제안 및 커뮤니티 피드백 |
| 2 | KEEP 작성 및 PR 제출 |
| 3 | parser/lexer 수정 |
| 4 | FIR 구조 반영 |
| 5 | IR 변환 구현 |
| 6 | 테스트 작성 |
| 7 | Pull Request 제출 및 리뷰 대응 |
| 8 | JetBrains 팀과 협업 및 피드백 수용 |
| 9 | 기능 릴리스 전후 지속적 기여 |
| 10 | 실제 사례 학습 |
| 11 | 공식 문서화 기여 완료 |
&lt;/code>&lt;/pre></description></item><item><title>Kotlin 코루틴 내부 구조 (상태 머신 + Continuation + CPS)</title><link>https://jaemin-baek.github.io/post/coroutinecontinuation/</link><pubDate>Wed, 12 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinecontinuation/</guid><description>&lt;h1 id="kotlin-코루틴-내부-구조-상태-머신--continuation--cps">Kotlin 코루틴 내부 구조 (상태 머신 + Continuation + CPS)
&lt;/h1>&lt;p>Kotlin의 &lt;code>suspend&lt;/code> 키워드를 사용하는 코루틴은 단순한 비동기 기능이 아닙니다. 내부적으로는 &lt;strong>상태 머신(state machine)&lt;/strong> 과 &lt;strong>Continuation-passing style (CPS)&lt;/strong> 기반의 구조로 동작하며, 이러한 설계를 통해 코루틴은 &lt;strong>비동기 코드를 동기처럼 자연스럽게 표현&lt;/strong>할 수 있습니다.&lt;/p>
&lt;hr>
&lt;h2 id="기본-개념-suspend-함수란">기본 개념: &lt;code>suspend&lt;/code> 함수란?
&lt;/h2>&lt;p>&lt;code>suspend&lt;/code> 함수는 &lt;strong>중단(suspend)&lt;/strong> 및 &lt;strong>재개(resume)&lt;/strong> 가 가능한 함수입니다. 컴파일러는 이를 위해 &lt;code>Continuation&lt;/code> 객체를 생성하고 상태 추적 코드를 자동 생성합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">greet&lt;/span>(): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드는 컴파일러에 의해 상태 머신으로 변환됩니다.&lt;/p>
&lt;hr>
&lt;h2 id="상태-머신-구조-컴파일-결과-개념도">상태 머신 구조 (컴파일 결과 개념도)
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">GreetContinuation&lt;/span>(&lt;span style="color:#66d9ef">val&lt;/span> completion: Continuation&amp;lt;String&amp;gt;) : Continuation&amp;lt;Any?&amp;gt; {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">var&lt;/span> label = &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">lateinit&lt;/span> &lt;span style="color:#66d9ef">var&lt;/span> result: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> context = EmptyCoroutineContext
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">override&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">resumeWith&lt;/span>(&lt;span style="color:#66d9ef">data&lt;/span>: Result&amp;lt;Any?&amp;gt;) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">when&lt;/span> (label) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">0&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> label = &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>, &lt;span style="color:#66d9ef">this&lt;/span>) &lt;span style="color:#75715e">// suspend 후 현재 상태 저장
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#ae81ff">1&lt;/span> &lt;span style="color:#f92672">-&amp;gt;&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;World&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> result = &lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> completion.resumeWith(&lt;span style="color:#a6e22e">Result&lt;/span>.success(result))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Throwable) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> completion.resumeWith(&lt;span style="color:#a6e22e">Result&lt;/span>.failure(e))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>→ &lt;code>label&lt;/code> 값으로 상태를 저장하며, 중단 이후 적절한 지점에서 재개됩니다.&lt;/p>
&lt;hr>
&lt;h2 id="cps-continuation-passing-style">CPS (Continuation-Passing Style)
&lt;/h2>&lt;p>Kotlin 코루틴은 내부적으로 **CPS 변환(CPS Transformation)**을 통해 구현됩니다. 이는 모든 &lt;code>suspend&lt;/code> 함수가 &lt;strong>다음 실행 내용을 Continuation(콜백)&lt;/strong> 으로 넘기는 방식으로 동작한다는 뜻입니다.&lt;/p>
&lt;p>예시:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">hello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;A&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;B&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>→ 컴파일러는 이 코드를 &lt;code>hello(continuation)&lt;/code> 형태로 변환하며, delay 이후 재개 위치를 기억해 두었다가 &lt;code>resumeWith&lt;/code>로 다시 이어서 실행합니다.&lt;/p>
&lt;hr>
&lt;h2 id="delay-함수의-내부">delay 함수의 내부
&lt;/h2>&lt;p>Kotlin의 &lt;code>delay()&lt;/code> 함수는 다음과 같이 작동합니다 (JVM 기준):&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">delay&lt;/span>(timeMillis: Long) = suspendCancellableCoroutine&amp;lt;Unit&amp;gt; { cont &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> scheduled = executor.schedule({
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cont.resume(Unit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }, timeMillis, &lt;span style="color:#a6e22e">TimeUnit&lt;/span>.MILLISECONDS)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cont.invokeOnCancellation {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scheduled.cancel(&lt;span style="color:#66d9ef">false&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>executor&lt;/code>: 내부적으로는 자바의 &lt;code>ScheduledExecutorService&lt;/code> 사용&lt;/li>
&lt;li>&lt;code>suspendCancellableCoroutine&lt;/code>: 코루틴 중단 가능 지점 생성&lt;/li>
&lt;li>&lt;code>resume()&lt;/code>: 일정 시간 후 코루틴 재개&lt;/li>
&lt;/ul>
&lt;p>→ 스레드를 블로킹하지 않고 코루틴만 중단시킴&lt;/p>
&lt;hr>
&lt;h2 id="dispatchers와-스레드">Dispatchers와 스레드
&lt;/h2>&lt;p>Kotlin 코루틴은 직접 스레드를 만들지 않습니다. 대신, 다음과 같은 &lt;strong>Dispatcher&lt;/strong>를 통해 JVM의 스레드 풀을 재사용합니다:&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Dispatcher&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>Default&lt;/td>
&lt;td>CPU 연산용 스레드풀 (ForkJoinPool 기반)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>IO&lt;/td>
&lt;td>IO용 무제한 스레드풀&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Main&lt;/td>
&lt;td>Android 메인 스레드 등 UI 전용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Unconfined&lt;/td>
&lt;td>처음 호출된 스레드에서 실행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>→ 결국 코루틴은 &lt;strong>JVM 스레드에서 실행되지만&lt;/strong>, 코루틴 자체는 스레드가 아닙니다.&lt;/p>
&lt;hr>
&lt;h2 id="참고-자료">참고 자료
&lt;/h2>&lt;ul>
&lt;li>Kotlin 공식 문서: &lt;a class="link" href="https://kotlinlang.org/docs/coroutines-overview.html" target="_blank" rel="noopener"
>https://kotlinlang.org/docs/coroutines-overview.html&lt;/a>&lt;/li>
&lt;li>KotlinConf 2019 Roman Elizarov (설계자) 발표: &lt;a class="link" href="https://www.youtube.com/watch?v=_hfBv0a09Jc" target="_blank" rel="noopener"
>KotlinConf 2019: Coroutines Under the Hood&lt;/a>&lt;/li>
&lt;li>KotlinConf 2017 Roman Elizarov (설계자) 발표: &lt;a class="link" href="https://youtu.be/YrrUCSi72E8?si=EoNjXdNJ2wvMJIpG" target="_blank" rel="noopener"
>https://youtu.be/YrrUCSi72E8?si=EoNjXdNJ2wvMJIpG&lt;/a>&lt;/li>
&lt;li>Kotlin GitHub: &lt;a class="link" href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener"
>https://github.com/Kotlin/kotlinx.coroutines&lt;/a>&lt;/li>
&lt;li>kotlinx.coroutines 구현 내부 코드: &lt;code>suspendCancellableCoroutine.kt&lt;/code>, &lt;code>Delay.kt&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="마무리-요약">마무리 요약
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>핵심 요소&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>suspend&lt;/code>&lt;/td>
&lt;td>상태 머신으로 변환됨 (코드 쪼개짐)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Continuation&lt;/code>&lt;/td>
&lt;td>재개 지점 추적 객체&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>delay()&lt;/code>&lt;/td>
&lt;td>실제로는 스케줄된 콜백 등록 후 중단&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실행 위치&lt;/td>
&lt;td>JVM 스레드풀 (Dispatcher)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>철학&lt;/td>
&lt;td>비동기 코드를 동기처럼 쓰게 해주는 언어 설계&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>Kotlin 코루틴은 단순한 비동기 처리 기술이 아니라, &lt;strong>언어, 컴파일러, 런타임이 조화롭게 설계된 고급 개념&lt;/strong>입니다.&lt;/p></description></item><item><title>Gradle에서 Naver Map SDK SSL 오류 해결 (macOS 기준)</title><link>https://jaemin-baek.github.io/post/gradlesslissue/</link><pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/gradlesslissue/</guid><description>&lt;h1 id="gradle에서-naver-map-sdk-ssl-오류-해결-macos-기준">Gradle에서 Naver Map SDK SSL 오류 해결 (macOS 기준)
&lt;/h1>&lt;p>네이버 지도 SDK를 사용하는 Android 프로젝트에서 다음과 같은 Gradle 에러를 겪었다면, 이 글이 도움이 될 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>unable to find valid certification path to requested target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>브라우저로는 잘 열리는데, Gradle에서는 계속 실패하는… 바로 그 상황입니다.&lt;/p>
&lt;h2 id="-상황-정리">✅ 상황 정리
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// build.gradle.kts 또는 build.gradle
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>implementation(&lt;span style="color:#e6db74">&amp;#34;com.naver.maps:map-sdk:3.21.0&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>을 추가했더니 Gradle에서 아래와 같은 SSL 오류가 발생합니다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Could not GET &lt;span style="color:#960050;background-color:#1e0010">&amp;#39;&lt;/span>https:&lt;span style="color:#75715e">//repository.map.naver.com/archive/maven/...&amp;#39;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>PKIX path building failed: unable to find valid certification path to requested target
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 브라우저에서는 해당 .pom 파일이 정상 다운로드됩니다. 이때 우리는 아래를 의심해야 합니다.&lt;/p>
&lt;h2 id="-문제-원인">🔍 문제 원인
&lt;/h2>&lt;p>✅ Gradle은 브라우저와 달리 자체 JDK 인증서 저장소(cacerts)를 사용합니다&lt;/p>
&lt;p>macOS는 시스템 Keychain을 사용해 프록시 인증서를 신뢰&lt;/p>
&lt;p>하지만 Gradle은 JVM 내부의 cacerts만 신뢰함&lt;/p>
&lt;p>네이버 저장소의 SSL 인증서 또는 프록시가 삽입한 인증서를 신뢰하지 못하면 위 오류 발생&lt;/p>
&lt;h2 id="-문제-해결을-위한-삽질-과정">🧭 문제 해결을 위한 삽질 과정
&lt;/h2>&lt;p>❌ 처음에는 Android Studio 내장 JDK에 인증서를 등록했지만&amp;hellip;&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>/Applications/Android&lt;span style="color:#960050;background-color:#1e0010">\&lt;/span> &lt;span style="color:#a6e22e">Studio&lt;/span>.app/Contents/jbr/Contents/Home/lib/security/cacerts
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 경로에 인증서를 등록했는데, Gradle은 여전히 실패했습니다.&lt;/p>
&lt;p>✅ ./gradlew -version 으로 확인해보니?&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>JVM: &lt;span style="color:#ae81ff">22.0&lt;/span>.&lt;span style="color:#ae81ff">2&lt;/span> (Oracle Corporation)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>JVM home: /Users/&lt;span style="color:#f92672">..&lt;/span>./openjdk-&lt;span style="color:#ae81ff">22.0&lt;/span>.&lt;span style="color:#ae81ff">2&lt;/span>/Contents/Home
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>👉 Gradle은 시스템 JDK (OpenJDK 22)를 사용 중이었던 것!&lt;/p>
&lt;p>✅ 그래서 해당 경로로 다시 인증서 등록&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>sudo keytool -importcert \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -alias naver-map \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -&lt;span style="color:#66d9ef">file&lt;/span> ~/Downloads/naver-map.cer \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -keystore /Users/you/Library/Java/JavaVirtualMachines/openjdk-&lt;span style="color:#ae81ff">22.0&lt;/span>.&lt;span style="color:#ae81ff">2&lt;/span>/Contents/Home/lib/security/cacerts \
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> -storepass changeit
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>-file은 브라우저에서 DER 형식으로 저장한 인증서&lt;/p>
&lt;p>-storepass 기본값은 changeit&lt;/p>
&lt;p>등록 완료 후 ./gradlew clean build 성공! 🎉&lt;/p>
&lt;h2 id="-인증서-추출-방법-macos-기준">🧪 인증서 추출 방법 (macOS 기준)
&lt;/h2>&lt;p>Safari 또는 Chrome으로 &lt;a class="link" href="https://repository.map.naver.com" target="_blank" rel="noopener"
>https://repository.map.naver.com&lt;/a> 접속&lt;/p>
&lt;p>주소창 자물쇠 클릭 → 인증서 보기&lt;/p>
&lt;p>인증서 계층에서 서버 인증서 또는 루트 인증서 선택&lt;/p>
&lt;p>[Export] 클릭 → DER encoded .cer 형식으로 저장&lt;/p>
&lt;p>⚠️ 주의: 회사 네트워크에서는 프록시가 인증서를 바꿨을 수도 있습니다&lt;/p>
&lt;p>많은 회사는 HTTPS 트래픽을 검사하기 위해 SSL 프록시 (중간자 공격 구조)를 사용합니다.
이 경우 네이버의 인증서 대신 사내 인증서가 삽입되어 브라우저는 OK, Gradle은 실패할 수 있습니다.&lt;/p>
&lt;p>✅ 마무리&lt;/p>
&lt;p>이번 경험을 통해 아래를 다시 한번 정리할 수 있었습니다:&lt;/p>
&lt;p>Gradle의 SSL은 브라우저와 별개의 JDK 인증서 체인에 의존&lt;/p>
&lt;p>시스템 JDK인지 Android Studio 내장 JDK인지 반드시 확인&lt;/p>
&lt;p>프록시 환경에선 SSL 인증서가 중간에 바뀔 수 있음&lt;/p></description></item><item><title>Kotlin Receiver Lambda</title><link>https://jaemin-baek.github.io/post/kotlinlamda/</link><pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlinlamda/</guid><description>&lt;h1 id="kotlin-리시버-람다receiver-lambda-정리">Kotlin 리시버 람다(Receiver Lambda) 정리
&lt;/h1>&lt;p>Kotlin에서는 람다 표현식을 한 단계 더 확장하여, &lt;strong>리시버(수신자)를 가지는 람다&lt;/strong>를 정의할 수 있습니다. 이것을 &lt;strong>리시버 람다(Receiver Lambda)&lt;/strong> 또는 &lt;strong>확장 람다(Extension Lambda)&lt;/strong> 라고 하며, Kotlin DSL, 코루틴, 빌더 패턴 등에 자주 사용됩니다.&lt;/p>
&lt;hr>
&lt;h2 id="기본-문법">기본 문법
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">ReceiverType&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> ReturnType
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>ReceiverType&lt;/code>: 리시버(수신자)의 타입&lt;/li>
&lt;li>&lt;code>this&lt;/code>는 리시버를 가리킴&lt;/li>
&lt;li>리시버의 멤버에 직접 접근 가능 (&lt;code>this.&lt;/code> 생략 가능)&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="예제-string---unit">예제: String.() -&amp;gt; Unit
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> printLength: &lt;span style="color:#a6e22e">String&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit = {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;[리시버] 길이 = &lt;/span>&lt;span style="color:#e6db74">${this.length}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>.printLength() &lt;span style="color:#75715e">// 출력: [리시버] 길이 = 5
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>위에서 &lt;code>this&lt;/code>는 &lt;code>&amp;quot;Hello&amp;quot;&lt;/code> 문자열&lt;/li>
&lt;li>리시버 타입은 &lt;code>String&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="일반-람다-vs-리시버-람다">일반 람다 vs 리시버 람다
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>형태&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>() -&amp;gt; Unit&lt;/code>&lt;/td>
&lt;td>일반 람다. 외부에서 전달받는 값만 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>String.() -&amp;gt; Unit&lt;/code>&lt;/td>
&lt;td>&lt;code>String&lt;/code>을 리시버로 사용. 내부에서 &lt;code>this.length&lt;/code> 등 사용 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="실전-예시-1-apply-">실전 예시 1: &lt;code>apply {}&lt;/code>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">data&lt;/span> &lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">User&lt;/span>(&lt;span style="color:#66d9ef">var&lt;/span> name: String, &lt;span style="color:#66d9ef">var&lt;/span> age: Int)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> user = User(&lt;span style="color:#e6db74">&amp;#34;Tom&amp;#34;&lt;/span>, &lt;span style="color:#ae81ff">30&lt;/span>).apply {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> name = &lt;span style="color:#e6db74">&amp;#34;Jerry&amp;#34;&lt;/span> &lt;span style="color:#75715e">// this.name 으로도 가능
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> age = &lt;span style="color:#ae81ff">25&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>apply&lt;/code>는 &lt;code>T.apply(block: T.() -&amp;gt; Unit)&lt;/code>으로 선언되어 있음&lt;/li>
&lt;li>내부에서 &lt;code>this&lt;/code>는 &lt;code>User&lt;/code>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h2 id="실전-예시-2-코루틴-runblocking-">실전 예시 2: 코루틴 &lt;code>runBlocking {}&lt;/code>
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">runBlocking&lt;/span>(block: &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T): T
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>block&lt;/code>은 &lt;code>CoroutineScope&lt;/code>를 리시버로 갖는 suspend 람다&lt;/li>
&lt;li>내부에서 &lt;code>launch&lt;/code>, &lt;code>async&lt;/code> 등을 &lt;code>this.&lt;/code> 없이 사용 가능&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { println(&lt;span style="color:#e6db74">&amp;#34;Hi from coroutine&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h2 id="리시버-람다의-장점">리시버 람다의 장점
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>장점&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>DSL 작성에 유리&lt;/td>
&lt;td>&lt;code>this&lt;/code> 생략 가능. 직관적인 문법 제공&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>컨텍스트 스코프 제공&lt;/td>
&lt;td>내부에서 특정 타입의 기능을 자연스럽게 활용 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Kotlin 특유의 선언형 스타일 표현 가능&lt;/td>
&lt;td>&lt;code>apply&lt;/code>, &lt;code>with&lt;/code>, &lt;code>run&lt;/code>, &lt;code>build.gradle.kts&lt;/code> 등에서 사용됨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h2 id="요약-정리">요약 정리
&lt;/h2>&lt;ul>
&lt;li>&lt;code>Receiver.() -&amp;gt; T&lt;/code>는 &lt;strong>리시버를 갖는 람다 타입&lt;/strong>&lt;/li>
&lt;li>내부에서 &lt;code>this&lt;/code>는 리시버 객체를 가리킴&lt;/li>
&lt;li>&lt;code>apply&lt;/code>, &lt;code>runBlocking&lt;/code>, &lt;code>withContext&lt;/code> 등에서 사용됨&lt;/li>
&lt;/ul>
&lt;p>리시버 람다는 Kotlin DSL, 구조화된 코루틴, 빌더 패턴 등을 가능하게 하는 핵심적인 언어 기능입니다. Kotlin의 선언형 프로그래밍 스타일을 이해하려면 &lt;strong>리시버 람다의 개념을 정확히 이해하는 것이 매우 중요&lt;/strong>합니다.&lt;/p>
&lt;hr>
&lt;h2 id="참고-자료">참고 자료
&lt;/h2>&lt;ul>
&lt;li>Kotlin 공식 문서: &lt;a class="link" href="https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver" target="_blank" rel="noopener"
>https://kotlinlang.org/docs/lambdas.html#function-literals-with-receiver&lt;/a>&lt;/li>
&lt;li>Kotlin 표준 라이브러리 예시: &lt;code>apply&lt;/code>, &lt;code>run&lt;/code>, &lt;code>with&lt;/code>&lt;/li>
&lt;li>JetBrains Kotlin 슬라이드: DSL 만들기&lt;/li>
&lt;/ul></description></item><item><title>익명 함수란? (anonymous function)</title><link>https://jaemin-baek.github.io/post/kotlinanonymousfunction/</link><pubDate>Tue, 11 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlinanonymousfunction/</guid><description>&lt;h1 id="1-익명-함수란-anonymous-function">1. 익명 함수란? (anonymous function)
&lt;/h1>&lt;blockquote>
&lt;p>이름이 없는 함수&lt;/p>&lt;/blockquote>
&lt;p>보통 우리가 쓰는 함수는 이름이 있는 함수입니다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sayHello&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 어떤 함수는 이름 없이도 쓸 수 있습니다. 이것이 익명 함수예요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이렇게 쓰면 이름이 없기 때문에 이 자체로는 실행이 안 되고, 변수에 담아서 써야 합니다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> greet = &lt;span style="color:#66d9ef">fun&lt;/span>() { println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>) }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>greet() &lt;span style="color:#75715e">// Hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h1 id="2-그럼-람다-표현식은-뭐가-다르냐">2. 그럼 람다 표현식은 뭐가 다르냐?
&lt;/h1>&lt;p>람다 표현식은 익명 함수를 더 간결하게 쓰는 문법이에요.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> greet = { println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>) } &lt;span style="color:#75715e">// 람다 표현식
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>greet() &lt;span style="color:#75715e">// Hello
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, fun() {} 을 {}로 바꾼 것!&lt;/p>
&lt;h1 id="3-함수를-값처럼-다룬다는-무슨-뜻">3. &amp;ldquo;함수를 값처럼 다룬다&amp;quot;는 무슨 뜻?
&lt;/h1>&lt;p>이 말이 중요한데요. 함수도 변수에 넣고, 다른 함수에 넘기고, 리턴할 수도 있다는 뜻입니다.&lt;/p>
&lt;p>예를 들어&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> add = { a: Int, b: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> a + b } &lt;span style="color:#75715e">// 함수처럼 생긴 값을 변수에 저장
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(x: Int, y: Int, op: (Int, Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> op(x, y) &lt;span style="color:#75715e">// 함수(값)를 받아서 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result = calculate(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">5&lt;/span>, add) &lt;span style="color:#75715e">// 함수 자체를 넘김!
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(result) &lt;span style="color:#75715e">// 8
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 add는 함수지만 값처럼 변수에 담겨 다뤄졌고&lt;/p>
&lt;p>calculate는 함수 하나를 인자로 받아서 실행했죠&lt;/p>
&lt;p>이게 바로 &amp;ldquo;함수를 값처럼 다룰 수 있다&amp;rdquo; 는 뜻이에요.
함수를 변수처럼 사용 → 함수형 프로그래밍의 핵심입니다.&lt;/p></description></item><item><title>Kotlin 문법 정리: Expression Body Function</title><link>https://jaemin-baek.github.io/post/kotlinexpressionbodyfunction/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlinexpressionbodyfunction/</guid><description>&lt;h1 id="kotlin-함수-문법-요약">Kotlin 함수 문법 요약
&lt;/h1>&lt;h2 id="식-본문-함수-expression-body-function">식 본문 함수 (Expression Body Function)
&lt;/h2>&lt;p>함수 본문이 단일 표현식일 경우, 중괄호 없이 &lt;code>=&lt;/code> 로 정의할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int, b: Int) = a + b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>return 키워드를 명시하지 않아도 자동 반환됩니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>함수의 결과가 단일 식(expression)일 때 사용됩니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>간결한 함수 작성에 유리하며, 특히 getters, utility functions, single-line transformations 등에서 자주 활용됩니다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="단일-표현식이란">단일 표현식이란?
&lt;/h3>&lt;p>하나의 결과값을 내는 하나의 명령 또는 계산식
즉, return 없이도 값을 만들어내는 단 하나의 식(expression) 을 말합니다.&lt;/p>
&lt;h4 id="예-단일-표현식-o">예: 단일 표현식 (O)
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int, b: Int) = a + b
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>a + b는 하나의 식이고, **하나의 값(Int)**을 만듭니다.&lt;/p>
&lt;p>그래서 = 오른쪽만 보고도 반환값이 명확함&lt;/p>
&lt;h4 id="예-단일-표현식-아님-x">예: 단일 표현식 아님 (X)
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int, b: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> sum = a + b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(sum)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기에는 **여러 문장(statements)**이 있고&lt;/p>
&lt;p>val, println, return 등 복합적인 흐름이 존재하므로 → 단일 표현식이 아님&lt;/p>
&lt;h3 id="블록-본문-함수와-비교">블록 본문 함수와 비교
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">add&lt;/span>(a: Int, b: Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> a + b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>블록 본문 함수는 여러 줄의 로직을 포함할 수 있어 더 복잡한 처리가 가능합니다.&lt;/p>
&lt;p>반드시 return 키워드를 명시해야 결과를 반환합니다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Syntax&lt;/th>
&lt;th>Name&lt;/th>
&lt;th>Description&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>fun foo() = something&lt;/code>&lt;/td>
&lt;td>Expression Body&lt;/td>
&lt;td>Single expression, return omitted&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>fun foo() { ... }&lt;/code>&lt;/td>
&lt;td>Block Body&lt;/td>
&lt;td>Multiple lines allowed, explicit return&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="expression-body-사용의-이점">Expression Body 사용의 이점
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>가독성 향상: 간단한 함수는 더 읽기 쉬운 형태로 표현됨&lt;/p>
&lt;/li>
&lt;li>
&lt;p>코드 길이 단축: 반복적인 return 문 생략 가능&lt;/p>
&lt;/li>
&lt;li>
&lt;p>함수형 스타일 지향: Kotlin의 함수형 프로그래밍 특징과 잘 어울림&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> square: (Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Int = { &lt;span style="color:#66d9ef">it&lt;/span> * &lt;span style="color:#66d9ef">it&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">isEven&lt;/span>(n: Int) = n % &lt;span style="color:#ae81ff">2&lt;/span> &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">greet&lt;/span>(name: String) = &lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$name&lt;/span>&lt;span style="color:#e6db74">!&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="주의할-점">주의할 점
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>여러 줄 로직에는 적합하지 않음 → 블록 본문을 사용해야 가독성 유지&lt;/p>
&lt;/li>
&lt;li>
&lt;p>반환 타입이 명확하지 않을 경우, 타입 추론이 어려워질 수 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="나쁜-예">나쁜 예)
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">risky&lt;/span>() = &lt;span style="color:#66d9ef">if&lt;/span> (someCondition) &lt;span style="color:#e6db74">&amp;#34;yes&amp;#34;&lt;/span> &lt;span style="color:#66d9ef">else&lt;/span> &lt;span style="color:#66d9ef">null&lt;/span> &lt;span style="color:#75715e">// 타입 명시가 더 안전할 수 있음
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="좋은-예">좋은 예)
&lt;/h4>&lt;p>모델 객체의 getter&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> fullName: String
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">get&lt;/span>() = &lt;span style="color:#e6db74">&amp;#34;&lt;/span>&lt;span style="color:#e6db74">$firstName&lt;/span>&lt;span style="color:#e6db74"> &lt;/span>&lt;span style="color:#e6db74">$lastName&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Repository, Service, UseCase 등에서 한 줄로 끝나는 경우&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">findUserById&lt;/span>(id: Int) = userRepository.findById(id)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="결론">결론
&lt;/h3>&lt;p>Expression Body는 Kotlin 코드의 간결함과 가독성을 높이는 강력한 기능입니다. 하지만 남용 시 복잡한 로직이 숨어버릴 수 있으므로, 상황에 맞는 사용이 중요합니다.&lt;/p></description></item><item><title>Kotlin 문법 정리: Lambda Expression</title><link>https://jaemin-baek.github.io/post/kotlinlambdaexpression/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlinlambdaexpression/</guid><description>&lt;h1 id="람다-표현식-lambda-expression">람다 표현식 (Lambda Expression)
&lt;/h1>&lt;h2 id="정의">정의
&lt;/h2>&lt;p>람다 표현식은 익명 함수(anonymous function)를 간결하게 표현한 것으로, 함수를 값처럼 다룰 수 있도록 해줍니다.
코틀린에서는 중괄호 {}를 사용하여 정의하며, 변수에 할당하거나 함수 인자로 넘기는 등 일급 시민(first-class citizen) 으로 취급됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> square = { x: Int &lt;span style="color:#f92672">-&amp;gt;&lt;/span> x * x }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(square(&lt;span style="color:#ae81ff">4&lt;/span>)) &lt;span style="color:#75715e">// 16
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="람다-표현식의-철학">람다 표현식의 철학
&lt;/h2>&lt;p>람다는 단순히 &amp;ldquo;짧게 쓰는 함수&amp;quot;가 아닙니다. 함수형 프로그래밍의 핵심 철학, 즉 동작을 데이터처럼 다룰 수 있는 능력을 나타냅니다.&lt;/p>
&lt;p>람다를 사용하면, 코드의 흐름을 제어하거나 설계를 바꾸지 않고도 기능을 전달할 수 있습니다.
이것은 OOP의 상속과 다형성보다 더 유연한 전략을 제공하며, 전략 패턴의 대체물로도 활용될 수 있습니다.&lt;/p>
&lt;blockquote>
&lt;p>&amp;ldquo;인터페이스를 따로 만들 필요 없이, 곧바로 행동을 전달할 수 있는 능력.&amp;rdquo; — 이것이 람다의 본질적인 힘입니다.&lt;/p>&lt;/blockquote>
&lt;p>코틀린은 람다를 통해 다음과 같은 설계 철학을 구현합니다:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>간결성: 최소한의 문법으로 최대한의 표현&lt;/p>
&lt;/li>
&lt;li>
&lt;p>표현력: 이름 없는 함수로도 충분히 의미 전달 가능&lt;/p>
&lt;/li>
&lt;li>
&lt;p>조합 가능성: 고차 함수와 조합하여 유연한 API 구성 가능&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>불- 변성 강조: 상태 없는 함수형 스타일 지향&lt;/p>
&lt;h2 id="문법-구조">문법 구조
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> 이름: (입력타입) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 출력타입 = { 매개변수 &lt;span style="color:#f92672">-&amp;gt;&lt;/span> 본문 }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="예">예
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> greet: (String) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> String = { name &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$name&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> greet = { name: String &lt;span style="color:#f92672">-&amp;gt;&lt;/span> &lt;span style="color:#e6db74">&amp;#34;Hello, &lt;/span>&lt;span style="color:#e6db74">$name&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span> }
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="고차-함수와-함께-쓰기">고차 함수와 함께 쓰기
&lt;/h2>&lt;p>람다의 가장 강력한 점은 고차 함수(Higher-Order Function) 와 함께 쓸 때 드러납니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">calculate&lt;/span>(x: Int, y: Int, op: (Int, Int) &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Int): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> op(x, y)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> sum = calculate(&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>) { a, b &lt;span style="color:#f92672">-&amp;gt;&lt;/span> a + b } &lt;span style="color:#75715e">// 7
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 코드는 calculate 함수의 동작을 람다로 주입합니다. 이는 전략 패턴을 코드 수준에서 자연스럽게 표현하는 방식입니다&lt;/p>
&lt;h2 id="실무에서의-활용">실무에서의 활용
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>컬렉션 처리: map, filter, reduce&lt;/p>
&lt;/li>
&lt;li>
&lt;p>UI 이벤트 처리: setOnClickListener { &amp;hellip; }&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DSL 구성 요소: apply, with, build.gradle.kts&lt;/p>
&lt;/li>
&lt;li>
&lt;p>비동기 콜백: Retrofit, Coroutine Scope 내부 처리 등&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="주의할-점">주의할 점
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>람다 캡처 비용: 외부 변수 캡처 시, 메모리 비용 및 예기치 않은 참조 유지에 주의&lt;/p>
&lt;/li>
&lt;li>
&lt;p>남용 금지: 람다로 모든 걸 처리하려 하면 오히려 가독성 하락&lt;/p>
&lt;/li>
&lt;li>
&lt;p>타입 명시 생략의 위험: IDE가 추론하더라도 명시가 더 명확할 때가 있음&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="요약">요약
&lt;/h2>&lt;p>람다 표현식은 단순한 문법 편의성을 넘어, 행위를 코드로 캡슐화하는 도구입니다.&lt;/p>
&lt;p>코드를 데이터처럼 다루는 함수형 사고방식은 선언형 프로그래밍, 조합 가능성 높은 API, 의존성 분리, 상태 최소화 등 현대 소프트웨어 설계에서 매우 중요한 가치를 담고 있습니다.&lt;/p>
&lt;p>람다는 읽기 쉽고, 전달 가능하고, 테스트하기 좋은 코드를 설계할 수 있는 핵심 도구입니다.&lt;/p>
&lt;p>적절한 곳에 사용하는 람다는 코드 품질을 한 단계 끌어올리는 열쇠가 됩니다.&lt;/p></description></item><item><title>Kotlin 문법 정리: Trailing Lambda Syntax</title><link>https://jaemin-baek.github.io/post/kotlintrailinglambdasyntax/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/kotlintrailinglambdasyntax/</guid><description>&lt;h1 id="트레일링-람다-문법-trailing-lambda-syntax">트레일링 람다 문법 (Trailing Lambda Syntax)
&lt;/h1>&lt;h2 id="정의">정의
&lt;/h2>&lt;p>트레일링 람다(Trailing Lambda)는 함수의 마지막 파라미터가 람다(lambda expression)일 경우,
해당 람다를 함수 호출 괄호 () 밖으로 빼서 더 읽기 쉬운 형태로 표현하는 코틀린의 문법입니다.&lt;/p>
&lt;p>이 문법은 코드의 명확성, 선언적 스타일, 그리고 함수형 프로그래밍 철학에 기반한 Kotlin의 설계 철학을 잘 보여줍니다.&lt;/p>
&lt;h2 id="기본-예제">기본 예제
&lt;/h2>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">doSomething&lt;/span>(action: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> action()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 일반적인 호출
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>doSomething({ println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>) })
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// 트레일링 람다 사용
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>doSomething {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 두 코드는 동일한 동작을 하지만, 두 번째 예시는 람다 블록의 의도를 더 명확히 드러냅니다.&lt;/p>
&lt;h2 id="왜-필요한가-코틀린-철학적-배경">왜 필요한가? (코틀린 철학적 배경)
&lt;/h2>&lt;p>Kotlin은 간결성(conciseness), 표현력(expressiveness), 그리고 안전성(safety)을 중시하는 언어입니다.&lt;/p>
&lt;h3 id="트레일링-람다는-이런-철학을-다음과-같은-방식으로-실현합니다">트레일링 람다는 이런 철학을 다음과 같은 방식으로 실현합니다:
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>의도를 드러내는 코드: 마지막 인자가 람다인 경우, 괄호 밖으로 빼는 것이 람다의 &amp;ldquo;중심적 역할&amp;quot;을 강조함&lt;/p>
&lt;/li>
&lt;li>
&lt;p>읽기 쉬운 DSL 스타일: apply, run, with, build.gradle.kts 같은 DSL에서 직관적인 문법 제공&lt;/p>
&lt;/li>
&lt;li>
&lt;p>콜백 기반 함수의 가독성 향상: 네트워크 요청, 버튼 클릭, 파일 처리 등에서 콜백이 많을 때 유리함&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="실제-활용-예시">실제 활용 예시
&lt;/h2>&lt;h3 id="1-코루틴에서">1. 코루틴에서
&lt;/h3>&lt;ul>
&lt;li>
&lt;ol>
&lt;li>코루틴에서&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Hello from coroutine&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;ol start="2">
&lt;li>컬렉션 처리에서&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> list = listOf(&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, &lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>list.forEach {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#66d9ef">it&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;ol start="3">
&lt;li>UI 콜백에서 (Android 기준)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>button.setOnClickListener {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">Toast&lt;/span>.makeText(context, &lt;span style="color:#e6db74">&amp;#34;Clicked&amp;#34;&lt;/span>, &lt;span style="color:#a6e22e">Toast&lt;/span>.LENGTH_SHORT).show()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="주의할-점">주의할 점
&lt;/h2>&lt;ul>
&lt;li>
&lt;p>람다가 마지막 인자일 때만 트레일링 람다 문법 사용 가능&lt;/p>
&lt;/li>
&lt;li>
&lt;p>람다가 유일한 인자라면 () 생략 가능:&lt;/p>
&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 가능
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>하지만 중간에 람다가 오면 절대 밖으로 뺄 수 없음:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(a: Int, action: () &lt;span style="color:#f92672">-&amp;gt;&lt;/span> Unit)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo(&lt;span style="color:#ae81ff">1&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 가능 (람다가 마지막)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>foo({ &lt;span style="color:#f92672">..&lt;/span>. }, &lt;span style="color:#ae81ff">1&lt;/span>) &lt;span style="color:#75715e">// ❌ 불가능
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="결론">결론
&lt;/h2>&lt;p>트레일링 람다는 단순한 문법 이상의 의미를 가집니다. Kotlin이 추구하는 명료한 코드, 함수형 프로그래밍, 선언형 DSL 작성을 가능하게 해주는 강력한 문법 도구이며, 코드를 읽는 사람의 관점에서 쓰는 코드를 지향합니다.&lt;/p>
&lt;p>적절한 상황에서 트레일링 람다를 활용하면, 코드가 더 직관적이고 우아해질 수 있습니다.&lt;/p></description></item><item><title>코루틴 장점1: 코루틴은 일시 중단과 재개가 가능한 함수</title><link>https://jaemin-baek.github.io/post/coroutine1/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutine1/</guid><description>&lt;h2 id="코루틴은-일시-중단과-재개가-가능한-함수">코루틴은 일시 중단과 재개가 가능한 함수
&lt;/h2>&lt;p>코틀린에서는 &lt;strong>일시 중단&lt;/strong>을 suspend 라는 키워드로 표현합니다.&lt;/p>
&lt;p>suspend는 &lt;strong>이 함수는 중단(suspend)될 수 있다&lt;/strong>는 의미이죠&lt;/p>
&lt;p>즉, 함수가 실행 도중 잠시 멈췄다가 나중에 이어서 다시 실행될 수 있음을 나타냅니다.&lt;/p>
&lt;p>이런 함수는 코루틴 안에서만 호출할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchUserData&lt;/span>(): User {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>) &lt;span style="color:#75715e">// 1초 일시 중단 (non-blocking)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> &lt;span style="color:#66d9ef">return&lt;/span> User(&lt;span style="color:#e6db74">&amp;#34;jaemin&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>여기서 delay(1000)은 현재 실행 중인 스레드를 막지 않고 (코루틴을 실행하고 있던 스레드를 블로킹하지 않고)
1초 동안 코루틴만 일시 중단합니다.&lt;/p>
&lt;p>이게 코루틴의 핵심 장점이죠 — 효율적이고 가벼운 비동기 처리.&lt;/p>
&lt;p>suspend 함수는 코루틴 컨텍스트 안에서만 실행 가능합니다.
즉, 코루틴 블록 안에서만 호출 가능하죠&lt;/p>
&lt;p>일반 함수는 실행을 시작하면 → 끝날 때까지 쭉 실행됨.
→ 중간에 멈추거나 재개하는 기능 없음&lt;/p>
&lt;p>suspend 함수는 실행 중 &amp;ldquo;중단&amp;quot;했다가 &amp;ldquo;재개&amp;quot;할 수 있음
→ 이게 코루틴의 핵심 기능&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> kotlinx.coroutines.*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;🕒 코루틴 A: 작업 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">2000&lt;/span>) &lt;span style="color:#75715e">// 여기서 중단됨 (2초 동안 멈춤)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;✅ 코루틴 A: 작업 완료&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;💡 코루틴 B: 작업 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(&lt;span style="color:#ae81ff">5&lt;/span>) { i &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;💡 코루틴 B: &lt;/span>&lt;span style="color:#e6db74">$i&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">400&lt;/span>) &lt;span style="color:#75715e">// 반복하면서 작업함
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;💡 코루틴 B: 작업 완료&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>1 → 2 → 3 한 번에 실행됨. 멈추거나 나중에 이어서 실행 못함&lt;/p>
&lt;p>suspend 함수 (코루틴)
중간에 멈출 수 있음&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">helloSuspend&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;1&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>) &lt;span style="color:#75715e">// 💡 여기서 중단됨! (다른 일 가능)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;2&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 💡 1초 후에 여기서 다시 이어서 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="왜-일반-함수는-중단재개-안-되나">왜 일반 함수는 중단/재개 안 되나?
&lt;/h3>&lt;p>일반 함수는 JVM 바이트코드 수준에서 스택 기반으로 한 번에 실행되도록 설계됨.&lt;/p>
&lt;p>반면 suspend 함수는 컴파일 시 내부적으로 Continuation이라는 상태 저장 구조로 변환됨.
즉, **“지금 어디까지 실행했는지 기억하는 설계”**가 적용되는 것.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;🅰️ A 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">2000&lt;/span>) &lt;span style="color:#75715e">// ← 여기서 코루틴 A는 &amp;#34;suspend&amp;#34; = 대기 상태로 빠짐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(&lt;span style="color:#e6db74">&amp;#34;🅰️ A 끝&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(&lt;span style="color:#ae81ff">5&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;🅱️ B: &lt;/span>&lt;span style="color:#e6db74">$it&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">400&lt;/span>) &lt;span style="color:#75715e">// ← 이것도 suspend 지점
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="결과">결과:
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅰️&lt;/span> A 시작: &lt;span style="color:#ae81ff">1747879622324&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">0&lt;/span> at &lt;span style="color:#ae81ff">1747879622329&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">1&lt;/span> at &lt;span style="color:#ae81ff">1747879622735&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">2&lt;/span> at &lt;span style="color:#ae81ff">1747879623140&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">3&lt;/span> at &lt;span style="color:#ae81ff">1747879623545&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">4&lt;/span> at &lt;span style="color:#ae81ff">1747879623947&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅰️&lt;/span> A 끝: &lt;span style="color:#ae81ff">1747879624333&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">5&lt;/span> at &lt;span style="color:#ae81ff">1747879624351&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">6&lt;/span> at &lt;span style="color:#ae81ff">1747879624755&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">7&lt;/span> at &lt;span style="color:#ae81ff">1747879625160&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">8&lt;/span> at &lt;span style="color:#ae81ff">1747879625565&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#960050;background-color:#1e0010">🅱️&lt;/span> B: &lt;span style="color:#ae81ff">9&lt;/span> at &lt;span style="color:#ae81ff">1747879625970&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="실행-흐름">실행 흐름:
&lt;/h4>&lt;p>A는 0ms에 시작해서 → delay(2000) → 2000ms쯤에 다시 실행될 준비 완료&lt;/p>
&lt;p>B는 0ms부터 시작해서 → 400ms 간격으로 반복&lt;/p>
&lt;p>2000ms쯤 되면 B는 5번째나 6번째 반복 중일 텐데&lt;/p>
&lt;p>그 타이밍에 스레드가 A를 재개할 틈이 생기면, A가 다시 실행됩니다&lt;/p>
&lt;h4 id="이게-가능한-이유">이게 가능한 이유:
&lt;/h4>&lt;p>코루틴은 항상 suspend → resume을 반복&lt;/p>
&lt;p>스레드가 놀지 않고 실행 가능한 코루틴에게 계속 작업을 넘김&lt;/p>
&lt;p>시간 순서가 충족되면 → A가 우선순위 없이도 재개됨&lt;/p>
&lt;h2 id="결론">결론:
&lt;/h2>&lt;p>코루틴은 일시 중단(suspend)과 재개(resume)가 가능한 함수로, 비동기 코드를 동기 코드처럼 쉽게 작성하게 해준다&lt;/p></description></item><item><title>코루틴 장점2: 비동기 코드를 동기 코드처럼 쉽게 작성하게 해준다</title><link>https://jaemin-baek.github.io/post/coroutine2/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutine2/</guid><description>&lt;h2 id="비동기-코드를-동기-코드처럼-쉽게-작성하게-해준다">비동기 코드를 동기 코드처럼 쉽게 작성하게 해준다
&lt;/h2>&lt;p>먼저 &amp;ldquo;비동기 코드를 동기처럼&amp;quot;이란 무슨 뜻인가?
비동기 코드는 원래 콜백(callback)이나 이벤트 리스너로 작성되기 때문에,
코드 흐름이 분리되고 복잡해지기 쉬워요.&lt;/p>
&lt;p>하지만 코루틴을 사용하면, 그런 복잡한 구조를 &amp;ldquo;한 줄씩 순차적으로&amp;rdquo; 작성할 수 있어서
마치 일반 함수(=동기 함수)처럼 코드를 짤 수 있다는 뜻이에요.&lt;/p>
&lt;h3 id="예시-1-비동기-코드-콜백-지옥">예시 1: 비동기 코드 (콜백 지옥)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>getUser { user &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getProfile(user.id) { profile &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> getPosts(profile.id) { posts &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;완료: &lt;/span>&lt;span style="color:#e6db74">$posts&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>중첩 콜백이 많아짐 (일명 콜백 헬/지옥)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>코드 흐름이 위→아래로 자연스럽지 않음&lt;/p>
&lt;/li>
&lt;li>
&lt;p>예외 처리도 복잡&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="예시-2-코루틴-사용-동기처럼-보임">예시 2: 코루틴 사용 (동기처럼 보임)
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchAll&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> user = getUser()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> profile = getProfile(user.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> posts = getPosts(profile.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;완료: &lt;/span>&lt;span style="color:#e6db74">$posts&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>마치 동기 함수처럼 보이죠?&lt;/p>
&lt;p>하지만 실제로는 getUser, getProfile, getPosts는 각각 suspend 함수이고&lt;/p>
&lt;p>내부적으로는 중단과 재개가 발생하지만, 작성 방식은 순차적이고 간단&lt;/p>
&lt;h3 id="그런데-suspend-fun-fetchall이-아니라-그냥-일반-함수라면">그런데, suspend fun fetchAll()이 아니라, 그냥 일반 함수라면?
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchAll&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> user = getUser()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> profile = getProfile(user.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> posts = getPosts(profile.id)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;완료: &lt;/span>&lt;span style="color:#e6db74">$posts&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이럴 경우 어떤 문제가 생기냐?
getUser(), getProfile(), getPosts()가 느린 작업이면?&lt;/p>
&lt;h4 id="예">예:
&lt;/h4>&lt;ul>
&lt;li>서버에서 사용자 정보를 가져옴 (HTTP 요청)&lt;/li>
&lt;li>디스크에서 파일을 읽음&lt;/li>
&lt;li>DB에서 조회&lt;/li>
&lt;/ul>
&lt;blockquote>
&lt;p>일반 함수에서는 이런 느린 작업을 하면 스레드를 막게 됨&lt;/p>&lt;/blockquote>
&lt;p>getUser()에서 네트워크 응답을 기다리는 동안 스레드 전체가 블로킹(blocking) 됨&lt;/p>
&lt;p>다른 일을 못 하게되므로 비효율적, 앱 멈춘 것처럼 보임&lt;/p>
&lt;h3 id="다시-말해-한-줄-요약하면">다시 말해 한 줄 요약하면..!
&lt;/h3>&lt;blockquote>
&lt;p>&amp;ldquo;비동기 코드를 동기 코드처럼 쓴다&amp;rdquo; = 비동기의 복잡함을 숨기고, 자연스러운 코드 흐름을 만든다.&lt;/p>&lt;/blockquote></description></item><item><title>주요 코루틴 라이브러리 모듈 종류</title><link>https://jaemin-baek.github.io/post/coroutinelib/</link><pubDate>Sun, 09 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinelib/</guid><description>&lt;h2 id="주요-코루틴-라이브러리-모듈-종류">주요 코루틴 라이브러리 모듈 종류
&lt;/h2>&lt;h3 id="1-공통core">1. 공통(Core)
&lt;/h3>&lt;p>&lt;img src="https://github.com/user-attachments/assets/eb25b970-a573-45eb-ad07-5b9d0436f32e"
loading="lazy"
alt="core-jvm 예시"
>&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>모듈 이름&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-core&lt;/code>&lt;/td>
&lt;td>코루틴의 핵심 기능 (공통 플랫폼)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-core-jvm&lt;/code>&lt;/td>
&lt;td>JVM 플랫폼 전용 코어 기능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-core-js&lt;/code>&lt;/td>
&lt;td>JavaScript 플랫폼 전용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-core-native&lt;/code>&lt;/td>
&lt;td>Kotlin/Native용 (iOS, macOS, Linux 등)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>kotlinx-coroutines-core는 멀티플랫폼 프로젝트에서 expect/actual 구문 기반으로 각 플랫폼별로 구현됩니다.&lt;/p>
&lt;h3 id="2-추가-플랫폼별-지원-모듈">2. 추가 플랫폼별 지원 모듈
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>모듈 이름&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-android&lt;/code>&lt;/td>
&lt;td>Android에 최적화된 Dispatcher (&lt;code>Dispatchers.Main&lt;/code>) 등 포함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-javafx&lt;/code>&lt;/td>
&lt;td>JavaFX에서 UI 업데이트를 위한 Dispatcher 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-swing&lt;/code>&lt;/td>
&lt;td>Swing 앱을 위한 Dispatcher&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-test&lt;/code>&lt;/td>
&lt;td>테스트 환경에서의 코루틴 제어 (가상 시간, 테스트 디스패처 등)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-debug&lt;/code>&lt;/td>
&lt;td>코루틴 디버깅을 위한 도구 (&lt;code>DebugProbes&lt;/code>, Stack trace 확장 등)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="3-지원부가기능-모듈">3. 지원/부가기능 모듈
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>모듈 이름&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-reactive&lt;/code>&lt;/td>
&lt;td>Reactive Streams (&lt;code>Publisher&lt;/code>, &lt;code>Subscriber&lt;/code>) 호환 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-rx2&lt;/code> / &lt;code>rx3&lt;/code>&lt;/td>
&lt;td>RxJava2, RxJava3 연동용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-guava&lt;/code>&lt;/td>
&lt;td>Google Guava의 &lt;code>ListenableFuture&lt;/code> 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-jdk8&lt;/code>&lt;/td>
&lt;td>&lt;code>CompletableFuture&lt;/code>, &lt;code>java.time&lt;/code> 지원&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>kotlinx-coroutines-jdk9&lt;/code>&lt;/td>
&lt;td>&lt;code>Flow.Publisher&lt;/code> 등 Java 9 API 통합용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="gradle-예시">Gradle 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// 공통
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// Android UI용
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> testImplementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// 테스트용
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>거의 모든 Kotlin 코루틴 기반 프로젝트에서 kotlinx-coroutines-core 모듈은 필수입니다.&lt;/p>
&lt;hr>
&lt;h2 id="왜-항상-core가-필요할까">왜 항상 core가 필요할까?
&lt;/h2>&lt;p>kotlinx-coroutines-core는 다음을 포함합니다:&lt;/p>
&lt;ul>
&lt;li>launch, async, runBlocking, withContext 같은 핵심 함수&lt;/li>
&lt;li>Job, Deferred, Dispatcher 같은 기본 타입&lt;/li>
&lt;li>flow {} 등 Flow API의 기반&lt;/li>
&lt;/ul>
&lt;p>CoroutineScope, suspend 기반의 구조적 동시성 도구&lt;/p>
&lt;p>이 모든 것들이 코루틴 기능의 중심축(core) 역할을 하므로, 다른 모듈(android, test, rx, guava 등)은 전부 core에 의존하거나 core 위에 얹혀 있습니다.&lt;/p>
&lt;h3 id="모듈-간-관계-예시">모듈 간 관계 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>kotlinx&lt;span style="color:#f92672">-&lt;/span>coroutines&lt;span style="color:#f92672">-&lt;/span>android
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">└─&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> kotlinx&lt;span style="color:#f92672">-&lt;/span>coroutines&lt;span style="color:#f92672">-&lt;/span>core
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>kotlinx&lt;span style="color:#f92672">-&lt;/span>coroutines&lt;span style="color:#f92672">-&lt;/span>test
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#960050;background-color:#1e0010">└─&lt;/span>&lt;span style="color:#f92672">&amp;gt;&lt;/span> kotlinx&lt;span style="color:#f92672">-&lt;/span>coroutines&lt;span style="color:#f92672">-&lt;/span>core
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, android나 test만 추가해도 내부적으로는 core가 함께 로딩됩니다.
하지만 직접 core를 명시하는 것이 버전 충돌 방지나 멀티플랫폼 세팅 시 더 안정적입니다.&lt;/p>
&lt;h3 id="예외적으로-core를-직접-추가하지-않아도-되는-경우">예외적으로 core를 직접 추가하지 않아도 되는 경우?
&lt;/h3>&lt;ul>
&lt;li>
&lt;p>kotlinx-coroutines-android만 사용하고 있고, 그 모듈이 core를 이미 의존하고 있는 경우
→ 빌드는 되지만 명시적으로 core 추가하는 걸 권장합니다.&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Ktor, Retrofit 등 외부 라이브러리가 내부적으로 코루틴을 쓰고 있음
→ 이 경우에도 core가 이미 transitively 포함되긴 하지만 명확성을 위해 명시하는 게 좋습니다.&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>kotlinx-coroutines-android나 kotlinx-coroutines-test만 추가하고, core를 명시하지 않으면&lt;/p>
&lt;p>Gradle이 각 모듈이 자체적으로 의존하고 있는 core 버전을 가져와서 버전 충돌이 발생하거나, 프로젝트 전체에 다른 버전이 적용될 수 있습니다.&lt;/p>
&lt;p>예를 들어, build.gradle이 다음과 같다면&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>testImplementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.4&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>Gradle은 &lt;strong>두 가지 다른 버전의 core&lt;/strong>를 프로젝트에 끌어오게 되며,
이는 다음 문제를 유발할 수 있습니다:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>클래스 중복 (duplicate class)&lt;/p>
&lt;/li>
&lt;li>
&lt;p>버전 mismatch로 인한 런타임 크래시&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Flow, Dispatcher 등이 버전별로 다른 동작&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="서로-core-버전이-다르면-어떤-규칙으로-선택될까">서로 core 버전이 다르면 어떤 규칙으로 선택될까?
&lt;/h3>&lt;p>Kotlin/Gradle 프로젝트에서 서로 다른 버전의 kotlinx-coroutines-core가 의존되는 경우, Gradle은 &amp;ldquo;의존성 해석(dependency resolution)&amp;rdquo; 규칙에 따라 하나의 버전만을 선택하게 됩니다.&lt;/p>
&lt;h2 id="gradle의-기본-규칙-최신-버전-우선">Gradle의 기본 규칙: 최신 버전 우선
&lt;/h2>&lt;blockquote>
&lt;p>&amp;ldquo;같은 그룹과 이름을 가진 라이브러리 중에서, 가장 높은 버전을 사용한다.&amp;rdquo;&lt;/p>&lt;/blockquote>
&lt;h3 id="예시-1">예시 1
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// → core:1.7.3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.4&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// → core:1.6.4
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>kotlinx-coroutines-core:1.6.4, 1.7.3이 모두 간접 의존되지만 Gradle은 더 높은 1.7.3을 자동 선택해서 core로 사용합니다.&lt;/p>
&lt;h3 id="예시-2">예시 2
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.0.0&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// 👈 명시적 (구버전)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// 👉 내부적으로 core:1.7.3 의존
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// 👉 내부적으로 core:1.7.3 의존
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>kotlinx-coroutines-core:1.7.3이 선택됩니다 (🚫 1.0.0 아님)&lt;/p>
&lt;ul>
&lt;li>kotlinx-coroutines-android:1.7.3는 내부적으로 kotlinx-coroutines-core:1.7.3에 의존&lt;/li>
&lt;li>kotlinx-coroutines-test:1.7.3도 마찬가지로 core:1.7.3 의존&lt;/li>
&lt;li>core:1.0.0을 명시적으로 선언했지만, Gradle은 모든 버전 후보를 수집한 뒤 가장 높은 버전(1.7.3)을 선택&lt;/li>
&lt;/ul>
&lt;h3 id="해결-방법-버전-통일">해결 방법: 버전 통일
&lt;/h3>&lt;p>항상 kotlinx-coroutines-core를 명시적으로 추가하고, 다른 모듈도 동일한 버전을 사용&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>val coroutinesVersion &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#34;1.7.3&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-core:$coroutinesVersion&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutinesVersion&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> testImplementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:$coroutinesVersion&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="테스트">테스트
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-gradle" data-lang="gradle">&lt;span style="display:flex;">&lt;span>dependencies &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.7.3&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// → core:1.7.3
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> implementation&lt;span style="color:#f92672">(&lt;/span>&lt;span style="color:#e6db74">&amp;#34;org.jetbrains.kotlinx:kotlinx-coroutines-test:1.6.4&amp;#34;&lt;/span>&lt;span style="color:#f92672">)&lt;/span> &lt;span style="color:#75715e">// → core:1.6.4
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;pre tabindex="0">&lt;code>./gradlew dependencies --configuration runtimeClasspath
&lt;/code>&lt;/pre>&lt;h3 id="결과">결과
&lt;/h3>&lt;p>kotlinx-coroutines-test 가 1.6.4 가 아닌 1.7.3 을 사용하는것으로 나온다.&lt;/p>
&lt;p>&lt;img src="https://github.com/user-attachments/assets/469c29bb-f566-453f-aebd-08e813ef21ae"
loading="lazy"
alt="Image"
>&lt;/p></description></item><item><title>GlobalScope는 왜 위험한가? 구조적 동시성 관점에서의 설명과 대안</title><link>https://jaemin-baek.github.io/post/coroutineglobalscope/</link><pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutineglobalscope/</guid><description>&lt;h2 id="globalscope는-왜-위험한가">GlobalScope는 왜 위험한가?
&lt;/h2>&lt;p>구조적 동시성 관점에서의 설명과 대안&lt;/p>
&lt;p>Kotlin에서는 &lt;code>GlobalScope.launch&lt;/code>를 통해 간단하게 코루틴을 실행할 수 있다.&lt;br>
하지만 아무 생각 없이 GlobalScope를 사용하는 것은 &lt;strong>구조적 동시성 원칙을 깨뜨리고&lt;/strong>,&lt;br>
비동기 코드의 안정성과 예측 가능성을 크게 해친다.&lt;/p>
&lt;hr>
&lt;h3 id="문제-코드-예시">문제 코드 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GlobalScope&lt;/span>.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 이 코루틴은 언제 끝날지 아무도 모름
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>fetchData()&lt;/code>는 &lt;code>launch&lt;/code>의 결과(Job)를 반환하지 않음&lt;/li>
&lt;li>&lt;code>GlobalScope&lt;/code>는 앱 전체 생명주기에 묶임&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="호출한-쪽-입장에서-생기는-문제">호출한 쪽 입장에서 생기는 문제
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>문제 내용&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>종료 시점 추적 불가&lt;/td>
&lt;td>호출한 쪽에서는 이 코루틴이 언제 끝날지 알 수 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>취소 불가&lt;/td>
&lt;td>&lt;code>Job&lt;/code>을 반환하지 않으므로 &lt;code>cancel()&lt;/code> 호출도 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 처리 어려움&lt;/td>
&lt;td>예외가 외부로 전파되지 않음. &lt;code>try-catch&lt;/code>도 못함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>테스트 어려움&lt;/td>
&lt;td>완료 시점 제어 불가 → 유닛 테스트 작성 어려움&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 누수 가능성&lt;/td>
&lt;td>생명주기를 갖지 않으므로 메모리 누수 위험&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;blockquote>
&lt;p>즉, &lt;strong>&lt;code>fetchData()&lt;/code>를 호출한 입장에서 이 코루틴은 &amp;lsquo;제어 불가능한 유령&amp;rsquo;과 같다.&lt;/strong>&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h3 id="왜-구조적-동시성과-충돌하는가">왜 구조적 동시성과 충돌하는가?
&lt;/h3>&lt;p>&lt;code>GlobalScope&lt;/code>는 부모 스코프가 없기 때문에 &lt;strong>어떤 스코프와도 생명주기를 공유하지 않는다.&lt;/strong>&lt;br>
이는 구조적 동시성의 핵심 원칙인&lt;/p>
&lt;blockquote>
&lt;p>“부모 스코프가 닫히면 자식 코루틴도 함께 정리된다”&lt;br>
는 규칙을 위반한다.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h3 id="개선-예시-1-스코프-주입-방식">개선 예시 1: 스코프 주입 방식
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>(scope: CoroutineScope): Job {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 안전하게 실행
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>호출하는 쪽에서 &lt;code>scope&lt;/code>를 넘겨주면 생명주기와 연결됨&lt;/li>
&lt;li>반환된 &lt;code>Job&lt;/code>을 통해 &lt;code>cancel()&lt;/code> 호출도 가능&lt;/li>
&lt;li>예외도 추적 가능&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="개선-예시-2-구조적-코루틴-사용">개선 예시 2: 구조적 코루틴 사용
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { &lt;span style="color:#f92672">..&lt;/span>. }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>호출한 쪽에서 &lt;code>suspend&lt;/code> 함수로 사용&lt;/li>
&lt;li>내부 코루틴들이 종료될 때까지 &lt;code>fetchData()&lt;/code>는 자동으로 대기&lt;/li>
&lt;li>예외도 위로 전파되어 처리 가능&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="정리-globalscope는-언제-써야-하나">정리: GlobalScope는 언제 써야 하나?
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>상황&lt;/th>
&lt;th>사용 권장 여부&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>일반적인 앱 비동기 작업&lt;/td>
&lt;td>❌ 피해야 함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>백그라운드에서 무기한 감시 (예: 앱 알림, 상태 보고)&lt;/td>
&lt;td>✅ 가능 (주의 필요)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>테스트 가능한 구조가 필요할 때&lt;/td>
&lt;td>❌ 불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>코루틴 생명주기를 제어해야 할 때&lt;/td>
&lt;td>❌ 안 맞음&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="결론">결론
&lt;/h3>&lt;p>&lt;code>GlobalScope&lt;/code>는 강력하지만 위험한 도구다.&lt;br>
단순한 비동기 작업에 GlobalScope를 사용하면,&lt;br>
예외 추적, 자원 해제, 테스트 모두 어려워진다.&lt;/p>
&lt;blockquote>
&lt;p>구조적 동시성을 지키기 위해서는&lt;br>
&lt;strong>코루틴의 생명주기를 관리할 수 있는 스코프&lt;/strong>를 명확히 설계하고,&lt;br>
필요할 경우 &lt;code>Job&lt;/code>을 반환하거나, &lt;code>coroutineScope&lt;/code> 내에서 suspend 함수를 사용하는 것이 권장된다.&lt;/p>&lt;/blockquote></description></item><item><title>구조적 동시성이란 무엇인가? 코루틴의 안정성과 예측 가능성을 위한 원칙</title><link>https://jaemin-baek.github.io/post/coroutinestructuredconcurrency/</link><pubDate>Sat, 08 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinestructuredconcurrency/</guid><description>&lt;h2 id="구조적-동시성이란-무엇인가">구조적 동시성이란 무엇인가?
&lt;/h2>&lt;p>코루틴의 안정성과 예측 가능성을 위한 원칙&lt;/p>
&lt;p>Kotlin의 코루틴 철학에서 가장 핵심적인 개념 중 하나가 바로 **구조적 동시성(Structured Concurrency)**이다.&lt;br>
이 개념은 코루틴이 언제 시작되고 언제 종료되는지를 &lt;strong>코드의 구조(스코프)에 따라 명확하게 보장&lt;/strong>하도록 만든다.&lt;/p>
&lt;hr>
&lt;h3 id="한줄-정의">한줄 정의
&lt;/h3>&lt;blockquote>
&lt;p>**구조적 동시성(Structured Concurrency)**이란&lt;br>
&amp;ldquo;&lt;strong>코루틴의 실행 범위와 생명주기를 코드 구조에 따라 명확하게 관리&lt;/strong>하는 방식&amp;quot;이다.&lt;/p>&lt;/blockquote>
&lt;hr>
&lt;h3 id="왜-필요한가">왜 필요한가?
&lt;/h3>&lt;p>전통적인 비동기 코드에서는 다음과 같은 문제가 자주 발생한다:&lt;/p>
&lt;ul>
&lt;li>콜백 지옥&lt;/li>
&lt;li>예외가 무시됨&lt;/li>
&lt;li>남은 코루틴이 언제 끝날지 알 수 없음&lt;/li>
&lt;li>메모리 누수&lt;/li>
&lt;/ul>
&lt;p>구조적 동시성은 이를 해결한다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>구조적 동시성에서 보장되는 동작&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>코루틴 생명주기&lt;/td>
&lt;td>부모 스코프가 닫히면 자식 코루틴도 종료됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 처리&lt;/td>
&lt;td>자식 예외는 부모로 전파됨 (또는 Supervisor로 분리 처리)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자원 누수 방지&lt;/td>
&lt;td>스코프 바깥에 살아남는 코루틴 없음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>테스트 가능성&lt;/td>
&lt;td>어느 시점에 어떤 작업이 실행 중인지 추론 가능&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="예시-구조적-동시성이-없는-코드">예시: 구조적 동시성이 없는 코드
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">GlobalScope&lt;/span>.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 이 코루틴은 언제 끝날지 아무도 모름
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>GlobalScope&lt;/code>는 앱 전체 생명주기에 묶여 있으므로 정리 불가&lt;/li>
&lt;li>호출한 쪽에서는 &lt;strong>코루틴 취소, 예외 추적 불가능&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="예시-구조적-동시성이-적용된-코드">예시: 구조적 동시성이 적용된 코드
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>() = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { getUser() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { getPosts() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>coroutineScope&lt;/code> 안에서 실행된 모든 코루틴은 이 블록이 끝날 때까지 완료되어야 한다.&lt;/li>
&lt;li>이 블록이 끝난다는 것은 &lt;strong>모든 자식 코루틴이 정상 종료되었음을 보장&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="구조적-동시성의-핵심-규칙">구조적 동시성의 핵심 규칙
&lt;/h3>&lt;ol>
&lt;li>모든 코루틴은 &lt;strong>명확한 부모 스코프&lt;/strong> 내에서 실행된다&lt;/li>
&lt;li>부모가 종료되면 자식 코루틴도 자동으로 취소된다&lt;/li>
&lt;li>예외는 위로 전파되어 일관된 방식으로 처리된다&lt;/li>
&lt;/ol>
&lt;hr>
&lt;h3 id="kotlin이-구조적-동시성을-지원하는-방식">Kotlin이 구조적 동시성을 지원하는 방식
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>역할&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>CoroutineScope&lt;/code>&lt;/td>
&lt;td>생명주기 단위 스코프 정의&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>coroutineScope {}&lt;/code>&lt;/td>
&lt;td>suspend 함수 내부 일시적 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 간 예외 전파 제어&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>withContext&lt;/code>&lt;/td>
&lt;td>부모-자식 관계를 유지한 채 컨텍스트 전환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>viewModelScope&lt;/code>, &lt;code>lifecycleScope&lt;/code>&lt;/td>
&lt;td>Android 앱 생명주기에 연동된 구조적 스코프 제공&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="요약-정리">요약 정리
&lt;/h3>&lt;blockquote>
&lt;p>구조적 동시성은 &lt;strong>코루틴이 언제 시작되고 언제 종료되는지를 명확하게 통제&lt;/strong>할 수 있도록 한다.&lt;br>
이를 통해 개발자는 &lt;strong>예측 가능한 흐름, 자동 정리, 안정적인 에러 전파&lt;/strong>를 기반으로&lt;br>
복잡한 비동기 프로그램을 안전하게 설계할 수 있다.&lt;/p>&lt;/blockquote></description></item><item><title>Kotlin 코루틴에서 에러 처리 제대로 이해하기</title><link>https://jaemin-baek.github.io/post/coroutinejob/</link><pubDate>Thu, 06 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinejob/</guid><description>&lt;h2 id="job의-주요-역할">Job의 주요 역할
&lt;/h2>&lt;h3 id="1-생명주기-추적">1. 생명주기 추적
&lt;/h3>&lt;p>Job은 코루틴이 활성(active) 상태인지, 완료(completed) 되었는지, 취소(cancelled) 되었는지 관리합니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = launch { &lt;span style="color:#f92672">..&lt;/span>. }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>println(job.isActive) &lt;span style="color:#75715e">// true
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(job.isCancelled) &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(job.isCompleted) &lt;span style="color:#75715e">// false
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="2-취소-전파">2. 취소 전파
&lt;/h3>&lt;p>부모 코루틴이 취소되면, 모든 자식 Job도 자동으로 취소됩니다 (구조적 동시성).&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> parent = CoroutineScope(Job())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> child = parent.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child finished&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent.cancel() &lt;span style="color:#75715e">// child도 함께 취소됨
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="3-작업-완료-대기">3. 작업 완료 대기
&lt;/h3>&lt;p>job.join()을 통해 Job이 끝날 때까지 대기할 수 있습니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>job.join() &lt;span style="color:#75715e">// 여기서 기다림
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>println(&lt;span style="color:#e6db74">&amp;#34;After job&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="4-예외-및-오류-처리">4. 예외 및 오류 처리
&lt;/h3>&lt;p>예외 발생 시 Job은 취소 상태로 전환되고, 예외는 부모나 예외 핸들러로 전파됩니다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default).launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> error(&lt;span style="color:#e6db74">&amp;#34;Something went wrong&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>job.invokeOnCompletion { throwable &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Job ended with: &lt;/span>&lt;span style="color:#e6db74">$throwable&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="정리">정리
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>역할&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>생명주기 관리&lt;/td>
&lt;td>코루틴의 실행/완료/취소 상태를 추적함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조적 동시성&lt;/td>
&lt;td>부모-자식 코루틴 관계를 구성하고 취소를 전파함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>동기화&lt;/td>
&lt;td>join() 등을 통해 코루틴이 끝날 때까지 기다릴 수 있음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 추적&lt;/td>
&lt;td>예외 발생 시 취소 상태로 전환되고 예외가 전파됨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table></description></item><item><title>Kotlin 코루틴에서 에러 처리 제대로 이해하기</title><link>https://jaemin-baek.github.io/post/coroutineerror/</link><pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutineerror/</guid><description>&lt;h2 id="kotlin-코루틴에서-에러-처리-제대로-이해하기">Kotlin 코루틴에서 에러 처리 제대로 이해하기
&lt;/h2>&lt;p>코틀린 코루틴은 비동기 코드의 예외 처리 방식을 명확하게 구조화하고 있다.&lt;br>
단순한 &lt;code>try-catch&lt;/code>를 넘어서, &lt;code>Job&lt;/code>, &lt;code>SupervisorJob&lt;/code>, &lt;code>CoroutineExceptionHandler&lt;/code> 등 다양한 메커니즘이 존재하며,&lt;br>
이들은 &lt;strong>구조적 동시성(Structured Concurrency)&lt;/strong> 원칙 하에 작동한다.&lt;br>
이 글에서는 Kotlin 코루틴의 예외 처리 구조를 단계적으로 설명하고, 실전 예제를 통해 이해를 돕고자 한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-코루틴의-예외-처리-기본-try-catch">1. 코루틴의 예외 처리 기본: &lt;code>try-catch&lt;/code>
&lt;/h3>&lt;p>가장 단순한 예외 처리는 &lt;code>try-catch&lt;/code> 블록을 사용하는 것이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> riskySuspendFunction()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;에러 발생: &lt;/span>&lt;span style="color:#e6db74">$e&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>위 코드는 launch 내부에서 발생한 예외를 catch로 처리한다.&lt;/li>
&lt;li>하지만 모든 상황에서 try-catch가 동작하는 것은 아니다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-launch-vs-async의-예외-처리-차이">2. launch vs async의 예외 처리 차이
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>코루틴 빌더&lt;/th>
&lt;th>예외 발생 시 처리 방식&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>launch&lt;/code>&lt;/td>
&lt;td>예외가 즉시 전파됨 → 부모 Job에 전달되거나 &lt;code>CoroutineExceptionHandler&lt;/code>에서 처리됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>async&lt;/code>&lt;/td>
&lt;td>예외가 &lt;code>Deferred&lt;/code>에 저장됨 → &lt;code>await()&lt;/code> 호출 시 예외가 발생함&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default).launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;launch 내부 예외&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 즉시 전파됨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> deferred = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default).async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;async 내부 예외&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 바로 안 터짐
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>deferred.await() &lt;span style="color:#75715e">// 여기서 예외가 발생함
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="3-coroutineexceptionhandler-사용">3. CoroutineExceptionHandler 사용
&lt;/h3>&lt;p>코루틴 전체에 적용되는 전역 예외 처리자 역할을 한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> handler = CoroutineExceptionHandler { _, exception &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;핸들러에서 처리된 예외: &lt;/span>&lt;span style="color:#e6db74">$exception&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + handler)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> IllegalStateException(&lt;span style="color:#e6db74">&amp;#34;예외 발생!&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>CoroutineExceptionHandler는 **launch나 actor와 같은 &amp;lsquo;최상위 코루틴&amp;rsquo;**에서만 작동&lt;/li>
&lt;li>async에는 작동하지 않음 → 예외는 반드시 await()로 수동 처리해야 함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-부모-자식-관계와-예외-전파">4. 부모-자식 관계와 예외 전파
&lt;/h3>&lt;p>일반 Job의 경우:&lt;/p>
&lt;ul>
&lt;li>자식 코루틴이 예외를 던지면 → 부모 Job도 취소됨&lt;/li>
&lt;li>형제 코루틴도 모두 함께 취소됨&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> parent = CoroutineScope(Job())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;자식 예외&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>parent.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;이 코루틴은 취소됨&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>SupervisorJob을 사용할 경우:&lt;/p>
&lt;ul>
&lt;li>자식이 예외를 던져도 부모나 다른 형제에 영향 없음&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;에러 발생&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;이 코루틴은 살아있음&amp;#34;&lt;/span>) &lt;span style="color:#75715e">// 출력됨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="5-실전-패턴-안전한-동시-처리">5. 실전 패턴: 안전한 동시 처리
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">safeParallelExecution&lt;/span>(): Result = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchA() } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) { emptyList() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchB() } &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) { emptyList() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> Result(a.await(), b.await())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>각 작업을 별도 async로 실행&lt;/li>
&lt;li>개별 try-catch로 안전하게 감싸서 전체 실패를 막는다&lt;/li>
&lt;li>coroutineScope는 모든 async가 완료될 때까지 대기&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="6-정리-요약">6. 정리 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>try-catch&lt;/code>&lt;/td>
&lt;td>&lt;code>launch&lt;/code> 내부에서는 직접 사용 가능. &lt;code>async&lt;/code>는 &lt;code>await()&lt;/code> 호출 시 예외 발생하므로 그 시점에서 catch 필요&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CoroutineExceptionHandler&lt;/code>&lt;/td>
&lt;td>&lt;code>launch&lt;/code>, &lt;code>actor&lt;/code> 등 &lt;strong>최상위 코루틴에서 발생한 예외만&lt;/strong> 처리. &lt;code>async&lt;/code>에서는 동작하지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>launch&lt;/code>&lt;/td>
&lt;td>예외가 발생하면 즉시 상위로 전파되며, 부모 Job이나 예외 핸들러가 처리&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>async&lt;/code>&lt;/td>
&lt;td>예외가 &lt;code>Deferred&lt;/code> 내부에 저장되며, &lt;code>await()&lt;/code> 호출 시 예외가 발생&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 코루틴 중 하나가 실패해도, 다른 자식 코루틴에 영향을 주지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조적 동시성 (&lt;code>coroutineScope&lt;/code>)&lt;/td>
&lt;td>모든 자식 코루틴이 성공적으로 완료되어야 블록이 종료됨. 하나라도 실패하면 전체 블록이 예외로 종료됨&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>코루틴의 예외 처리는 단순히 try-catch로 끝나지 않는다.
코루틴 빌더의 종류(launch vs async), Job의 구조(Job vs SupervisorJob), 전역 핸들러의 유무에 따라
예외의 전파 경로와 처리 방법이 달라진다.&lt;/p>
&lt;p>비동기 프로그램의 안정성과 복원력을 높이기 위해서는,
각 코루틴의 실행 범위와 책임, 예외 처리 방식을 명확히 설계해야 한다.&lt;/p>
&lt;h3 id="참고-예외-발생-흐름도">참고: 예외 발생 흐름도
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception() &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> 부모 Job &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> CoroutineExceptionHandler
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> Exception() &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> 저장됨 &lt;span style="color:#960050;background-color:#1e0010">→&lt;/span> await() 호출 시 &lt;span style="color:#66d9ef">throw&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div></description></item><item><title>구조적 동시성과 SupervisorJob의 실제 설계 활용</title><link>https://jaemin-baek.github.io/post/coroutinestructured/</link><pubDate>Wed, 05 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinestructured/</guid><description>&lt;h3 id="1-구조적-동시성이란">1. 구조적 동시성이란?
&lt;/h3>&lt;p>코루틴은 &lt;strong>스코프 기반으로 생성되며&lt;/strong>, 스코프가 종료되면&lt;br>
하위의 모든 자식 코루틴도 함께 종료된다.&lt;/p>
&lt;p>즉, 부모가 죽으면 자식도 죽고, 자식이 죽으면 부모도 영향을 받는다.&lt;br>
이는 다음과 같은 전통적인 구조를 따른다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { taskA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch { taskB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>taskA()&lt;/code>에서 예외가 발생하면 → 부모 코루틴도 취소됨&lt;/li>
&lt;li>따라서 &lt;code>taskB()&lt;/code>도 함께 취소된다&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-문제-상황-일부-실패는-무시하고-싶을-때">2. 문제 상황: 일부 실패는 무시하고 싶을 때
&lt;/h3>&lt;h4 id="예-병렬-api-요청-처리">예: 병렬 API 요청 처리
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> result = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> comments = async { fetchComments() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> suggestions = async { fetchSuggestions() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> AggregatedData(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> comments = comments.await(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> suggestions = suggestions.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>fetchComments()&lt;/code>에서 예외 발생 시 → &lt;code>fetchSuggestions()&lt;/code>도 중단됨&lt;/li>
&lt;li>전체가 실패로 처리됨 → &lt;strong>너무 강한 연결 구조&lt;/strong>&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-해결책-supervisorjob을-사용한-독립-실행-구조">3. 해결책: &lt;code>SupervisorJob&lt;/code>을 사용한 독립 실행 구조
&lt;/h3>&lt;p>&lt;code>SupervisorJob&lt;/code>을 사용하면,&lt;br>
&lt;strong>자식 중 하나가 예외를 던져도 다른 자식에 영향을 주지 않는다.&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> dataA = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> dataB = async {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span> { fetchB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">catch&lt;/span> (e: Exception) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> emptyList()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> data = ResultData(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dataA = dataA.await(),
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> dataB = dataB.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> )
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#66d9ef">data&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>&lt;code>fetchA()&lt;/code>가 실패해도 &lt;code>fetchB()&lt;/code>는 정상 실행됨&lt;/li>
&lt;li>각각 독립적으로 예외 처리하고, 전체 구조는 안정성을 유지함&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-내부-구조-요약">4. 내부 구조 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Job 유형&lt;/th>
&lt;th>예외 전파 방식&lt;/th>
&lt;th>사용 상황&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Job&lt;/code>&lt;/td>
&lt;td>자식 예외 → 부모로 전파 → 형제도 취소됨&lt;/td>
&lt;td>전체 실패 시 모두 중단해야 할 때&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>SupervisorJob&lt;/code>&lt;/td>
&lt;td>자식 예외는 부모에게 영향을 주지 않음&lt;/td>
&lt;td>부분 실패 허용, 독립적 작업 병렬 실행 시&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="5-실무-적용-사례">5. 실무 적용 사례
&lt;/h3>&lt;h4 id="병렬-데이터-수집">병렬 데이터 수집
&lt;/h4>&lt;ul>
&lt;li>API 여러 개 동시에 호출&lt;/li>
&lt;li>하나 실패해도 가능한 응답만으로 화면 구성&lt;/li>
&lt;/ul>
&lt;h4 id="백그라운드-동기화">백그라운드 동기화
&lt;/h4>&lt;ul>
&lt;li>다수의 파일 동기화 작업&lt;/li>
&lt;li>일부 실패는 로그로 남기고 나머지 계속 처리&lt;/li>
&lt;/ul>
&lt;h4 id="사용자-입력-처리">사용자 입력 처리
&lt;/h4>&lt;ul>
&lt;li>검색어 자동완성, 추천어, 최근 검색어 등 병렬로 가져올 때&lt;/li>
&lt;li>하나 실패해도 나머지는 계속 보여주고자 할 때&lt;/li>
&lt;/ul>
&lt;hr></description></item><item><title>CoroutineContext란 무엇인가? 코루틴 실행 환경의 핵심 이해</title><link>https://jaemin-baek.github.io/post/coroutinecontext/</link><pubDate>Tue, 04 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinecontext/</guid><description>&lt;h2 id="coroutinecontext란-무엇인가-코루틴-실행-환경의-핵심-이해">CoroutineContext란 무엇인가? 코루틴 실행 환경의 핵심 이해
&lt;/h2>&lt;p>Kotlin 코루틴을 사용하다 보면 반드시 등장하는 개념이 있다. 바로 &lt;code>CoroutineContext&lt;/code>.&lt;br>
이 객체는 코루틴의 실행에 필요한 모든 정보를 담고 있는 &lt;strong>컨텍스트 컨테이너&lt;/strong>이며,&lt;br>
코루틴의 동작 방식, 위치, 생명주기, 예외 처리 방식 등을 결정하는 &lt;strong>핵심 구성 요소&lt;/strong>이다.&lt;/p>
&lt;hr>
&lt;h3 id="1-coroutinecontext란">1. CoroutineContext란?
&lt;/h3>&lt;blockquote>
&lt;p>&lt;code>CoroutineContext&lt;/code>는 코루틴이 실행되기 위한 환경 정보들을 담고 있는 키-값 구조의 컨테이너이다.&lt;/p>&lt;/blockquote>
&lt;p>Kotlin에서 코루틴을 실행하려면 단순히 코드만으로는 부족하다.&lt;br>
다음과 같은 부가 정보들이 필요하다:&lt;/p>
&lt;ul>
&lt;li>어떤 스레드에서 실행할 것인가? (&lt;code>Dispatcher&lt;/code>)&lt;/li>
&lt;li>코루틴의 생명주기는 어떻게 관리할 것인가? (&lt;code>Job&lt;/code>)&lt;/li>
&lt;li>디버깅 시 어떤 이름으로 보일 것인가? (&lt;code>CoroutineName&lt;/code>)&lt;/li>
&lt;li>예외가 발생했을 때 어떻게 처리할 것인가? (&lt;code>CoroutineExceptionHandler&lt;/code>)&lt;/li>
&lt;/ul>
&lt;p>이 모든 정보를 하나로 묶은 것이 바로 &lt;code>CoroutineContext&lt;/code>이다.&lt;/p>
&lt;hr>
&lt;h3 id="2-주요-구성-요소">2. 주요 구성 요소
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>요소&lt;/th>
&lt;th>설명&lt;/th>
&lt;th>예시&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Job&lt;/code>&lt;/td>
&lt;td>코루틴의 생명주기 추적 및 취소 관리&lt;/td>
&lt;td>&lt;code>Job()&lt;/code>, &lt;code>SupervisorJob()&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Dispatcher&lt;/code>&lt;/td>
&lt;td>코루틴을 실행할 스레드 결정&lt;/td>
&lt;td>&lt;code>Dispatchers.Default&lt;/code>, &lt;code>Dispatchers.IO&lt;/code>, &lt;code>Dispatchers.Main&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CoroutineName&lt;/code>&lt;/td>
&lt;td>디버깅용 이름&lt;/td>
&lt;td>&lt;code>CoroutineName(&amp;quot;LoginFlow&amp;quot;)&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>CoroutineExceptionHandler&lt;/code>&lt;/td>
&lt;td>예외 처리 전략&lt;/td>
&lt;td>&lt;code>CoroutineExceptionHandler { _, e -&amp;gt; log(e) }&lt;/code>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="3-coroutinecontext-조합-방법">3. CoroutineContext 조합 방법
&lt;/h3>&lt;p>&lt;code>CoroutineContext&lt;/code>는 &lt;code>+&lt;/code> 연산자를 통해 여러 구성 요소를 결합할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> context = Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + CoroutineName(&lt;span style="color:#e6db74">&amp;#34;ExampleCoroutine&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>위 코드에서는 Job, Dispatcher, CoroutineName이 하나의 Context로 결합된다.&lt;/li>
&lt;li>이 Context는 CoroutineScope나 launch 등에서 사용 가능하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-coroutinescope와-coroutinecontext">4. CoroutineScope와 CoroutineContext
&lt;/h3>&lt;p>CoroutineScope는 내부적으로 반드시 하나의 CoroutineContext를 포함한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO + Job())
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 Scope에서 launch한 모든 코루틴은 이 Context를 상속받는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Context: &lt;/span>&lt;span style="color:#e6db74">$coroutineContext&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h4 id="출력-예시">출력 예시
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Context: [JobImpl{Active}&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>a67cf4c, &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="5-withcontext와-coroutinecontext">5. withContext와 CoroutineContext
&lt;/h3>&lt;p>코루틴의 Context를 전환하려면 withContext를 사용한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 이 블록은 IO 스레드에서 실행됨
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>현재 코루틴은 일시 정지되고&lt;/li>
&lt;li>새로운 Context에서 블록이 실행되며&lt;/li>
&lt;li>완료 후 원래 Context로 복귀된다&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="6-coroutinecontext-키워드">6. coroutineContext 키워드
&lt;/h3>&lt;p>코루틴 내부에서는 coroutineContext 키워드를 통해
자신이 실행 중인 Context를 언제든지 확인할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(coroutineContext[Job]) &lt;span style="color:#75715e">// 현재 Job
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> println(coroutineContext[CoroutineName]) &lt;span style="color:#75715e">// 이름 (있다면)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="7-실전-활용-예시">7. 실전 활용 예시
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + CoroutineName(&lt;span style="color:#e6db74">&amp;#34;Worker&amp;#34;&lt;/span>))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Context: &lt;/span>&lt;span style="color:#e6db74">$coroutineContext&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>출력 예&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Context: [JobImpl{Active}&lt;span style="color:#960050;background-color:#1e0010">@&lt;/span>&lt;span style="color:#ae81ff">7&lt;/span>e5c3f4, CoroutineName(Worker), &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="8-결론">8. 결론
&lt;/h3>&lt;p>CoroutineContext는 Kotlin 코루틴의 실행 환경을 구성하는 핵심 구조다.
Dispatcher, Job, Name, ExceptionHandler 등 다양한 정보가 담겨 있으며,
CoroutineScope, withContext, launch, async 등 코루틴 관련 도구들은 모두 이 Context를 바탕으로 동작한다.&lt;/p>
&lt;p>코루틴을 잘 다루려면 단순한 launch나 async뿐 아니라,
이들을 감싸고 있는 CoroutineContext의 구조와 흐름을 정확히 이해하는 것이 중요하다.&lt;/p></description></item><item><title>CoroutineScope.cancel()과 Job.cancel()은 같은가?</title><link>https://jaemin-baek.github.io/post/coroutinejobcancel/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinejobcancel/</guid><description>&lt;h2 id="coroutinescopecancel과-jobcancel은-같은가">CoroutineScope.cancel()과 Job.cancel()은 같은가?
&lt;/h2>&lt;p>Kotlin 코루틴을 사용하다 보면 &lt;code>CoroutineScope.cancel()&lt;/code>과 &lt;code>Job.cancel()&lt;/code>을 모두 보게 된다. 이 둘은 이름은 비슷하지만, 실제로 동일한 기능일까? 둘의 차이는 어디에 있을까? 본 포스트에서는 이 질문을 중심으로, Kotlin 표준과 &lt;code>kotlinx.coroutines&lt;/code>의 차이를 기반으로 정확한 동작 방식을 설명한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-job이란">1. Job이란?
&lt;/h3>&lt;p>&lt;code>Job&lt;/code>은 Kotlin 코루틴의 생명주기와 상태를 관리하는 객체다.&lt;br>
각 코루틴에는 하나의 Job이 할당되며, 이를 통해 다음을 제어할 수 있다:&lt;/p>
&lt;ul>
&lt;li>코루틴의 실행 상태 추적 (활성, 취소, 완료)&lt;/li>
&lt;li>&lt;code>cancel()&lt;/code>을 통한 중단 신호 전달&lt;/li>
&lt;li>&lt;code>join()&lt;/code>을 통한 종료 대기&lt;/li>
&lt;li>부모-자식 관계 관리&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="2-coroutinescope는-job을-포함한다">2. CoroutineScope는 Job을 포함한다
&lt;/h3>&lt;p>&lt;code>CoroutineScope&lt;/code>는 코루틴을 실행할 수 있는 컨텍스트이며, 내부적으로 &lt;code>CoroutineContext&lt;/code>를 통해 &lt;strong>Job을 반드시 포함&lt;/strong>한다. 예를 들어 다음과 같은 코드가 있을 때:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>실제로는 다음과 같은 컨텍스트가 구성된다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>CoroutineScope(Job() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, Job은 자동 생성되며 scope 안에 숨겨져 있다. 하지만 이 Job에 직접 접근할 수는 없다.&lt;/p>
&lt;hr>
&lt;h3 id="3-scopecancel은-왜-되는가">3. scope.cancel()은 왜 되는가?
&lt;/h3>&lt;p>Kotlin 표준의 CoroutineScope 인터페이스는 cancel() 함수를 직접 정의하지 않는다.
하지만 kotlinx.coroutines 라이브러리는 다음과 같은 확장 함수를 제공한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">public&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.cancel(cause: CancellationException? = &lt;span style="color:#66d9ef">null&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineContext[Job]&lt;span style="color:#f92672">?.&lt;/span>cancel(cause)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>즉, CoroutineScope.cancel()은 실제로는 자신의 CoroutineContext에서 Job을 꺼내고, 그 Job의 cancel()을 호출하는 확장 함수일 뿐이다.&lt;/p>
&lt;p>따라서 다음과 같은 코드는 정상적으로 작동한다&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.cancel() &lt;span style="color:#75715e">// kotlinx.coroutines 확장 함수로 동작
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="4-job을-명시적으로-만들면-어떤-이점이-있나">4. Job을 명시적으로 만들면 어떤 이점이 있나?
&lt;/h3>&lt;p>Job을 직접 변수로 만들어 Scope에 넣으면, Scope 밖에서도 Job을 통해 상태를 제어할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> job = Job()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(job + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// ...
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>job.cancel() &lt;span style="color:#75715e">// scope의 모든 코루틴 취소 가능
&lt;/span>&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>CoroutineScope.cancel()은 Kotlin 표준의 기능이 아니라,
kotlinx.coroutines에서 제공하는 확장 함수이다.
내부적으로는 Job.cancel()을 위임 호출하며, 같은 대상이라면 동작 결과는 동일하다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 withContext, launch, async의 개념 및 실행 방식 비교</title><link>https://jaemin-baek.github.io/post/withcontext/</link><pubDate>Mon, 03 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/withcontext/</guid><description>&lt;h2 id="kotlin-coroutine에서-withcontext-launch-async의-개념-및-실행-방식-비교">Kotlin Coroutine에서 withContext, launch, async의 개념 및 실행 방식 비교
&lt;/h2>&lt;p>Kotlin 코루틴은 비동기 흐름 제어를 위한 고수준 추상화를 제공하며, 이를 위한 핵심 도구로 &lt;code>withContext&lt;/code>, &lt;code>launch&lt;/code>, &lt;code>async&lt;/code>가 사용된다. 이 세 도구는 각각 목적과 동작 방식이 뚜렷하게 구분되며, 올바른 사용을 위해 그 차이를 명확히 이해하는 것이 중요하다. 본 문서에서는 이 세 가지 코루틴 구성 요소의 구조적 차이, 실행 방식, 반환값, 예외 처리 특성을 중심으로 비교하고 그 활용 맥락을 제시한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개념적-정의">1. 개념적 정의
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구성 요소&lt;/th>
&lt;th>기본 용도&lt;/th>
&lt;th>실행 컨텍스트&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>withContext&lt;/code>&lt;/td>
&lt;td>컨텍스트 전환 및 작업 수행&lt;/td>
&lt;td>같은 코루틴 내에서 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>launch&lt;/code>&lt;/td>
&lt;td>새로운 코루틴 시작 (단순 실행)&lt;/td>
&lt;td>독립된 Job 생성&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>async&lt;/code>&lt;/td>
&lt;td>결과값 반환이 필요한 코루틴 시작&lt;/td>
&lt;td>&lt;code>Deferred&amp;lt;T&amp;gt;&lt;/code> 반환&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="2-시그니처-비교">2. 시그니처 비교
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">withContext&lt;/span>(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context: CoroutineContext,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> block: &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): T
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &amp;lt;&lt;span style="color:#a6e22e">T&lt;/span>&amp;gt; &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.async(
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> context: CoroutineContext = EmptyCoroutineContext,
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> block: &lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#a6e22e">CoroutineScope&lt;/span>.() &lt;span style="color:#f92672">-&amp;gt;&lt;/span> T
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>): Deferred&amp;lt;T&amp;gt;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>withContext: suspend 함수이며, 호출한 코루틴의 흐름을 일시 정지하고 컨텍스트 전환 후 실행&lt;/li>
&lt;li>launch: 새로운 코루틴을 시작하고 Job을 반환&lt;/li>
&lt;li>async: 결과값을 비동기적으로 계산하며 Deferred&lt;!-- raw HTML omitted -->를 반환&lt;/li>
&lt;/ul>
&lt;h3 id="3-사용-예시">3. 사용 예시
&lt;/h3>&lt;h4 id="31-withcontext">3.1 withContext
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">loadData&lt;/span>(): String {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 블로킹 IO → 비동기 전환
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> fetchDataFromNetwork()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>현재 코루틴을 일시 정지하고 Dispatchers.IO로 전환하여 작업을 수행&lt;/li>
&lt;li>완료 후 이전 컨텍스트로 복귀&lt;/li>
&lt;/ul>
&lt;h4 id="32-launch">3.2 launch
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">startLogging&lt;/span>(scope: CoroutineScope) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Logging started.&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>독립 실행 → 결과 반환 없이 작업 수행&lt;/li>
&lt;li>Job을 통해 수명 및 취소 여부 제어 가능&lt;/li>
&lt;/ul>
&lt;h4 id="33-async">3.3 async
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">aggregate&lt;/span>(): Int = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async { computeA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async { computeB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> a.await() + b.await()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>결과가 필요한 두 작업을 병렬로 실행&lt;/li>
&lt;li>await() 호출 시 각각의 연산 결과를 비동기적으로 수집&lt;/li>
&lt;/ul>
&lt;h3 id="4-비교-요약-표">4. 비교 요약 표
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>withContext&lt;/code>&lt;/th>
&lt;th>&lt;code>launch&lt;/code>&lt;/th>
&lt;th>&lt;code>async&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>새 코루틴 생성 여부&lt;/td>
&lt;td>❌ (현재 코루틴 내부에서 실행)&lt;/td>
&lt;td>✅ 새 코루틴 시작&lt;/td>
&lt;td>✅ 새 코루틴 시작&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>반환값&lt;/td>
&lt;td>✅ 반환값을 직접 반환&lt;/td>
&lt;td>❌ 반환값 없음 (&lt;code>Unit&lt;/code>)&lt;/td>
&lt;td>✅ &lt;code>Deferred&amp;lt;T&amp;gt;&lt;/code>로 비동기 결과 반환&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>병렬 실행&lt;/td>
&lt;td>❌ 순차 실행&lt;/td>
&lt;td>✅ 병렬 가능&lt;/td>
&lt;td>✅ 병렬 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>예외 전파 방식&lt;/td>
&lt;td>즉시 전파됨&lt;/td>
&lt;td>부모 &lt;code>Job&lt;/code>으로 전파됨&lt;/td>
&lt;td>&lt;code>await()&lt;/code> 시 전파됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>컨텍스트 전환&lt;/td>
&lt;td>✅ 주 용도&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>취소 전파&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;td>✅ 가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주 사용 목적&lt;/td>
&lt;td>컨텍스트 전환 + 결과 처리&lt;/td>
&lt;td>단순한 백그라운드 실행&lt;/td>
&lt;td>병렬 작업 + 결과 수집&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="5-결론">5. 결론
&lt;/h3>&lt;p>&lt;code>withContext&lt;/code>, &lt;code>launch&lt;/code>, &lt;code>async&lt;/code>는 Kotlin 코루틴의 비동기 실행 모델을 구성하는 핵심 도구로서, 각기 다른 목적과 특성을 가진다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>withContext&lt;/code>는 &lt;strong>기존 코루틴의 흐름 안에서 Dispatcher나 Job 등 컨텍스트만 전환&lt;/strong>하여 특정 블록을 실행하고 결과를 반환하는 데 사용된다.&lt;/li>
&lt;li>&lt;code>launch&lt;/code>는 &lt;strong>새로운 코루틴을 시작하여 병렬로 독립적인 작업을 수행&lt;/strong>하는 데 적합하며, 결과값이 필요 없는 단순 작업에 주로 쓰인다.&lt;/li>
&lt;li>&lt;code>async&lt;/code>는 &lt;strong>결과값을 반환해야 하는 병렬 작업&lt;/strong>에 적합하며, &lt;code>Deferred&amp;lt;T&amp;gt;&lt;/code>를 통해 &lt;code>await()&lt;/code>로 값을 추후 사용할 수 있게 한다.&lt;/li>
&lt;/ul>
&lt;p>이들 각각은 코루틴의 &lt;strong>생명주기 관리, 예외 처리 흐름, 병렬성 확보 방식&lt;/strong>에 차이를 가지며, 목적에 맞는 선택을 통해 더 안정적이고 예측 가능한 비동기 시스템을 설계할 수 있다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 coroutineScope의 일시 정지(suspend) 동작 해석</title><link>https://jaemin-baek.github.io/post/coroutinescopesuspend/</link><pubDate>Sun, 02 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescopesuspend/</guid><description>&lt;h2 id="kotlin-coroutine에서-coroutinescope의-일시-정지suspend-동작-해석">Kotlin Coroutine에서 &lt;code>coroutineScope&lt;/code>의 일시 정지(suspend) 동작 해석
&lt;/h2>&lt;p>Kotlin의 코루틴은 비동기 제어 흐름을 지원하는 언어 차원의 기능으로, 실행의 흐름을 일시적으로 중단하고 재개할 수 있는 &lt;code>suspend&lt;/code> 키워드를 핵심으로 한다. 이 가운데 &lt;code>coroutineScope&lt;/code> 빌더는 구조적 동시성(Structured Concurrency)을 구성하는 대표적 구성 요소이며, “현재 코루틴을 일시 정지시킨다”는 표현으로 설명되곤 한다. 본 문서에서는 이 표현의 기술적 의미와 실제 실행 흐름을 해석한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개념적-정의">1. 개념적 정의
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 &lt;code>suspend&lt;/code> 함수 내에서 사용 가능한 고차 함수로, 내부에서 생성된 자식 코루틴들이 &lt;strong>모두 완료될 때까지&lt;/strong> 현재 코루틴의 실행을 &lt;strong>일시 정지(suspend)&lt;/strong> 상태로 유지한다. 이 suspend는 &lt;strong>스레드 블로킹(blocking)이 아닌, 코루틴 자체의 일시 정지&lt;/strong>를 의미하며, 이는 코루틴 스케줄러 수준에서 관리된다.&lt;/p>
&lt;hr>
&lt;h3 id="2-코드-예시-및-실행-흐름">2. 코드 예시 및 실행 흐름
&lt;/h3>&lt;p>다음은 &lt;code>coroutineScope&lt;/code>의 대표적인 사용 예이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">outerFunction&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;1. 시작&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;2. 자식 코루틴 완료&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;3. coroutineScope 블록 종료 후 실행됨&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="예상-출력-순서">예상 출력 순서
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">1.&lt;/span> 시작
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">2.&lt;/span> 자식 코루틴 완료
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#ae81ff">3.&lt;/span> coroutineScope 블록 종료 후 실행됨
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="동작-설명">동작 설명
&lt;/h3>&lt;ul>
&lt;li>outerFunction은 하나의 suspend 함수이며 코루틴 컨텍스트 내에서 실행된다.&lt;/li>
&lt;li>그 안의 coroutineScope는 내부에서 자식 코루틴을 생성하고, **해당 자식이 완료될 때까지 현재 코루틴의 실행을 일시 중단(suspend)**한다.&lt;/li>
&lt;li>자식이 완료되면 다시 이어서 실행되며, 이후의 println(&amp;ldquo;3. &amp;hellip;&amp;quot;)이 실행된다.&lt;/li>
&lt;/ul>
&lt;h3 id="3-suspend와-blocking의-구분">3. suspend와 blocking의 구분
&lt;/h3>&lt;p>&lt;code>suspend&lt;/code>는 &lt;strong>비동기 흐름 제어&lt;/strong>를 위한 메커니즘으로, 스레드를 점유하지 않고 중단할 수 있다. 이는 &lt;code>Thread.sleep&lt;/code>과 같은 &lt;strong>스레드 차단(blocking)&lt;/strong> 방식과 본질적으로 다르다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>구분&lt;/th>
&lt;th>suspend&lt;/th>
&lt;th>blocking&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>대상&lt;/td>
&lt;td>코루틴&lt;/td>
&lt;td>스레드&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>리소스 점유&lt;/td>
&lt;td>없음&lt;/td>
&lt;td>있음 (CPU 점유)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>실행 재개 방식&lt;/td>
&lt;td>코루틴 스케줄러가 재개&lt;/td>
&lt;td>외부 조건이 충족되어야 해제&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>대표 예시&lt;/td>
&lt;td>&lt;code>delay()&lt;/code>, &lt;code>coroutineScope {}&lt;/code>&lt;/td>
&lt;td>&lt;code>Thread.sleep()&lt;/code>, &lt;code>runBlocking {}&lt;/code>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>병렬성 확보&lt;/td>
&lt;td>고성능 병렬 처리 가능&lt;/td>
&lt;td>동시성 제한, 블로킹 자원 증가&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>따라서 &amp;ldquo;&lt;code>현재 코루틴을 일시 정지시킨다&lt;/code>&amp;ldquo;는 표현은 &lt;strong>스레드가 멈추는 것이 아니라&lt;/strong>,&lt;br>
해당 suspend 함수의 &lt;strong>논리적 실행 흐름만 대기 상태로 전환된다&lt;/strong>는 의미이다.&lt;/p>
&lt;hr>
&lt;h3 id="4-구조적-동시성과의-관계">4. 구조적 동시성과의 관계
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 구조적 동시성을 보장하는 코루틴 빌더로,&lt;br>
블록 내 자식 코루틴이 &lt;strong>모두 완료되기 전까지 suspend 상태를 유지&lt;/strong>한다.&lt;br>
이 구조는 다음과 같은 특징을 가진다:&lt;/p>
&lt;ul>
&lt;li>모든 자식 코루틴이 종료되기 전까지 다음 코드로 진행되지 않음&lt;/li>
&lt;li>자식 중 하나라도 실패하면 전체 블록이 예외와 함께 취소됨&lt;/li>
&lt;li>suspend 함수 안에서 사용되어 자연스럽게 일시 중단을 허용함&lt;/li>
&lt;/ul>
&lt;p>이러한 특성은 복잡한 비동기 로직의 안정성을 높이고, 예외 흐름을 간결하게 구성할 수 있게 해준다.&lt;/p>
&lt;hr>
&lt;h3 id="5-결론">5. 결론
&lt;/h3>&lt;p>&amp;ldquo;&lt;code>coroutineScope&lt;/code>는 현재 코루틴을 일시 정지시킨다&amp;quot;는 표현은&lt;br>
&lt;strong>비동기 흐름 내에서 해당 suspend 함수의 실행이 자식 코루틴의 완료 시점까지 일시적으로 중단(suspend)&lt;/strong>&lt;br>
된다는 의미로 해석해야 한다.&lt;/p>
&lt;p>이는 스레드를 차단하지 않으면서도 자식 작업을 &lt;strong>안전하게 동기화&lt;/strong>할 수 있게 하며,&lt;br>
Kotlin 코루틴의 구조적 동시성 모델에서 핵심적인 개념 중 하나이다.&lt;/p>
&lt;p>개발자는 &lt;code>suspend&lt;/code>와 &lt;code>blocking&lt;/code>의 차이를 명확히 이해함으로써,&lt;br>
불필요한 스레드 점유 없이 효율적인 비동기 시스템을 설계할 수 있다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 CoroutineScope와 coroutineScope 빌더의 개념적 차이</title><link>https://jaemin-baek.github.io/post/coroutinescopevsbuilder/</link><pubDate>Sat, 01 Mar 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescopevsbuilder/</guid><description>&lt;h2 id="kotlin-coroutine에서-coroutinescope와-coroutinescope-빌더의-개념적-차이">Kotlin Coroutine에서 CoroutineScope와 coroutineScope 빌더의 개념적 차이
&lt;/h2>&lt;p>Kotlin 코루틴은 구조적 동시성(Structured Concurrency)을 구현하기 위해 다양한 스코프(scope) 기반의 실행 환경을 제공한다. 그중 &lt;code>CoroutineScope(...)&lt;/code> 생성자와 &lt;code>coroutineScope {}&lt;/code> 빌더는 이름이 유사하지만, &lt;strong>역할과 사용 위치, 생명주기 및 제어 방식에 있어 명확히 구분되는 개념&lt;/strong>이다. 본 문서에서는 이 둘의 본질적인 차이와 각각의 실용적 쓰임에 대해 기술한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 자체적인 실행 컨텍스트를 요구하며, 이를 정의하는 단위가 CoroutineScope이다. 코루틴 스코프는 일반적으로 명시적으로 생성하거나, 일시적으로 suspend 함수 내에서 빌더로 선언하여 사용된다. 이 두 방식은 각각 &lt;code>CoroutineScope(...)&lt;/code> 생성자와 &lt;code>coroutineScope {}&lt;/code> 빌더로 구분되며, 코드 구조와 실행 흐름에 결정적인 영향을 미친다.&lt;/p>
&lt;hr>
&lt;h3 id="2-coroutinescope-생성자">2. CoroutineScope(&amp;hellip;) 생성자
&lt;/h3>&lt;p>&lt;code>CoroutineScope(context: CoroutineContext)&lt;/code>는 &lt;strong>클래스나 객체 수준&lt;/strong>에서 코루틴 실행 환경을 명시적으로 구성할 때 사용된다. 생성된 스코프는 별도로 &lt;code>cancel()&lt;/code>하거나 생명주기를 관리해야 하며, 장기 실행되는 컴포넌트(ViewModel, Service 등)에 적합하다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 장기 실행되는 비동기 작업
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>외부에서 scope.cancel()을 호출하면 해당 스코프 하위의 모든 코루틴이 취소된다.&lt;/li>
&lt;li>CoroutineScope는 클래스 필드나 전역 컨텍스트로 주입되며, 수동 관리가 필수이다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="3-coroutinescope---빌더">3. coroutineScope { } 빌더
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 &lt;code>suspend fun&lt;/code> 내부에서 사용 가능한 코루틴 빌더이며, 해당 블록 내에서 생성된 자식 코루틴들이 모두 완료되기 전까지 현재 코루틴을 일시 정지시킨다. 구조적 동시성을 구현하기 위한 핵심 기제로 작동하며, 블록 범위 외부로 생명주기가 확장되지 않는다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchData&lt;/span>(): UserData = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async { fetchA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async { fetchB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> UserData(a.await(), b.await())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>블록이 종료되면 자식 코루틴은 모두 정리되고 스코프도 자동으로 사라진다.&lt;/li>
&lt;li>coroutineScope 자체를 변수로 저장하거나 외부에서 cancel()하는 것은 불가능하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-비교-표">4. 비교 표
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>CoroutineScope(...)&lt;/code>&lt;/th>
&lt;th>&lt;code>coroutineScope { }&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>타입&lt;/td>
&lt;td>클래스 생성자&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내 빌더&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 위치&lt;/td>
&lt;td>전역, 클래스 필드 등&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생명주기&lt;/td>
&lt;td>외부에서 수동으로 관리 (&lt;code>cancel()&lt;/code>)&lt;/td>
&lt;td>블록 내부에서 자동 관리됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>구조적 동시성&lt;/td>
&lt;td>보장되지 않음 (설계에 따라 가능)&lt;/td>
&lt;td>기본적으로 보장됨&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>외부에서 종료 가능 여부&lt;/td>
&lt;td>가능 (&lt;code>cancel()&lt;/code>)&lt;/td>
&lt;td>불가능&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자식 예외 전파 방식&lt;/td>
&lt;td>Job 종류에 따라 다름 (ex. &lt;code>SupervisorJob&lt;/code>)&lt;/td>
&lt;td>자식 실패 시 전체 블록 취소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>일반적 사용 용도&lt;/td>
&lt;td>ViewModel, Repository, Service 등 장기 생존 객체&lt;/td>
&lt;td>일시적 작업 조합, suspend 함수 내부 동시 실행 처리&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="5-사용-예시-비교">5. 사용 예시 비교
&lt;/h3>&lt;h4 id="51-coroutinescope-예시">5.1 CoroutineScope 예시
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">DataFetcher&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">startFetching&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> fetchSomething()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">stop&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> scope.cancel() &lt;span style="color:#75715e">// 명시적으로 종료
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>장기 실행되는 비동기 작업을 관리하는 데 적합하며, cancel()을 통한 명확한 종료가 가능하다.&lt;/li>
&lt;/ul>
&lt;h4 id="52-coroutinescope-예시">5.2 coroutineScope 예시
&lt;/h4>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">fetchAll&lt;/span>(): List&amp;lt;Result&amp;gt; = coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> a = async { fetchA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">val&lt;/span> b = async { fetchB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> listOf(a.await(), b.await())
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>일시적인 데이터 병렬 수집이나 처리 시에 적합하며, 외부 생명주기와 무관하다.&lt;/li>
&lt;/ul>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>&lt;code>CoroutineScope(...)&lt;/code>는 명시적 실행 환경을 구성하고, 생명주기를 외부에서 직접 제어해야 하는 경우에 사용된다. 반면 &lt;code>coroutineScope {}&lt;/code>는 일시적이고 지역적인 suspend 블록으로서, 블록 내부의 자식 코루틴들의 실행을 제어하고, 자동 정리되는 구조적 동시성을 제공한다. 이 둘은 유사한 이름을 가졌으나, 설계 철학과 활용 맥락이 명확히 구분되어야 하며, 적절한 선택이 안정적이고 예측 가능한 코루틴 기반 시스템 설계의 핵심이 된다.&lt;/p></description></item><item><title>Kotlin Coroutine에서 SupervisorJob의 역할과 scopeJob 구조</title><link>https://jaemin-baek.github.io/post/supervisorjob/</link><pubDate>Tue, 25 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/supervisorjob/</guid><description>&lt;h2 id="kotlin-coroutine에서-supervisorjob의-역할과-scopejob-구조">Kotlin Coroutine에서 SupervisorJob의 역할과 &lt;code>scopeJob&lt;/code> 구조
&lt;/h2>&lt;p>Kotlin 코루틴에서는 비동기 작업의 생명주기와 예외 처리를 체계적으로 관리하기 위해 &lt;code>Job&lt;/code> 기반의 구조적 동시성을 제공한다. 본 문서에서는 그 중 &lt;code>SupervisorJob&lt;/code>을 중심으로 하는 &lt;code>scopeJob&lt;/code>의 역할과 필요성, 그리고 일반 &lt;code>Job&lt;/code>과의 차이에 대해 고찰한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 &lt;code>CoroutineScope&lt;/code> 내에서 생성된 자식 코루틴들과 부모 코루틴 간의 관계를 명확히 하여 예측 가능한 동시 실행을 가능하게 한다. 이때 &lt;code>Job&lt;/code>은 각 코루틴의 생명주기를 추적하고, 취소 여부를 상위 또는 하위로 전파하는 핵심 구성요소로 작동한다. Kotlin에서는 &lt;code>Job&lt;/code> 외에도 &lt;code>SupervisorJob&lt;/code>이라는 특별한 형태의 Job을 제공하여, 자식 간의 실패 전파를 제어할 수 있다.&lt;/p>
&lt;hr>
&lt;h3 id="2-구조-예시">2. 구조 예시
&lt;/h3>&lt;p>아래는 &lt;code>SupervisorJob&lt;/code>을 기반으로 한 &lt;code>scopeJob&lt;/code>을 생성하는 전형적인 코드 예시이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scopeJob = SupervisorJob()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">private&lt;/span> &lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(scopeJob + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 scope 내에서 생성되는 모든 자식 코루틴이 SupervisorJob을 공유하도록 구성되며, 하나의 자식이 실패하더라도 다른 자식은 영향을 받지 않고 독립적으로 실행을 계속할 수 있도록 한다.&lt;/p>
&lt;hr>
&lt;h3 id="3-supervisorjob의-동작-원리">3. SupervisorJob의 동작 원리
&lt;/h3>&lt;p>&lt;code>SupervisorJob&lt;/code>은 일반 &lt;code>Job&lt;/code>과 달리, 자식 코루틴이 실패(Exception 발생 등)하더라도 &lt;strong>부모나 다른 자식 코루틴에게 실패를 전파하지 않는다&lt;/strong>. 이를 통해 &lt;strong>고립된 실패 처리&lt;/strong>와 &lt;strong>부분 성공 전략&lt;/strong>을 구현할 수 있다.&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>Job (기본)&lt;/th>
&lt;th>SupervisorJob&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>자식 실패 시&lt;/td>
&lt;td>전체 스코프 취소&lt;/td>
&lt;td>실패한 자식만 취소&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>형제 간 전파&lt;/td>
&lt;td>예외 전파됨&lt;/td>
&lt;td>전파되지 않음&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 목적&lt;/td>
&lt;td>전체 작업의 일관성 보장&lt;/td>
&lt;td>부분 실패 허용, 독립 실행 구조&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;code>SupervisorJob&lt;/code>은 &lt;code>supervisorScope {}&lt;/code> 또는 직접 Scope를 구성할 때 명시적으로 사용되며, &lt;code>CoroutineScope(SupervisorJob())&lt;/code> 형태로 자주 활용된다.&lt;/p>
&lt;hr>
&lt;h3 id="4-실용적-사용-맥락">4. 실용적 사용 맥락
&lt;/h3>&lt;ul>
&lt;li>병렬로 다수의 외부 API를 호출할 때&lt;/li>
&lt;li>자식 코루틴 중 하나가 실패하더라도 나머지 결과가 유효한 경우&lt;/li>
&lt;li>백그라운드 데이터 동기화 작업에서 개별 요청 단위의 실패를 분리하고 싶은 경우&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 개별 작업 1
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>scope.launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e">// 개별 작업 2 (실패해도 다른 작업에는 영향 없음)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 scope 내부에서 수행되는 코루틴들이 독립적인 실행 환경을 갖도록 보장한다.&lt;/p>
&lt;hr>
&lt;h3 id="5-예외-처리와-결합">5. 예외 처리와 결합
&lt;/h3>&lt;p>실제 응용에서는 SupervisorJob과 함께 CoroutineExceptionHandler를 결합하여 보다 견고한 예외 처리를 구현할 수 있다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> exceptionHandler = CoroutineExceptionHandler { _, throwable &lt;span style="color:#f92672">-&amp;gt;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> logger.error(&lt;span style="color:#e6db74">&amp;#34;Unhandled exception: &lt;/span>&lt;span style="color:#e6db74">$throwable&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> scope = CoroutineScope(SupervisorJob() + &lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default + exceptionHandler)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 실패한 자식 코루틴의 예외를 처리하면서도 전체 스코프를 안정적으로 유지할 수 있게 한다.&lt;/p>
&lt;h3 id="6-결론">6. 결론
&lt;/h3>&lt;p>SupervisorJob은 Kotlin 코루틴 기반 구조에서 자식 간의 예외 전파를 분리하고, 작업 단위의 독립성과 견고성을 확보하기 위한 중요한 구성요소이다. 일반 Job이 전체 일괄 실패를 선호하는 전략이라면, SupervisorJob은 부분 실패를 수용하며 전체 서비스의 연속성을 유지하는 전략에 적합하다. 이를 통해 복잡한 비동기 시스템에서도 예측 가능한 실행 흐름과 회복 가능한 오류 처리가 가능해진다.&lt;/p>
&lt;hr></description></item><item><title>Kotlin 코루틴의 runBlocking, coroutineScope, supervisorScope 비교</title><link>https://jaemin-baek.github.io/post/coroutinescope/</link><pubDate>Wed, 19 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutinescope/</guid><description>&lt;h2 id="kotlin-코루틴의-실행-스코프-비교-runblocking-coroutinescope-supervisorscope">Kotlin 코루틴의 실행 스코프 비교: runBlocking, coroutineScope, supervisorScope
&lt;/h2>&lt;p>Kotlin의 코루틴 시스템은 다양한 실행 스코프 제공을 통해 구조적 동시성과 예외 분리를 가능하게 한다. 본 문서에서는 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>의 기능과 목적을 비교하고, 각각의 사용 상황과 실행 흐름 차이에 대해 기술한다.&lt;/p>
&lt;hr>
&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>코루틴은 전통적인 스레드 기반 프로그래밍에 비해 더 적은 리소스로 동시성을 지원하며, 이를 위해 다양한 스코프 빌더가 제공된다. 그중 &lt;code>runBlocking&lt;/code>, &lt;code>coroutineScope&lt;/code>, &lt;code>supervisorScope&lt;/code>는 가장 자주 사용되는 고수준 코루틴 빌더로, 이들은 실행 방식과 예외 처리 구조에 있어 중요한 차이를 갖는다.&lt;/p>
&lt;hr>
&lt;h3 id="2-주요-차이점-요약">2. 주요 차이점 요약
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>항목&lt;/th>
&lt;th>&lt;code>runBlocking&lt;/code>&lt;/th>
&lt;th>&lt;code>coroutineScope&lt;/code>&lt;/th>
&lt;th>&lt;code>supervisorScope&lt;/code>&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>차단 여부&lt;/td>
&lt;td>호출한 &lt;strong>스레드를 차단&lt;/strong>&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;td>차단하지 않음 (&lt;code>suspend&lt;/code>)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>사용 위치&lt;/td>
&lt;td>&lt;code>main()&lt;/code> 함수, 테스트&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;td>&lt;code>suspend&lt;/code> 함수 내부&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>자식 실패 전파&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>자식 실패 시 전체 취소&lt;/td>
&lt;td>실패해도 다른 자식은 계속 실행&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>생성 스코프&lt;/td>
&lt;td>새 &lt;code>CoroutineScope&lt;/code> 생성&lt;/td>
&lt;td>상위 스코프 상속&lt;/td>
&lt;td>&lt;code>SupervisorJob&lt;/code> 기반 스코프&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>주요 목적&lt;/td>
&lt;td>일반 코드와 코루틴 연결&lt;/td>
&lt;td>구조적 동시성&lt;/td>
&lt;td>예외 고립 및 분리 실행&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;hr>
&lt;h3 id="3-runblocking">3. runBlocking
&lt;/h3>&lt;p>&lt;code>runBlocking&lt;/code>은 코루틴 진입점을 제공하는 함수로, 일반적인 블로킹 코드(main 함수 등)에서 &lt;code>suspend&lt;/code> 함수를 사용할 수 있도록 한다. 내부적으로 현재 스레드를 차단하며, 코루틴이 완료될 때까지 대기한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Start&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>호출한 스레드를 직접 차단하며, UI 스레드에서는 사용을 지양해야 한다.&lt;/li>
&lt;li>&lt;code>CoroutineScope&lt;/code>를 생성하여 내부에서 &lt;code>launch&lt;/code>, &lt;code>async&lt;/code> 등을 사용할 수 있다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="4-coroutinescope">4. coroutineScope
&lt;/h3>&lt;p>&lt;code>coroutineScope&lt;/code>는 현재 컨텍스트를 상속하는 &lt;code>CoroutineScope&lt;/code>를 생성하며, 내부의 모든 자식 코루틴이 종료될 때까지 &lt;code>suspend&lt;/code> 상태로 대기한다. 이는 구조적 동시성을 구현하는 핵심 도구로 사용된다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> coroutineScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child 1 done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Child 2 done&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;All children completed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>자식 중 하나라도 실패하면 전체 스코프가 취소된다.&lt;/li>
&lt;li>일반적으로 suspend 함수 내에서 사용된다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="5-supervisorscope">5. supervisorScope
&lt;/h3>&lt;p>supervisorScope는 자식 코루틴 간 실패 전파를 막고, 하나의 실패가 다른 작업에 영향을 미치지 않도록 하는 예외 격리 기능을 제공한다. 내부적으로 SupervisorJob을 사용하여 고립된 실행 환경을 형성한다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">run&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> supervisorScope {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">throw&lt;/span> RuntimeException(&lt;span style="color:#e6db74">&amp;#34;Child failed&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Other child still runs&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>하나의 자식이 예외를 발생시켜도 다른 자식은 계속 실행된다.&lt;/li>
&lt;li>실시간 처리나 부분 실패를 허용하는 작업에 적합하다.&lt;/li>
&lt;/ul>
&lt;hr>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>코루틴의 실행 컨텍스트 선택은 코드의 동시성 구조와 예외 처리 전략에 직접적인 영향을 미친다. runBlocking은 동기-비동기 경계를 연결하는 데 유용하며, coroutineScope는 구조적 동시성을 제공하고, supervisorScope는 자식 코루틴의 독립 실행을 보장한다. 각 스코프의 특성을 이해하고 상황에 맞게 사용하는 것이 안전하고 예측 가능한 비동기 프로그래밍을 구현하는 데 핵심이 된다.&lt;/p>
&lt;hr></description></item><item><title>Kotlin 코루틴의 멀티스레드 동작 방식</title><link>https://jaemin-baek.github.io/post/coroutine/</link><pubDate>Sun, 16 Feb 2025 00:00:00 +0000</pubDate><guid>https://jaemin-baek.github.io/post/coroutine/</guid><description>&lt;h2 id="kotlin-coroutine의-멀티스레드-동작-방식">Kotlin Coroutine의 멀티스레드 동작 방식
&lt;/h2>&lt;h3 id="1-개요">1. 개요
&lt;/h3>&lt;p>Kotlin의 코루틴은 경량 스레드(Lightweight Thread) 개념에 기반하여 비동기 작업을 처리하는 구조로 설계되었다. 본 문서에서는 코루틴이 멀티스레드 환경에서 어떤 방식으로 실행되고 스케줄링되는지를 기술하고, 관련 디스패처(&lt;code>CoroutineDispatcher&lt;/code>)의 역할과 실행 흐름에 대해 서술한다.&lt;/p>
&lt;hr>
&lt;h3 id="2-코루틴과-스레드의-관계">2. 코루틴과 스레드의 관계
&lt;/h3>&lt;p>Kotlin 코루틴은 실제 스레드(Thread)와는 구분되는 실행 단위로, 운영체제 수준의 스레드를 직접 생성하거나 관리하지 않는다. 대신, 내부적으로 코루틴 디스패처가 지정된 스레드 풀(Thread Pool) 또는 단일 스레드에서 코루틴을 스케줄링한다. 이러한 구조는 리소스 효율성을 높이고, 대규모 동시 실행 환경에서의 성능을 개선하는 데 기여한다.&lt;/p>
&lt;hr>
&lt;h3 id="3-coroutinedispatcher의-역할">3. CoroutineDispatcher의 역할
&lt;/h3>&lt;p>&lt;code>CoroutineDispatcher&lt;/code>는 코루틴이 실행될 스레드를 결정하는 핵심 컴포넌트이다. 주요 디스패처는 다음과 같다.&lt;/p>
&lt;ul>
&lt;li>&lt;code>Dispatchers.Default&lt;/code>: CPU 집약적인 작업을 위한 공유 스레드 풀을 사용한다. 일반적으로 코어 수에 비례한 스레드를 할당한다.&lt;/li>
&lt;li>&lt;code>Dispatchers.IO&lt;/code>: 블로킹 I/O 작업에 최적화된 디스패처로, 더 많은 수의 스레드를 동적으로 생성하여 처리한다.&lt;/li>
&lt;li>&lt;code>Dispatchers.Main&lt;/code>: UI 기반 애플리케이션에서 메인 스레드에서 실행되도록 보장한다. 안드로이드 또는 JavaFX 환경에서 사용된다.&lt;/li>
&lt;li>&lt;code>newSingleThreadContext(name: String)&lt;/code>: 명시적으로 단일 스레드를 생성하여 해당 코루틴만을 위해 사용할 수 있도록 한다.&lt;/li>
&lt;/ul>
&lt;p>각 디스패처는 코루틴이 실행되는 스레드의 종류를 정의함으로써, 개발자가 동시성 또는 병렬성을 세밀하게 제어할 수 있도록 한다.&lt;/p>
&lt;hr>
&lt;h3 id="4-실행-예시-및-스레드-분산">4. 실행 예시 및 스레드 분산
&lt;/h3>&lt;p>다음은 다양한 디스패처를 지정하여 코루틴이 각각 다른 스레드에서 실행되는 예시이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">import&lt;/span> kotlinx.coroutines.*
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Default dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;IO dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(newSingleThreadContext(&lt;span style="color:#e6db74">&amp;#34;MyThread&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Single thread context: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>위 예제는 세 개의 코루틴이 서로 다른 스레드에서 동시에 실행되는 구조를 갖는다. 이로써 코루틴이 단일 스레드에 국한되지 않으며, 디스패처 설정에 따라 명시적으로 병렬 실행이 가능함을 확인할 수 있다.&lt;/p>
&lt;h3 id="실행-결과">실행 결과:
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Single thread context: MyThread
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>그런데 Default, IO 가 기대했던 DefaultDispatcher-worker-1 , DefaultDispatcher-worker-2 가 아니다.&lt;/p>
&lt;p>이건 Dispatchers.Default와 Dispatchers.IO가 같은 스레드에서 실행된 것처럼 보이는 현상인데 이유는 아래와 같다.&lt;/p>
&lt;h3 id="왜-dispatchersdefault와-io가-같은-스레드-이름일까">왜 Dispatchers.Default와 IO가 같은 스레드 이름일까?
&lt;/h3>&lt;h4 id="공유-풀을-사용-중">공유 풀을 사용 중
&lt;/h4>&lt;ol>
&lt;li>Dispatchers.Default와 Dispatchers.IO는 모두 스레드 풀(thread pool) 기반이다.&lt;/li>
&lt;li>둘 다 내부적으로 DefaultExecutor와 IOExecutor를 공유하는 구조가 있다.&lt;/li>
&lt;li>JVM이 할당한 첫 번째 워커 스레드(worker-1)가 여러 코루틴에 재사용될 수 있다.&lt;/li>
&lt;/ol>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>Dispatcher&lt;/th>
&lt;th>설명&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>&lt;code>Dispatchers.Default&lt;/code>&lt;/td>
&lt;td>CPU 중심 작업용, &lt;strong>코어 수만큼의 스레드 풀&lt;/strong> 사용&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>Dispatchers.IO&lt;/code>&lt;/td>
&lt;td>I/O 중심 작업용, &lt;strong>무제한 스레드 풀&lt;/strong>, 내부적으로 &lt;code>Default&lt;/code>를 재사용함&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>&lt;code>newSingleThreadContext()&lt;/code>&lt;/td>
&lt;td>오직 &lt;strong>1개의 전용 스레드&lt;/strong>만 사용하는 디스패처, 명시적으로 생성한 스레드 사용&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>즉, 같은 워커가 같은 순간에 여러 코루틴을 처리하지 않더라도, 스레드 풀 안에서 동적으로 배정되다 보니 같은 이름이 출력될 수 있다.&lt;/p>
&lt;h4 id="작은-예제라-워커-수가-1개로-충분한-상황">작은 예제라 워커 수가 1개로 충분한 상황
&lt;/h4>&lt;p>runBlocking + 3개의 launch를 실행할 뿐이라서, 코어 수가 충분하거나 작업이 짧을 경우 JVM은 worker-1만 사용한다. 내부적으로 DefaultDispatcher-worker-1, -2, -3 등이 필요 시 생성&lt;/p>
&lt;h3 id="확인-실험">확인 실험
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() = runBlocking {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> repeat(&lt;span style="color:#ae81ff">10&lt;/span>) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Default dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;IO dispatcher: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> launch(newSingleThreadContext(&lt;span style="color:#e6db74">&amp;#34;MyThread&amp;#34;&lt;/span>)) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Single thread context: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="실행-결과-1">실행 결과
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">6&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Default dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">7&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">3&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">5&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO dispatcher: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Single thread context: MyThread
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="5-코루틴의-스레드-전환">5. 코루틴의 스레드 전환
&lt;/h3>&lt;p>코루틴은 &lt;code>withContext()&lt;/code> 함수를 통해 실행 중인 스레드를 동적으로 전환할 수 있다. 이는 컨텍스트 전환(Context Switch)을 명시적으로 수행하는 것으로, 특정 블록의 실행을 다른 디스패처가 관리하도록 위임하는 방식이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">sample&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Start: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> withContext(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;IO context: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Resume: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>이 구조는 코루틴의 유연성과 구조적 동시성(Structured Concurrency)을 강화하는 핵심 기제로 작용한다.&lt;/p>
&lt;h3 id="실행-결과-2">실행 결과:
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Start: main
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>IO context: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Resume: main
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;hr>
&lt;h3 id="6-동시성과-병렬성">6. 동시성과 병렬성
&lt;/h3>&lt;p>코루틴은 기본적으로 협조적(concurrent) 실행을 지향하나, 다중 디스패처를 활용하면 병렬성(parallelism)도 구현 가능하다. async와 await를 활용하면 서로 독립적인 계산을 동시에 수행하면서 결과를 효율적으로 병합할 수 있다.
다음은 Kotlin의 &lt;code>async&lt;/code>와 &lt;code>await&lt;/code>를 활용하여 두 작업을 병렬로 실행하고, 그 결과를 합산하는 예제이다.&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">// await: 결과가 준비될 때까지 suspend
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">&lt;/span>&lt;span style="color:#66d9ef">val&lt;/span> resultA = async(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.Default) { computeA() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> resultB = async(&lt;span style="color:#a6e22e">Dispatchers&lt;/span>.IO) { computeB() }
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">val&lt;/span> combined = resultA.await() + resultB.await()
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="실행-흐름-설명">실행 흐름 설명
&lt;/h3>&lt;ol>
&lt;li>&lt;code>computeA()&lt;/code>는 &lt;code>Dispatchers.Default&lt;/code> 디스패처에서 실행되며, 이는 CPU 집약적인 작업을 위한 공용 스레드 풀을 사용한다.&lt;/li>
&lt;li>&lt;code>computeB()&lt;/code>는 &lt;code>Dispatchers.IO&lt;/code> 디스패처에서 실행되며, I/O 블로킹 작업에 최적화된 스레드 풀에서 처리된다.&lt;/li>
&lt;li>&lt;code>async&lt;/code>를 통해 두 작업은 &lt;strong>동시에 실행&lt;/strong>되며, 서로 다른 스레드에서 병렬로 수행된다.&lt;/li>
&lt;li>&lt;code>await()&lt;/code>는 각각의 결과가 준비될 때까지 &lt;strong>suspend 상태로 대기&lt;/strong>하며, 이 동안 다른 코루틴이 실행될 수 있다.&lt;/li>
&lt;li>두 &lt;code>await()&lt;/code> 호출이 완료되면 &lt;code>resultA&lt;/code>와 &lt;code>resultB&lt;/code>의 값을 더하여 &lt;code>combined&lt;/code>에 결과를 저장한다.&lt;/li>
&lt;/ol>
&lt;p>이러한 병렬 실행은 코어 수에 따른 스레드 분산을 통해 실행 성능을 높이는 데 효과적이다.&lt;/p>
&lt;h3 id="예시-구현">예시 구현
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">computeA&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Running computeA on: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">500&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">suspend&lt;/span> &lt;span style="color:#66d9ef">fun&lt;/span> &lt;span style="color:#a6e22e">computeB&lt;/span>(): Int {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> println(&lt;span style="color:#e6db74">&amp;#34;Running computeB on: &lt;/span>&lt;span style="color:#e6db74">${Thread.currentThread().name}&lt;/span>&lt;span style="color:#e6db74">&amp;#34;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> delay(&lt;span style="color:#ae81ff">1000&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#ae81ff">20&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h3 id="실행-결과-3">실행 결과:
&lt;/h3>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-kotlin" data-lang="kotlin">&lt;span style="display:flex;">&lt;span>Running computeA on: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>Running computeB on: DefaultDispatcher-worker-&lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>computeA()는 약 500ms 후 10을 반환하고, computeB()는 약 1000ms 후 20을 반환한다. 따라서 combined의 값은 30이다.&lt;/p>
&lt;hr>
&lt;h3 id="7-결론">7. 결론
&lt;/h3>&lt;p>Kotlin의 코루틴은 전통적인 스레드 기반 프로그래밍의 한계를 극복하고, 비동기 처리를 보다 안전하고 구조적으로 구현할 수 있도록 설계되었다. 멀티스레드 환경에서의 코루틴 실행은 디스패처 설정을 통해 세밀히 제어되며, 협조적 실행 모델을 기반으로 하되 병렬 처리를 통해 성능 최적화도 가능하다. 이는 현대 애플리케이션 개발에서 요구되는 고성능 동시 처리 요구를 효과적으로 충족시킨다.&lt;/p></description></item></channel></rss>